---
title: "Sorting"
description: "2023"
date: "2023-01-24"
draft: true
tags:
- interview
---

Sorting is rearranging a collection of items into increasing or decreasing orderâ€”is a common problem in computing.Sorting is used to preprocess the collection to make searching faster.

Naive sorting algorithms run in O(n^2^) time. Sorting algorithms can run in O(nlogn) examples include 
heapsort, mergesort, quicksort. Heapsort is in place but not stable; mergesort is stable but not in place; quicksort runs O(n^2^) time in the worst case. 

Note : An in-place sort is one which uses 0(1) space; a stable sort is one where entries which are equal
appear in their original order.


In Java the time complexity of Arrays.sort(A) is O(nlog n), where n is length of the array A. The space complexity is as high as n/2 object references for randomly ordered input arrays.

Collections.sort(L) internally proceeds by forming an array A, calling Arrays.sort(A) on that array, and then writing the result back into the list L. This implies that the time complexity of Collections.sort(L) is the same as that of Arrays.sort(A). Because of the copy, the space complexity is always 0(n).

1. Compute the intersection of two sorted arrays. 
Write a program which takes as input two sorted arrays, and returns a new array containing elements that are present in both of the input arrays. The input arrays may have duplicate entries, but the returned array should be free of duplicates. For example, the input is (2,3,3,5,5,6,7,7,8,12} and (5,5,6,8,8,9,10,10), your output should be (5,6,8).

Solution :  The brute-force algorithm is a "loop join", i.e., traversing through all the elements of one array and comparing them to the elements of the other array.
```
public static List<Integer> intersectTwoSortedArrays(List<Integer> A,List<Integer> B) {
    List<Integer> intersectionAB = new ArrayList <>();
    for (int i = A; i < A.size(); i++) {
    if (i == 0 || A.get(i) != A.get(i - 1)) {
        for (Integer b : B) {
            if (A.get(i).equals(b)) {
                intersectionAB.add(A.get(i));
                break ;
            }
        }
    }
}
```
Let m and n be the lengths of the two input arrays. The brute-force algorithm has O(mn) time complexity.

Since both the arrays are sorted, we can make some optimizations. First, we can iterate through the first array and use binary search in array to test if the element is present in the second array.

```
public static List<Integer> intersectTwoSortedArrays(List<Integer> A, List<Integer> B) {
    List<Integer> intersectionAB = new ArrayList <>();
    for (int i = 0; i < A.size(); i++) {
        if ((i == 0 || A.get(i) != A.get(i - 1)) && Collections.binarySearch(B, A.get(i)) >= 0) {
            intersectionAB.add(A.get(i));
        }
    }
    return intersectionAB;
}
```
The time complexity is O(mlog n), where m is the length of the array being iterated over. 

This is the best solution if one set is much smaller than the other. However, it is not the best when the array lengths are similar because we are not exploiting the fact that both arrays are sorted.

We can achieve linear runtime by simultaneously advancing through the two input arrays in increasing order. At each iteration, if the array elements differ, the **smaller one can be eliminated**. If they are equal, we add that value to the intersection and advance both.

```
public static List <Integer> intersectTwoSort edArr ays(List <Integer> A, List <Integer> B) {
    List <Integer> intersectionAB = new ArrayList <>() ;
    int i = 0 , j = 0;
    while (i < A.size() && j < B.size()) {
        if (A.get(i) == B.get(j) && (i == 0 || A.get(i) != A.get(i - 1))) {
            intersectionAB.add(A.get(i));
            ++i ;
            ++J ;
        } else if (A.get(i) < B.get(j)) {
            ++i ;
        } else { // A.get(i) > B.get(j)
            ++j ;
        }
}
return intersectionAB;
```
Since we spend O(1) time per input array element, the time complexity for the entire algorithm is O(m + n).

2. Merge two sorted arrays
Write a program which takes as input two sorted arrays of integers, and updates the first to the combined entries of the two arrays in sorted order. Assume the first array has enough empty entries at its end to hold the result. For example, consider (5,13,17,_,_,_,_) and (3,7,11,19), where _ denotes an empty entry. Then the combined sorted entries can be stored in the first array as(3,5,7,11,13,17,19).

Solution : The challenge in this problem lies in writing the result back into the first array if we had a third array to store the result it, we could solve by iterating through the two input arrays in tandem, writing the smaller of the entries into the result. The time complexity is O(m+ n), where m and n are the number of entries initially in the first and second arrays.

We cannot use the above approach with the first array playing the role of the result and still keep the time complexity O(m + n). The reason is that if an entry in the second array is smaller than some entry in the first array, we will have to shift that and all subsequent entries in the first array to the right by 1. In the worst-case, each entry in the second array is smaller than every entry in the first array, and the time complexity is O(mn).
```
public static void mergeTwoSortedArrays(List<Integer> A, int m, List<Integer> B, int n) {
    int a = m - 1, b = n-l, k = m + n - 1;
    while (a >= 0 && b >= 0) {
       if(A.get(a) > B.get(b)){
            A.set(k,A.get(a));
            a--;
       } else{
            A.set(k,B.get(b));
            b--;
       }
       k--;
    }
    while (b >= 0) {
        A .set(k ,B.get(b--));
}
```
3.  Compute the Union of Intervals
