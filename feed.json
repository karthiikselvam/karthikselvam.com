{"version":"https://jsonfeed.org/version/1","title":"Karthik Selvam","home_page_url":"https://karthikselvam.com/","feed_url":"https://ronaldsvilcins.com/feed.json","description":"","icon":"https://ronaldsvilcins.com/assets/apple-touch-icon.png","favicon":"https://ronaldsvilcins.com/assets/favicon.ico","expired":false,"author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"},"items":[{"id":"94c9e75c50f087901721094867a286834fb42616","title":"Understanding OOP concepts","summary":"2023","content_text":"1. What is an Object?\nAn object is an entity in the real world that possesses state (fields) and behaviors (methods). It represents an instance of a class, occupies space in memory, and can communicate with other objects\n2. What is a Class?\nA class is a programming construct that serves as a template or blueprint for creating objects. Unlike objects, classes do not consume memory. Instead, they define the properties and behaviors of objects that can be instantiated multiple times.\n3. What is a Abstraction?\nAbstraction is the concept of exposing to the user only the relevant information while hiding the unnecessary details. This enables the user to focus on what the application does, rather than how it does it.\nLet\u0026rsquo;s consider a real-life example: a man driving a car. The man knows what each pedal does and what the steering wheel does, but he doesn\u0026rsquo;t know how these things are done internally by the car. He doesn\u0026rsquo;t know about the inner mechanisms that empower these things. This is what abstraction is. In Java, abstraction can be achieved via abstract classes and interfaces.\npublic interface Car { public void speedUp(); public void slowDown(); public void turnRight(); public void turnLeft(); public String getCarType(); } Next, each type of car should implement the Car interface and override these methods to provide the implementation of these actions. This implementation is hidden from the user (the man driving the car). For example, the ElectricCar class appears as follows:\npublic class ElectricCar implements Car { private final String carType; public ElectricCar(String carType) { this.carType = carType; } @Override public void speedUp() { System.out.println(\u0026quot;Speed up the electric car\u0026quot;); } @Override public void slowDown() { System.out.println(\u0026quot;Slow down the electric car\u0026quot;); } @Override public void turnRight() { System.out.println(\u0026quot;Turn right the electric car\u0026quot;); } @Override public void turnLeft() { System.out.println(\u0026quot;Turn left the electric car\u0026quot;); } @Override public String getCarType() { return this.carType; } } The user of this class has access to these public methods without being aware of the implementation:\npublic class Main { public static void main(String[] args) { Car electricCar = new ElectricCar(\u0026quot;BMW\u0026quot;); System.out.println(\u0026quot;Driving the electric car: \u0026quot; + electricCar.getCarType() + \u0026quot;\\n\u0026quot;); electricCar.speedUp(); electricCar.turnLeft(); electricCar.slowDown(); } } The output is listed as follows:\nDriving the electric car: BMW Speed up the electric car Turn left the electric car Slow down the electric car 4. What is a Encapsulation?\nEncapsulation is a technique whereby the state of an object is hidden from the outside world, and a set of public methods are exposed for accessing this state. Encapsulation is achieved when each object keeps its state private inside a class. It is known as a data-hiding mechanism, and has several important advantages associated with it, such as enabling loosely coupled, reusable, secure, and easy-to-test code.\nIn Java, encapsulation is implemented through the use of access modifiers such as public, private, and protected.\npublic class Person { private String name; private int age; // Getter method for name public String getName() { return name; } // Setter method for name public void setName(String name) { this.name = name; } // Getter method for age public int getAge() { return age; } // Setter method for age public void setAge(int age) { this.age = age; } } In this example, we have a Person class that encapsulates the state (name and age) of a person object. The state is hidden from the outside world through the use of private access modifiers on the name and age variables. However, public getter and setter methods (getName(), setName(), getAge(), setAge()) are provided for accessing and modifying the state of the object. This allows us to maintain control over the state of the object, ensuring that it remains valid and consistent at all times, while also providing a well-defined interface for other parts of the program to interact with the object.\n5. What is a Inheritance ?\nInheritance is a fundamental concept in object-oriented programming, which allows one class (the child or subclass) to inherit properties and methods from another class (the parent or superclass). This helps to promote code reuse, reduce duplication, and make the code more modular and easier to maintain.\nIn Java, inheritance is achieved through the use of the extends keyword. The child class inherits all the visible properties and methods of the parent class, which can be overridden or extended as needed.\nHere\u0026rsquo;s an example of inheritance in Java:\npublic class Animal { private String name; private int age; public Animal(String name, int age) { this.name = name; this.age = age; } public void eat() { System.out.println(name + \u0026quot; is eating.\u0026quot;); } public void sleep() { System.out.println(name + \u0026quot; is sleeping.\u0026quot;); } } public class Cat extends Animal { public Cat(String name, int age) { super(name, age); } public void meow() { System.out.println(\u0026quot;Meow!\u0026quot;); } @Override public void sleep() { System.out.println(getName() + \u0026quot; is curling up and sleeping.\u0026quot;); } } In this example, we have an Animal class that defines common properties and methods for all animals, such as name and age, and eat() and sleep() methods. The Cat class extends the Animal class, inheriting all its properties and methods, and also adds a new meow() method.\nWe can now create a Cat object and call its methods like this:\nCat cat = new Cat(\u0026quot;Kitty\u0026quot;, 2); cat.eat(); // Output: Kitty is eating. cat.sleep(); // Output: Kitty is curling up and sleeping. cat.meow(); // Output: Meow! In this example, the Cat class has overridden the sleep() method inherited from the Animal class, to provide a more specific implementation for cats. This demonstrates the flexibility and extensibility of inheritance, which allows us to modify the behavior of a class to better fit our needs.\n6. What is a Polymorphism ?\nPolymorphism is a concept in object-oriented programming that enables an object to exhibit different behaviors in certain scenarios. This can be achieved through method overloading, which is a form of compile-time polymorphism, or through method overriding, which is a form of runtime polymorphism and is applicable in the case of an IS-A relationship.\nPolymorphism via method overloading(compile time)\npublic class Calculator { public int add(int a, int b) { return a + b; } public double add(double a, double b) { return a + b; } } Polymorphism via method overriding(runtime)\npublic class Animal { public void makeSound() { System.out.println(\u0026quot;Animal makes a sound\u0026quot;); } } public class Dog extends Animal { @Override public void makeSound() { System.out.println(\u0026quot;Dog barks\u0026quot;); } } public class Cat extends Animal { @Override public void makeSound() { System.out.println(\u0026quot;Cat meows\u0026quot;); } } public class Main { public static void main(String[] args) { Animal animal1 = new Dog(); Animal animal2 = new Cat(); animal1.makeSound(); // Output: Dog barks animal2.makeSound(); // Output: Cat meows } } In the example above, we have an Animal class and two subclasses, Dog and Cat, that extend it. The makeSound method is overridden in each subclass to produce a different sound. In the Main class, we create an instance of Dog and Cat but assign them to variables of type Animal. When the makeSound method is called on each of these objects, the appropriate overridden version of the method is executed, producing \u0026ldquo;Dog barks\u0026rdquo; and \u0026ldquo;Cat meows\u0026rdquo; as output, respectively. This is an example of polymorphism as the same method is called on objects of different types, but the behavior is different depending on the actual type of the object at runtime.\n7. What is a Association ?\nAssociation is a concept in object-oriented programming that describes the relationship between two classes that are independent of each other. An association does not have an owner, and it can take different forms, including one-to-one, one-to-many, many-to-one, and many-to-many, depending on the cardinality and multiplicity of the relationship between the two classes.\nHere is an example of association in Java using a one-to-many relationship:\npublic class Library { private List\u0026lt;Book\u0026gt; books; public Library() { books = new ArrayList\u0026lt;\u0026gt;(); } public void addBook(Book book) { books.add(book); } } public class Book { private String title; private String author; public Book(String title, String author) { this.title = title; this.author = author; } // getters and setters } In this example, the Library class has an association with the Book class. The Library class has a list of Book objects, and it provides a method addBook() to add a book to the list. This is an example of a one-to-many association because a Library can have many Book objects in its list.\nThe Book class, on the other hand, has no knowledge of the Library class. It simply defines the properties of a book such as its title and author. This is an example of unidirectional association.\n8. What is a Aggregation ?\nAggregation is one of the core concepts of OOP. Mainly, aggregation is a special case of unidirectional association. While an association defines the relationship between two classes independent of one another, aggregation represents a HAS-A relationship between these two classes. In other words, two aggregated objects have their own life cycle, but one of the objects is the owner of the HAS-A relationship. Having their own life cycle means that ending one object will not affect the other object. For example, a TennisPlayer has a Racket. This is a unidirectional association since a Racket cannot have a TennisPlayer. Even if the TennisPlayer dies, the Racket is not affected.\nFor example, a TennisPlayer has a Racket. This is a unidirectional association since a Racket cannot have a TennisPlayer. Even if the TennisPlayer dies, the Racket is not affected.\npublic class Racket { private String type; private int size; private int weight; public Racket(String type, int size, int weight) { this.type = type; this.size = size; this.weight = weight; } // getters and setters omitted for brevity } A TennisPlayer HAS-A Racket. Therefore, the TennisPlayer class must be capable of receiving a Racket as follows:\npublic class TennisPlayer { private String name; private Racket racket; public TennisPlayer(String name, Racket racket) { this.name = name; this.racket = racket } // getters and setters omitted for brevity } Next, we create a Racket and a TennisPlayer that uses this Racket:\npublic static void main(String[] args) { Racket racket = new Racket(\u0026quot;Babolat Pure Aero\u0026quot;, 100, 300); TennisPlayer player = new TennisPlayer(\u0026quot;Rafael Nadal\u0026quot;, racket); System.out.println(\u0026quot;Player \u0026quot; + player.getName() + \u0026quot; plays with \u0026quot; + player.getRacket().getType()); } The output is as follows:\nPlayer Rafael Nadal plays with Babolat Pure Aero 9. What is a Composition ?\nComposition is one of the core concepts of OOP. Primarily, composition is a more restrictive case of aggregation. While aggregation represents a HAS-A relationship between two objects having their own life cycle, composition represents a HAS-A relationship that contains an object that cannot exist on its own. In order to highlight this coupling, the HAS-A relationship can be named PART-OF as well. For example, a Car has an Engine. In other words, the engine is PART-OF the car. If the car is destroyed, then the engine is destroyed as well. Composition is said to be better than inheritance because it sustains code reuse and the visibility control of objects.\npublic class Engine { private String type; private int horsepower; public Engine(String type, int horsepower) { this.type = type; this.horsepower = horsepower; } // getters and setters omitted for brevity } Next, we have the Car class. Check out the constructor of this class. Since Engine is part of Car, we create it with the Car.\npublic class Car { private final String name; private final Engine engine; public Car(String name) { this.name = name; Engine engine = new Engine(\u0026quot;petrol\u0026quot;, 300); this.engine=engine; } public int getHorsepower() { return engine.getHorsepower(); } public String getName() { return name; } } we can test composition from the main() method as follows:\npublic static void main(String[] args) { Car car = new Car(\u0026quot;MyCar\u0026quot;); System.out.println(\u0026quot;Horsepower: \u0026quot; + car.getHorsepower()); } output is as follows:\nHorsepower: 300 That\u0026rsquo;s it for OOPS.\n","content_html":"\u003cp\u003e\u003cstrong\u003e1. What is an Object?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAn object is an entity in the real world that possesses state (fields) and behaviors (methods). It represents an instance of a class, occupies space in memory, and can communicate with other objects\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2. What is a Class?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eA class is a programming construct that serves as a template or blueprint for creating objects. Unlike objects, classes do not consume memory. Instead, they define the properties and behaviors of objects that can be instantiated multiple times.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e3. What is a Abstraction?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAbstraction is the concept of exposing to the user only the relevant information while hiding the unnecessary details. This enables the user to focus on what the application does, rather than how it does it.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s consider a real-life example: a man driving a car. The man knows what each pedal does and what the steering wheel does, but he doesn\u0026rsquo;t know how these things are done internally by the car. He doesn\u0026rsquo;t know about the inner mechanisms that empower these things. This is what abstraction is. In Java, abstraction can be achieved via abstract classes and interfaces.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface Car {\n    public void speedUp();\n    public void slowDown();\n    public void turnRight();\n    public void turnLeft();\n    public String getCarType();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, each type of car should implement the Car interface and override these methods to provide the implementation of these actions. This implementation is hidden from the user (the man driving the car). For example, the ElectricCar class appears as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class ElectricCar implements Car {\n    private final String carType;\n\n    public ElectricCar(String carType) {\n        this.carType = carType;\n    } \n\n    @Override\n    public void speedUp() {\n        System.out.println(\u0026quot;Speed up the electric car\u0026quot;);\n    }\n    @Override\n    public void slowDown() {\n        System.out.println(\u0026quot;Slow down the electric car\u0026quot;);\n    }\n\n    @Override\n    public void turnRight() {\n        System.out.println(\u0026quot;Turn right the electric car\u0026quot;);\n    }\n\n    @Override\n    public void turnLeft() {\n        System.out.println(\u0026quot;Turn left the electric car\u0026quot;);\n    }\n    \n    @Override\n    public String getCarType() {\n         return this.carType;\n    } \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe user of this class has access to these public methods without being aware of the implementation:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epublic class Main {\n    public static void main(String[] args) {\n        Car electricCar = new ElectricCar(\u0026quot;BMW\u0026quot;);\n        System.out.println(\u0026quot;Driving the electric car: \u0026quot; + electricCar.getCarType() + \u0026quot;\\n\u0026quot;);\n        electricCar.speedUp();\n        electricCar.turnLeft();\n        electricCar.slowDown();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output is listed as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDriving the electric car: BMW\nSpeed up the electric car\nTurn left the electric car\nSlow down the electric car\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e4. What is a Encapsulation?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eEncapsulation is a technique whereby the state of an object is hidden from the outside world, and a set of public methods are exposed for accessing this state. Encapsulation is achieved when each object keeps its state private inside a class. It is known as a data-hiding mechanism, and has several important advantages associated with it, such as enabling loosely coupled, reusable, secure, and easy-to-test code.\u003c/p\u003e\n\u003cp\u003eIn Java, encapsulation is implemented through the use of access modifiers such as public, private, and protected.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Person {\n  private String name;\n  private int age;\n\n  // Getter method for name\n  public String getName() {\n    return name;\n  }\n\n  // Setter method for name\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  // Getter method for age\n  public int getAge() {\n    return age;\n  }\n\n  // Setter method for age\n  public void setAge(int age) {\n    this.age = age;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, we have a Person class that encapsulates the state (name and age) of a person object. The state is hidden from the outside world through the use of private access modifiers on the name and age variables. However, public getter and setter methods (getName(), setName(), getAge(), setAge()) are provided for accessing and modifying the state of the object. This allows us to maintain control over the state of the object, ensuring that it remains valid and consistent at all times, while also providing a well-defined interface for other parts of the program to interact with the object.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e5. What is a Inheritance ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eInheritance is a fundamental concept in object-oriented programming, which allows one class (the child or subclass) to inherit properties and methods from another class (the parent or superclass). This helps to promote code reuse, reduce duplication, and make the code more modular and easier to maintain.\u003c/p\u003e\n\u003cp\u003eIn Java, inheritance is achieved through the use of the \u003cstrong\u003eextends\u003c/strong\u003e keyword. The child class inherits all the visible properties and methods of the parent class, which can be overridden or extended as needed.\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s an example of inheritance in Java:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Animal {\n  private String name;\n  private int age;\n\n  public Animal(String name, int age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  public void eat() {\n    System.out.println(name + \u0026quot; is eating.\u0026quot;);\n  }\n\n  public void sleep() {\n    System.out.println(name + \u0026quot; is sleeping.\u0026quot;);\n  }\n}\n\npublic class Cat extends Animal {\n  public Cat(String name, int age) {\n    super(name, age);\n  }\n\n  public void meow() {\n    System.out.println(\u0026quot;Meow!\u0026quot;);\n  }\n\n  @Override\n  public void sleep() {\n    System.out.println(getName() + \u0026quot; is curling up and sleeping.\u0026quot;);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, we have an Animal class that defines common properties and methods for all animals, such as name and age, and eat() and sleep() methods. The Cat class extends the Animal class, inheriting all its properties and methods, and also adds a new meow() method.\u003c/p\u003e\n\u003cp\u003eWe can now create a Cat object and call its methods like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCat cat = new Cat(\u0026quot;Kitty\u0026quot;, 2);\ncat.eat(); // Output: Kitty is eating.\ncat.sleep(); // Output: Kitty is curling up and sleeping.\ncat.meow(); // Output: Meow!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, the Cat class has overridden the sleep() method inherited from the Animal class, to provide a more specific implementation for cats. This demonstrates the flexibility and extensibility of inheritance, which allows us to modify the behavior of a class to better fit our needs.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e6. What is a Polymorphism ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003ePolymorphism is a concept in object-oriented programming that enables an object to exhibit different behaviors in certain scenarios. This can be achieved through method overloading, which is a form of compile-time polymorphism, or through method overriding, which is a form of runtime polymorphism and is applicable in the case of an IS-A relationship.\u003c/p\u003e\n\u003cp\u003ePolymorphism via method overloading(compile time)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n    \n    public double add(double a, double b) {\n        return a + b;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePolymorphism via method overriding(runtime)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Animal {\n    public void makeSound() {\n        System.out.println(\u0026quot;Animal makes a sound\u0026quot;);\n    }\n}\n\npublic class Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\u0026quot;Dog barks\u0026quot;);\n    }\n}\n\npublic class Cat extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\u0026quot;Cat meows\u0026quot;);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal animal1 = new Dog();\n        Animal animal2 = new Cat();\n        \n        animal1.makeSound(); // Output: Dog barks\n        animal2.makeSound(); // Output: Cat meows\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn the example above, we have an Animal class and two subclasses, Dog and Cat, that extend it. The makeSound method is overridden in each subclass to produce a different sound. In the Main class, we create an instance of Dog and Cat but assign them to variables of type Animal. When the makeSound method is called on each of these objects, the appropriate overridden version of the method is executed, producing \u0026ldquo;Dog barks\u0026rdquo; and \u0026ldquo;Cat meows\u0026rdquo; as output, respectively. This is an example of polymorphism as the same method is called on objects of different types, but the behavior is different depending on the actual type of the object at runtime.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e7. What is a Association ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAssociation is a concept in object-oriented programming that describes the relationship between two classes that are independent of each other. An association does not have an owner, and it can take different forms, including one-to-one, one-to-many, many-to-one, and many-to-many, depending on the cardinality and multiplicity of the relationship between the two classes.\u003c/p\u003e\n\u003cp\u003eHere is an example of association in Java using a one-to-many relationship:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Library {\n   private List\u0026lt;Book\u0026gt; books;\n\n   public Library() {\n      books = new ArrayList\u0026lt;\u0026gt;();\n   }\n\n   public void addBook(Book book) {\n      books.add(book);\n   }\n}\n\npublic class Book {\n   private String title;\n   private String author;\n\n   public Book(String title, String author) {\n      this.title = title;\n      this.author = author;\n   }\n\n   // getters and setters\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, the Library class has an association with the Book class. The Library class has a list of Book objects, and it provides a method addBook() to add a book to the list. This is an example of a one-to-many association because a Library can have many Book objects in its list.\u003c/p\u003e\n\u003cp\u003eThe Book class, on the other hand, has no knowledge of the Library class. It simply defines the properties of a book such as its title and author. This is an example of unidirectional association.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e8. What is a Aggregation ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAggregation is one of the core concepts of OOP. Mainly, aggregation is a special case of unidirectional association. While an association defines the relationship between two classes independent of one another, aggregation represents a HAS-A relationship between these two classes. In other words, two aggregated objects have their own life cycle, but one of the objects is the owner of the HAS-A relationship. Having their own life cycle means that ending one object will not affect the other object. For example, a TennisPlayer has a Racket. This is a unidirectional association since a Racket cannot have a TennisPlayer. Even if the TennisPlayer dies, the Racket is not affected.\u003c/p\u003e\n\u003cp\u003eFor example, a TennisPlayer has a Racket. This is a unidirectional association since a Racket cannot have a TennisPlayer. Even if the TennisPlayer dies, the Racket is not affected.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Racket {\n    private String type;\n    private int size;\n    private int weight;\n\n    public Racket(String type, int size, int weight) {\n        this.type = type;\n        this.size = size;\n        this.weight = weight;\n    }\n // getters and setters omitted for brevity\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA TennisPlayer HAS-A Racket. Therefore, the TennisPlayer class must be capable of receiving a Racket as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class TennisPlayer {\n    private String name;\n    private Racket racket;\n    \n    public TennisPlayer(String name, Racket racket) {\n        this.name = name;\n        this.racket = racket\n }\n // getters and setters omitted for brevity\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, we create a Racket and a TennisPlayer that uses this Racket:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static void main(String[] args) {\n    Racket racket = new Racket(\u0026quot;Babolat Pure Aero\u0026quot;, 100, 300);\n    TennisPlayer player = new TennisPlayer(\u0026quot;Rafael Nadal\u0026quot;,  racket);\n    System.out.println(\u0026quot;Player \u0026quot; + player.getName() + \u0026quot; plays with \u0026quot; + player.getRacket().getType());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output is as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePlayer Rafael Nadal plays with Babolat Pure Aero\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e9. What is a Composition ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eComposition is one of the core concepts of OOP. Primarily, composition is a more restrictive case of aggregation. While aggregation represents a HAS-A relationship between two objects having their own life cycle, composition represents a HAS-A relationship that contains an object that cannot exist on its own. In order to highlight this coupling, the HAS-A relationship can be named PART-OF as well. For example, a Car has an Engine. In other words, the engine is PART-OF the car. If the car is destroyed, then the engine is destroyed as well. Composition is said to be better than inheritance because it sustains code reuse and the visibility control of objects.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Engine {\n    private String type;\n    private int horsepower;\n    public Engine(String type, int horsepower) {\n        this.type = type;\n        this.horsepower = horsepower;\n    }\n // getters and setters omitted for brevity\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, we have the Car class. Check out the constructor of this class. Since Engine is part of Car, we create it with the Car.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Car {\n    private final String name;\n    private final Engine engine;\n    \n    public Car(String name) {\n        this.name = name;\n        Engine engine = new Engine(\u0026quot;petrol\u0026quot;, 300);\n        this.engine=engine;\n    }\n\n    public int getHorsepower() {\n        return engine.getHorsepower();\n    }\n\n    public String getName() {\n        return name;\n    } \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewe can test composition from the main() method as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static void main(String[] args) {\n    Car car = new Car(\u0026quot;MyCar\u0026quot;);\n    System.out.println(\u0026quot;Horsepower: \u0026quot; + car.getHorsepower());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eoutput is as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eHorsepower: 300\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat\u0026rsquo;s it for OOPS.\u003c/p\u003e\n","url":"https://karthikselvam.com/posts/2023/01/25/oops_concepts/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"25016-25-09T10:2525:00+00:00","date_modified":"25016-25-09T10:2525:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"e6f6a613933a7c246b5ddb2c8d9fa5b114ca460a","title":"Understanding SOLID Principles","summary":"2023","content_text":"SOLID is an acronym of the following:\nS: Single Responsibility Principle O: Open Closed Principle L: Liskov\u0026rsquo;s Substitution Principle I: Interface Segregation Principle D: Dependency Inversion Principle 1. What is Single Responsibility Principle ?\nS stands for One class should have one, and only one, responsibility. S tells us to write a class for only one goal. As long as we write a class for only one goal, we will sustain high maintainability and visibility control across the application modules. In other words, by sustaining high maintainability, this principle has a significant business impact, and by providing visibility control across the application modules, this principle sustains encapsulation.\nFor example, the following class computes the area and converts it to inches:\npublic class RectangleAreaCalculator { private static final double INCH_TERM = 0.0254d; private final int width; private final int height; public RectangleAreaCalculator(int width, int height) { this.width = width; this.height = height; } public int area() { return width * height; } // this method breaks SRP public double metersToInches(int area) { return area / INCH_TERM; } } The situation can be remedied by removing the metersToInches() method from RectangleAreaCalculator, as follows:\npublic class RectangleAreaCalculator { private final int width; private final int height; public RectangleAreaCalculator(int width, int height) { this.width = width; this.height = height; } public int area() { return width * height; } } Now, RectangleAreaCalculator does only one thing (it computes the rectangle area), thereby observing the SRP.\nNext, metersToInches() can be extracted in a separate class.\npublic class AreaConverter { private static final double INCH_TERM = 0.0254d; private static final double FEET_TERM = 0.3048d; public double metersToInches(int area) { return area / INCH_TERM; } public double metersToFeet(int area) { return area / FEET_TERM; } } 2. What is Open Closed Principle ?\nO stands for Software components should be open for extension, but closed for modification. O sustains the fact that our classes should not contain constraints that will require other developers to modify our classes in order to accomplish their job – other developers should only extend our classes to accomplish their job.\nEach shape will implement the Shape interface. Therefore, the code is pretty straightforward:\npublic interface Shape { } public class Rectangle implements Shape { private final int width; rivate final int height; // constructor and getters omitted for brevity } public class Circle implements Shape { private final int radius; // constructor and getter omitted for brevity } At this point, we can easily use the constructors of these classes to create rectangles and circles of different sizes. Once we have several shapes, we want to sum their areas. For this, we can define an AreaCalculator class as follows:\npublic class AreaCalculator { private final List\u0026lt;Shape\u0026gt; shapes; public AreaCalculator(List\u0026lt;Shape\u0026gt; shapes) { this.shapes = shapes; } // adding more shapes requires us to modify this class // this code is not OCP compliant public double sum() { int sum = 0; for (Shape shape : shapes) { if (shape.getClass().equals(Circle.class)) { sum += Math.PI * Math.pow(((Circle) shape).getRadius(), 2); } else if(shape.getClass().equals(Rectangle.class)) { sum += ((Rectangle) shape).getHeight() * ((Rectangle) shape).getWidth(); } } return sum; } } Since each shape has its own formula for area, we require an if-else (or switch) structure to determine the type of shape. Furthermore, if we want to add a new shape (for example, a triangle), we have to modify the AreaCalculator class to add a new if case. This means that the preceding code breaks the OCP.\nThe main idea is to extract from AreaCalculator the area formula of each shape in the corresponding Shape class. Hence, the rectangle will compute its area, the circle as well, and so on. To enforce the fact that each shape must calculate its area, we add the area() method to the Shape contract:\npublic interface Shape { public double area(); } Next, Rectangle and Circle implements Shape as follows:\npublic class Rectangle implements Shape { private final int width; private final int height; public Rectangle(int width, int height) { this.width = width; this.height = height; } public double area() { return width * height; } } public class Circle implements Shape { private final int radius; public Circle(int radius) { this.radius = radius; } @Override public double area() { return Math.PI * Math.pow(radius, 2); } } Now, the AreaCalculator can loop the list of shapes and sum the areas by calling the proper area() method.\npublic class AreaCalculator { private final List\u0026lt;Shape\u0026gt; shapes; public AreaCalculator(List\u0026lt;Shape\u0026gt; shapes) { this.shapes = shapes; } public double sum() { int sum = 0; for (Shape shape : shapes) { sum += shape.area(); } return sum; } } 3. What is Liskov\u0026rsquo;s Substitution Principle ?\nL stands for Derived types must be completely substitutable for their base types. L sustains the fact that objects of subclasses must behave in the same way as the objects of superclasses, so every subclass (or derived class) should be capable of substituting their superclass without any issues. Most of the time, this is useful for runtime-type identification followed by the cast. For example, consider foo(p), where p is of the type T. Then, foo(q) should work fine if q is of the type S and S is a subtype of T.\nSuppose we have a class hierarchy for different shapes, with a base class Shape and two derived classes Circle and Rectangle. Each class has a method area() to calculate the area of the shape.\npublic abstract class Shape { public abstract double area(); } public class Circle extends Shape { private double radius; public Circle(double radius) { this.radius = radius; } @Override public double area() { return 3.14 * radius * radius; } } public class Rectangle extends Shape { private double length; private double width; public Rectangle(double length, double width) { this.length = length; this.width = width; } @Override public double area() { return length * width; } } Now suppose we have a method calculateTotalArea that takes an array of shapes and returns the total area of all the shapes in the array:\npublic static double calculateTotalArea(Shape[] shapes) { double totalArea = 0.0; for (Shape shape : shapes) { totalArea += shape.area(); } return totalArea; } According to Liskov\u0026rsquo;s Substitution Principle, we should be able to pass an array of Circle or Rectangle objects to this method without any problems, since both classes inherit from the Shape base class and implement the area() method.\nCircle circle = new Circle(5); Rectangle rectangle = new Rectangle(3, 4); Shape[] shapes = {circle, rectangle}; double totalArea = calculateTotalArea(shapes); // returns 83.5 This demonstrates that the Circle and Rectangle classes can be used interchangeably with the Shape class, without causing any errors or unexpected behavior in the program.\n4. What is Interface Segregation Principle ?\nI stands for the Interface Segregation Principle (ISP). I stands for Clients should not be forced to implement unnecessary methods that they will not use.\nThis principle stands for Clients should not be forced to implement unnecessary methods that they will not use. In other words, we should split an interface into two or more interfaces until clients are not forced to implement methods that they will not use. For example, consider the Connection interface, which has three methods: connect(), socket(), and http().\npublic interface Connection { public void socket(); public void http(); public void connect(); } WwwPingConnection is a class that pings different websites via HTTP; hence, it requires the http() method, but doesn\u0026rsquo;t need the socket() method. Notice the dummy socket() implementation – since WwwPingConnection implements Connection, it is forced to provide an implementation to the socket() method as well:\npublic class WwwPingConnection implements Connection { private final String www; public WwwPingConnection(String www) { this.www = www; } @Override public void http() { System.out.println(\u0026quot;Setup an HTTP connection to \u0026quot; + www); } @Override public void connect() { System.out.println(\u0026quot;Connect to \u0026quot; + www); } // this method breaks Interface Segregation Principle @Override public void socket() { } } Having an empty implementation or throwing a meaningful exception from methods that are not needed, such as socket(), is a really ugly solution. Check the following code:\nWwwPingConnection www = new WwwPingConnection 'www.yahoo.com'); www.socket(); // we can call this method! www.connect(); What do we expect to obtain from this code? A working code that does nothing, or an exception caused by the connect() method because there is no HTTP endpoint? Or, we can throw an exception from socket() of the type: Socket is not supported!. Then, why is it here?! Hence, it is now time to refactor the code to follow the ISP. In order to comply with the ISP, we need to segregate the Connection interface. Since the connect() method is required by any client, we leave it in this interface.\npublic interface Connection { public void connect(); } The http() and socket() methods are distributed in to separate interfaces that extend the Connection interface as follows:\npublic interface HttpConnection extends Connection { public void http(); } public interface SocketConnection extends Connection { public void socket(); } This time, the WwwPingConnection class can implement only the HttpConnection interface and use the http() method:\npublic class WwwPingConnection implements HttpConnection { private final String www; public WwwPingConnection(String www) { this.www = www; } @Override public void http() { System.out.println(\u0026quot;Setup an HTTP connection to \u0026quot; + www); } @Override public void connect() { System.out.println(\u0026quot;Connect to \u0026quot; + www); } } 5. What is Dependency Inversion Principle ?\nD stands for the Dependency Inversion Principle. This principle stands for Depend on abstractions, not on concretions. This means that we should rely on abstract layers to bind concrete modules together instead of having concrete modules that depend on other concrete modules. To accomplish this, all concrete modules should expose abstractions only.\nA database JDBC URL, PostgreSQLJdbcUrl, can be a low-level module, while a class that connects to the database may represent a high-level module, such as ConnectToDatabase#connect().\npublic class PostgreSQLJdbcUrl { private final String dbName; public PostgreSQLJdbcUrl(String dbName) { this.dbName = dbName; } public String get() { return \u0026quot;jdbc:// ... \u0026quot; + this.dbName; } } public class ConnectToDatabase { public void connect(PostgreSQLJdbcUrl postgresql) { System.out.println(\u0026quot;Connecting to \u0026quot; + postgresql.get()); } } If we create another type of JDBC URL (for example, MySQLJdbcUrl), then we cannot use the preceding connect(PostgreSQLJdbcUrl postgreSQL) method. So, we have to drop this dependency on concrete and create a dependency on abstraction.\nThe abstraction can be represented by an interface that should be implemented by each type of JDBC URL\npublic interface JdbcUrl { public String get(); } Next, PostgreSQLJdbcUrl implements JdbcUrl to return a JDBC URL specific to PostgreSQL databases:\npublic class PostgreSQLJdbcUrl implements JdbcUrl { private final String dbName; public PostgreSQLJdbcUrl(String dbName) { this.dbName = dbName; } @Override public String get() { return \u0026quot;jdbc:// ... \u0026quot; + this.dbName; } } In precisely the same manner, we can write MySQLJdbcUrl, OracleJdbcUrl, and so on. Finally, the ConnectToDatabase#connect() method is dependent on the JdbcUrl abstraction, so it can connect to any JDBC URL that implements this abstraction.\npublic class ConnectToDatabase { public void connect(JdbcUrl jdbcUrl) { System.out.println(\u0026quot;Connecting to \u0026quot; + jdbcUrl.get()); } } That\u0026rsquo;s it, now you have solid understanding of SOLID principles.\n","content_html":"\u003cp\u003eSOLID is an acronym of the following:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eS: Single Responsibility Principle\u003c/li\u003e\n\u003cli\u003eO: Open Closed Principle\u003c/li\u003e\n\u003cli\u003eL: Liskov\u0026rsquo;s Substitution Principle\u003c/li\u003e\n\u003cli\u003eI: Interface Segregation Principle\u003c/li\u003e\n\u003cli\u003eD: Dependency Inversion Principle\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e1. What is Single Responsibility Principle ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eS stands for One class should have one, and only one, responsibility. S tells us to write a class for only one goal. As long as we write a class for only one goal, we will sustain high maintainability and visibility control across the application modules. In other words, by sustaining high maintainability, this principle has a significant business impact, and by providing visibility control across the application modules, this principle sustains encapsulation.\u003c/p\u003e\n\u003cp\u003eFor example, the following class computes the area and converts it to inches:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class RectangleAreaCalculator {\n    private static final double INCH_TERM = 0.0254d;\n    private final int width;\n    private final int height;\n    \n    public RectangleAreaCalculator(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n    \n    public int area() {\n        return width * height;\n    }\n    \n    // this method breaks SRP\n    public double metersToInches(int area) {\n        return area / INCH_TERM;\n    } \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe situation can be remedied by removing the metersToInches() method from RectangleAreaCalculator, as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class RectangleAreaCalculator {\n    private final int width;\n    private final int height;\n    \n    public RectangleAreaCalculator(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n \n    public int area() {\n        return width * height;\n    } \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, RectangleAreaCalculator does only one thing (it computes the rectangle area), thereby observing the SRP.\u003c/p\u003e\n\u003cp\u003eNext, metersToInches() can be extracted in a separate class.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class AreaConverter {\n    private static final double INCH_TERM = 0.0254d;\n    private static final double FEET_TERM = 0.3048d;\n    \n    public double metersToInches(int area) {\n        return area / INCH_TERM;\n    }\n    \n    public double metersToFeet(int area) {\n        return area / FEET_TERM;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e2. What is Open Closed Principle ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eO stands for Software components should be open for extension, but closed for modification. O sustains the fact that our classes should not contain constraints that will require other developers to modify our classes in order to accomplish their job – other developers should only extend our classes to accomplish their job.\u003c/p\u003e\n\u003cp\u003eEach shape will implement the Shape interface. Therefore, the code is pretty straightforward:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public interface Shape { \n    }\n    \n    public class Rectangle implements Shape {\n        private final int width;\n        rivate final int height;\n        // constructor and getters omitted for brevity\n    }\n    \n    public class Circle implements Shape {\n        private final int radius;\n        // constructor and getter omitted for brevity\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAt this point, we can easily use the constructors of these classes to create rectangles and circles of different sizes. Once we have several shapes, we want to sum their areas. For this, we can define an AreaCalculator class as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public class AreaCalculator {\n        private final List\u0026lt;Shape\u0026gt; shapes;\n        public AreaCalculator(List\u0026lt;Shape\u0026gt; shapes) {\n            this.shapes = shapes;\n    }\n \n    // adding more shapes requires us to modify this class\n    // this code is not OCP compliant\n    public double sum() {\n        int sum = 0;\n        for (Shape shape : shapes) {\n            if (shape.getClass().equals(Circle.class)) {\n                sum += Math.PI * Math.pow(((Circle) shape).getRadius(), 2);\n            } else \n            if(shape.getClass().equals(Rectangle.class)) {\n                sum += ((Rectangle) shape).getHeight() * ((Rectangle) shape).getWidth();\n            }\n        }\n        return sum;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSince each shape has its own formula for area, we require an if-else (or switch) structure to determine the type of shape. Furthermore, if we want to add a new shape (for example, a triangle), we have to modify the AreaCalculator class to add a new if case. This means that the preceding code breaks the OCP.\u003c/p\u003e\n\u003cp\u003eThe main idea is to extract from AreaCalculator the area formula of each shape in the corresponding Shape class. Hence, the rectangle will compute its area, the circle as well, and so on. To enforce the fact that each shape must calculate its area, we add the area() method to the Shape contract:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface Shape { \n    public double area();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, Rectangle and Circle implements Shape as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e public class Rectangle implements Shape {\n    private final int width;\n    private final int height;\n\n public Rectangle(int width, int height) {\n    this.width = width;\n    this.height = height;\n }\n\n  public double area() {\n    return width * height;\n }\n}\n\npublic class Circle implements Shape {\n    private final int radius;\n    public Circle(int radius) {\n        this.radius = radius;\n    }\n \n    @Override\n    public double area() {\n        return Math.PI * Math.pow(radius, 2);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, the AreaCalculator can loop the list of shapes and sum the areas by calling the  proper area() method.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class AreaCalculator {\n    private final List\u0026lt;Shape\u0026gt; shapes;\n    public AreaCalculator(List\u0026lt;Shape\u0026gt; shapes) {\n        this.shapes = shapes;\n    }\n\n     public double sum() {\n        int sum = 0;\n        for (Shape shape : shapes) {\n            sum += shape.area();\n        }\n        return sum;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e3. What is Liskov\u0026rsquo;s Substitution Principle ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eL stands for Derived types must be completely substitutable for their base types. L sustains the fact that objects of subclasses must behave in the same way as the objects of superclasses, so every subclass (or derived class) should be capable of substituting their superclass without any issues. Most of the time, this is useful for runtime-type identification followed by the cast. For example, consider foo(p), where p is of the type T. Then, foo(q) should work fine if q is of the type S and S is a subtype of T.\u003c/p\u003e\n\u003cp\u003eSuppose we have a class hierarchy for different shapes, with a base class Shape and two derived classes Circle and Rectangle. Each class has a method area() to calculate the area of the shape.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic abstract class Shape {\n    public abstract double area();\n}\n\npublic class Circle extends Shape {\n    private double radius;\n\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n\n    @Override\n    public double area() {\n        return 3.14 * radius * radius;\n    }\n}\n\npublic class Rectangle extends Shape {\n    private double length;\n    private double width;\n\n    public Rectangle(double length, double width) {\n        this.length = length;\n        this.width = width;\n    }\n\n    @Override\n    public double area() {\n        return length * width;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow suppose we have a method calculateTotalArea that takes an array of shapes and returns the total area of all the shapes in the array:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epublic static double calculateTotalArea(Shape[] shapes) {\n    double totalArea = 0.0;\n    for (Shape shape : shapes) {\n        totalArea += shape.area();\n    }\n    return totalArea;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAccording to Liskov\u0026rsquo;s Substitution Principle, we should be able to pass an array of Circle or Rectangle objects to this method without any problems, since both classes inherit from the Shape base class and implement the area() method.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCircle circle = new Circle(5);\nRectangle rectangle = new Rectangle(3, 4);\nShape[] shapes = {circle, rectangle};\ndouble totalArea = calculateTotalArea(shapes); // returns 83.5\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis demonstrates that the Circle and Rectangle classes can be used interchangeably with the Shape class, without causing any errors or unexpected behavior in the program.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e4. What is Interface Segregation Principle ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI stands for the Interface Segregation Principle (ISP). I stands for Clients should not be forced to implement unnecessary methods that they will not use.\u003c/p\u003e\n\u003cp\u003eThis principle stands for Clients should not be forced to implement unnecessary methods that they will not use. In other words, we should split an interface into two or more interfaces until clients are not forced to implement methods that they will not use. For example, consider the Connection interface, which has three methods: connect(), socket(), and http().\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface Connection {\n    public void socket();\n    public void http();\n    public void connect();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWwwPingConnection is a class that pings different websites via HTTP; hence, it requires the http() method, but doesn\u0026rsquo;t need the socket() method. Notice the dummy socket() implementation – since WwwPingConnection implements Connection, it is forced to provide an implementation to the socket() method as well:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class WwwPingConnection implements Connection {\n    private final String www;\n\n    public WwwPingConnection(String www) {\n        this.www = www;\n    }\n\n    @Override\n    public void http() {\n        System.out.println(\u0026quot;Setup an HTTP connection to \u0026quot; + www);\n    }\n\n    @Override\n    public void connect() {\n    System.out.println(\u0026quot;Connect to \u0026quot; + www);\n    }\n\n    // this method breaks Interface Segregation Principle\n    @Override\n    public void socket() {\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHaving an empty implementation or throwing a meaningful exception from methods that are not needed, such as socket(), is a really ugly solution. Check the following code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eWwwPingConnection www = new WwwPingConnection 'www.yahoo.com');\nwww.socket(); // we can call this method!\nwww.connect();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhat do we expect to obtain from this code? A working code that does nothing, or an  exception caused by the connect() method because there is no HTTP endpoint? Or, we  can throw an exception from socket() of the type: Socket is not supported!. Then, why is  it here?! Hence, it is now time to refactor the code to follow the ISP. In order to comply with the ISP, we need to segregate the Connection interface. Since the connect() method is required by any client, we leave it in this interface.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface Connection {\n    public void connect();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe http() and socket() methods are distributed in to separate interfaces that extend the Connection interface as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface HttpConnection extends Connection {\n    public void http();\n    }\npublic interface SocketConnection extends Connection {\n    public void socket();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis time, the WwwPingConnection class can implement only the HttpConnection interface and use the http() method:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class WwwPingConnection implements HttpConnection {\n    private final String www;\n    \n    public WwwPingConnection(String www) {\n        this.www = www;\n    }\n\n    @Override\n    public void http() {\n        System.out.println(\u0026quot;Setup an HTTP connection to \u0026quot; + www);\n    }\n \n    @Override\n    public void connect() {\n        System.out.println(\u0026quot;Connect to \u0026quot; + www);\n    } \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e5. What is Dependency Inversion Principle ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eD stands for the Dependency Inversion Principle. This principle stands for Depend on abstractions, not on concretions. This means that we should rely on abstract layers to bind concrete modules together instead of having concrete modules that depend on other concrete modules. To accomplish this, all concrete modules should expose abstractions only.\u003c/p\u003e\n\u003cp\u003eA database JDBC URL, PostgreSQLJdbcUrl, can be a low-level module, while a class that connects to the database may represent a high-level module, such as ConnectToDatabase#connect().\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class PostgreSQLJdbcUrl {\n    private final String dbName;\n    public PostgreSQLJdbcUrl(String dbName) {\n        this.dbName = dbName;\n    }\n    public String get() {\n        return \u0026quot;jdbc:// ... \u0026quot; + this.dbName;\n    }\n}\n\npublic class ConnectToDatabase {\n    public void connect(PostgreSQLJdbcUrl postgresql) {\n        System.out.println(\u0026quot;Connecting to \u0026quot; + postgresql.get());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf we create another type of JDBC URL (for example, MySQLJdbcUrl), then we cannot use the preceding connect(PostgreSQLJdbcUrl postgreSQL) method. So, we have to drop this dependency on concrete and create a dependency on abstraction.\u003c/p\u003e\n\u003cp\u003eThe abstraction can be represented by an interface that should be implemented by each type of JDBC URL\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epublic interface JdbcUrl {\n    public String get();\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, PostgreSQLJdbcUrl implements JdbcUrl to return a JDBC URL specific to PostgreSQL databases:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class PostgreSQLJdbcUrl implements JdbcUrl {\n    private final String dbName;\n\n    public PostgreSQLJdbcUrl(String dbName) {\n        this.dbName = dbName;\n    }\n\n    @Override\n    public String get() {\n        return \u0026quot;jdbc:// ... \u0026quot; + this.dbName;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn precisely the same manner, we can write MySQLJdbcUrl, OracleJdbcUrl, and so on. Finally, the ConnectToDatabase#connect() method is dependent on the JdbcUrl abstraction, so it can connect to any JDBC URL that implements this abstraction.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class ConnectToDatabase {\n    public void connect(JdbcUrl jdbcUrl) {\n        System.out.println(\u0026quot;Connecting to \u0026quot; + jdbcUrl.get());\n }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat\u0026rsquo;s it, now you have solid understanding of SOLID principles.\u003c/p\u003e\n","url":"https://karthikselvam.com/posts/2023/01/24/solid_principles/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"24016-24-09T10:2424:00+00:00","date_modified":"24016-24-09T10:2424:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"cd31544a69cbb5c629dff9b7ba853f94a9fcbd76","title":"Capacity Estimation on the fly","summary":"2023","content_text":"Capacity estimation is a crucial component of system design interviews, and it can be quite challenging if one is not adequately prepared. However, with the right approach, it is possible to accurately estimate the storage, bandwidth, and memory/cache requirements needed for a particular system. This article provides a comprehensive framework for capacity estimation, which will enable you to confidently tackle capacity-related questions during system design interviews.\nTypically following estimates are required :\nStorage Bandwidth Memory/Cache Assumptions:\n1. Storage Estimates\nSingle character requires 2 bytes, while long and double require 8 bytes of space. An average photo takes up 200 KB of space, while a high-quality photo takes up 2 MB of space. For videos, we assume 50 MB of space per minute of video. Examples:\nSocial media: tweet can be assumed 140 char then 140*2 bytes = 280 bytes tweet. Tiny URL: Average URL length \u0026lt;100 char. Longer URLs needing tiny URL will generally be more than 150 char, lets say 200 char. then each URL assume as 200*2 = 400 bytes Database id or price etc field can be double or long so 8 bytes per field. 2. Traffic estimates\nFor social media applications like Facebook, Instagram, Twitter we can assume 1 billion total users, with 500 million daily active users. A chat application like WhatsApp, and Facebook Messenger, has 500 million total users, with 100 million daily active users. For video streaming applications like YouTube, Netflix, and Hulu, we can assume 1 billion total users, with 800 million daily active users. For cloud or file storage applications like Google Drive, Dropbox, and Microsoft OneDrive, we can assume 1 billion total users, with 500 million daily active users. 3. Time Assumptions\nA year has 365 days, so 5 years have 1825 days, which we round up to 2000 days. A day has 24 hours, which is 86400 seconds, which we round up to 100,000 seconds. Capacity Estimation for Social Media application\nAssuming each post or tweet has 140 characters, and each character requires 2 bytes, each tweet or post has a size of approximately 300 bytes. Let’s assume 1 billion total users and 500 million daily active users, we can assume that 10 million users post photos daily, with an average size of 200 KB. Using these assumptions, we can calculate the following:\nStorage: Text data storage: 300 bytes x 500,000,000 = 150,000,000,000 = 150 GB of tweet/post data per day Photo storage: 200 KB x 10,000,000 = 2,000 GB = 2 TB per day.\nTotal storage for 5 years: 150 GB x 2000 days = 300,000 GB = 300 TB for tweet/post data, and 2 TB x 2000 days = 4,000 TB for photos.\nBandwidth: Text data bandwidth: 150 GB per day / 100,000 seconds = 1.5 MB per second Photo bandwidth: 2 TB per day / 100,000 seconds = 200 MB per second\nMemory/Cache: Assuming we want to cache 20 posts/tweets per user, 300 bytes * 500,000,000 daily users * 20 = 150 GB * 20 = 3000 GB = 3 TB of cache. If one machine/server can keep 150 GB of cache, we need 20 machines/servers for caching.\nCapacity Estimation for TinyURL\nAssuming the average length of a URL is 100 characters, and each character requires 2 bytes, each URL has a size of approximately 200 bytes. Let’s assume 1 billion total users, 100 million daily active users. So 100 million urls are generated per day. Using these assumptions, we can calculate the following:\nStorage: URL data storage: 200 bytes x 100,000,000 = 20,000,000,000 = 20 GB per day\nTotal storage for 5 years: 20 GB per day x 2000 days = 40,000 GB = 40 TB\nBandwidth: URL bandwidth: 20 GB per day / 100,000 seconds = 0.2 MB per second.\nMemory/Cache: Assuming we want to cache 20 urls per user, 200 bytes * 100,000,000 daily users * 20 = 20 GB * 20 = 400 GB of cache. If one machine/server can keep 150 GB of cache, we need 3 machines/servers for caching.\nThe framework outlined above provides a clear approach to tackle capacity estimation problems during interviews.\n","content_html":"\u003cp\u003eCapacity estimation is a crucial component of system design interviews, and it can be quite challenging if one is not adequately prepared. However, with the right approach, it is possible to accurately estimate the storage, bandwidth, and memory/cache requirements needed for a particular system. This article provides a comprehensive framework for capacity estimation, which will enable you to confidently tackle capacity-related questions during system design interviews.\u003c/p\u003e\n\u003cp\u003eTypically following estimates are required :\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eStorage\u003c/li\u003e\n\u003cli\u003eBandwidth\u003c/li\u003e\n\u003cli\u003eMemory/Cache\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003cp\u003eAssumptions:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. Storage Estimates\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSingle character requires 2 bytes, while long and double require 8 bytes of space.\u003c/li\u003e\n\u003cli\u003eAn average photo takes up 200 KB of space, while a high-quality photo takes up 2 MB of space.\u003c/li\u003e\n\u003cli\u003eFor videos, we assume 50 MB of space per minute of video.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eExamples:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSocial media: tweet can be assumed 140 char then 140*2 bytes = 280 bytes tweet.\u003c/li\u003e\n\u003cli\u003eTiny URL: Average URL length \u0026lt;100 char. Longer URLs needing tiny URL will generally be more than 150 char, lets say 200 char. then each URL assume as 200*2 = 400 bytes\u003c/li\u003e\n\u003cli\u003eDatabase id or price etc field can be double or long so 8 bytes per field.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e2. Traffic estimates\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFor social media applications like Facebook, Instagram, Twitter we can assume 1 billion total users, with 500 million daily active users.\u003c/li\u003e\n\u003cli\u003eA chat application like WhatsApp, and Facebook Messenger, has 500 million total users, with 100 million daily active users.\u003c/li\u003e\n\u003cli\u003eFor video streaming applications like YouTube, Netflix, and Hulu, we can assume 1 billion total users, with 800 million daily active users.\u003c/li\u003e\n\u003cli\u003eFor cloud or file storage applications like Google Drive, Dropbox, and Microsoft OneDrive, we can assume 1 billion total users, with 500 million daily active users.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e3. Time Assumptions\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA year has 365 days, so 5 years have 1825 days, which we round up to 2000 days.\u003c/li\u003e\n\u003cli\u003eA day has 24 hours, which is 86400 seconds, which we round up to 100,000 seconds.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003eCapacity Estimation for Social Media application\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAssuming each post or tweet has 140 characters, and each character requires 2 bytes, each tweet or post has a size of approximately 300 bytes. Let’s assume 1 billion total users and 500 million daily active users, we can assume that 10 million users post photos daily, with an average size of 200 KB. Using these assumptions, we can calculate the following:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eStorage\u003c/strong\u003e:\nText data storage: 300 bytes x 500,000,000 = 150,000,000,000 = 150 GB of tweet/post data per day\nPhoto storage: 200 KB x 10,000,000 = 2,000 GB = 2 TB per day.\u003c/p\u003e\n\u003cp\u003eTotal storage for 5 years: 150 GB x 2000 days = 300,000 GB = 300 TB for tweet/post data, and 2 TB x 2000 days = 4,000 TB for photos.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBandwidth\u003c/strong\u003e:\nText data bandwidth: 150 GB per day / 100,000 seconds = 1.5 MB per second\nPhoto bandwidth: 2 TB per day / 100,000 seconds = 200 MB per second\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eMemory/Cache\u003c/strong\u003e:\nAssuming we want to cache 20 posts/tweets per user, 300 bytes * 500,000,000 daily users * 20 = 150 GB * 20 = 3000 GB = 3 TB of cache. If one machine/server can keep 150 GB of cache, we need 20 machines/servers for caching.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003eCapacity Estimation for TinyURL\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAssuming the average length of a URL is 100 characters, and each character requires 2 bytes, each URL has a size of approximately 200 bytes. Let’s assume 1 billion total users, 100 million daily active users. So 100 million urls are generated per day. Using these assumptions, we can calculate the following:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eStorage\u003c/strong\u003e:\nURL data storage: 200 bytes x 100,000,000 = 20,000,000,000 = 20 GB per day\u003c/p\u003e\n\u003cp\u003eTotal storage for 5 years: 20 GB per day x 2000 days = 40,000 GB = 40 TB\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBandwidth\u003c/strong\u003e:\nURL bandwidth: 20 GB per day / 100,000 seconds = 0.2 MB per second.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eMemory/Cache\u003c/strong\u003e:\nAssuming we want to cache 20 urls per user, 200 bytes * 100,000,000 daily users * 20 = 20 GB * 20 = 400 GB of cache. If one machine/server can keep 150 GB of cache, we need 3 machines/servers for caching.\u003c/p\u003e\n\u003cp\u003eThe framework outlined above provides a clear approach to tackle capacity estimation problems during interviews.\u003c/p\u003e\n","url":"https://karthikselvam.com/posts/2023/01/23/capacity_estimation/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"23016-23-09T10:2323:00+00:00","date_modified":"23016-23-09T10:2323:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"0d76f1d072960250b22ed281f11c16b9618e7027","title":"Fundamentals of Multithreading","summary":"2023","content_text":"1. Thread creation : In Java, you can create a thread by either extending the Thread class or implementing the Runnable interface. Here\u0026rsquo;s how you can do it:\nExtending the Thread class: public class MyThread extends Thread { public void run() { // code to be executed in this thread } } You can create an instance of the MyThread class and start the thread using the start() method:\nMyThread myThread = new MyThread(); myThread.start(); Implementing the Runnable interface: public class MyRunnable implements Runnable { public void run() { // code to be executed in this thread } } You can create an instance of the MyRunnable class and pass it to a Thread object\u0026rsquo;s constructor:\nMyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); thread.start(); In both cases, the run() method contains the code that will be executed when the thread is started. You should not call the run() method directly, but rather use the start() method to start the thread.\n2. Thread Termination : Following are reasons to terminate a thread:\nThreads in a computer consume various resources, such as memory, kernel resources, CPU cycles, and cache memory.\nIf a thread finished its work, but the application is still running we want to clean up the thread\u0026rsquo;s resources.\nIf a thread is misbehaving, we want to stop it.\nThe application will not stop as long as at least one thread is still running.\nIn Java, you can terminate a thread by calling the interrupt() method on the thread object. This method sets a flag on the thread to indicate that it should stop executing. However, it is up to the thread\u0026rsquo;s code to check for the interrupt flag and terminate gracefully.\npublic class MyThread extends Thread { @Override public void run() { while (!Thread.currentThread().isInterrupted()) { // do some work } System.out.println(\u0026quot;Thread is terminating.\u0026quot;); } } public class Main { public static void main(String[] args) { MyThread thread = new MyThread(); thread.start(); // Interrupt the thread thread.interrupt(); } } In this example, the MyThread class extends the Thread class and overrides the run() method to do some work in a loop. Inside the loop, the thread checks if it has been interrupted using the isInterrupted() method.\nIn the Main class, we create an instance of MyThread and start it. When the interrupt() method is called, the isInterrupted() method in the MyThread class will return true, causing the thread to exit the loop and terminate gracefully.\n3. Daemon Threads : In Java, a daemon thread is a type of thread that runs in the background and does not prevent the Java Virtual Machine (JVM) from exiting when the program finishes execution.\nDaemon threads are typically used for tasks that need to run continuously in the background, such as garbage collection or other system-level tasks. They are also commonly used in server applications to perform tasks like cleaning up old connections or handling periodic maintenance tasks.\nTo create a daemon thread in Java, you can use the setDaemon() method on a Thread object. For example, the following code creates a new thread and sets it as a daemon thread:\nThread myThread = new Thread(new Runnable() { public void run() { // Do some background task here } }); myThread.setDaemon(true); myThread.start(); Once a thread is set as a daemon thread, you cannot change it back to a non-daemon thread.\n4. Joining Threads :\nJoining threads in Java is done using the join() method, which allows one thread to wait for another thread to complete before continuing. Here\u0026rsquo;s a simple example of how to use the join() method to join two threads:\npublic class JoinExample { public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u0026gt; { System.out.println(\u0026quot;Thread 1 is running\u0026quot;); try { Thread.sleep(2000); // simulate some work being done } catch (InterruptedException e) { System.out.println(\u0026quot;Thread 1 was interrupted\u0026quot;); } System.out.println(\u0026quot;Thread 1 is finished\u0026quot;); }); Thread t2 = new Thread(() -\u0026gt; { System.out.println(\u0026quot;Thread 2 is running\u0026quot;); try { Thread.sleep(1000); // simulate some work being done } catch (InterruptedException e) { System.out.println(\u0026quot;Thread 2 was interrupted\u0026quot;); } System.out.println(\u0026quot;Thread 2 is finished\u0026quot;); }); t1.start(); t2.start(); // wait for both threads to finish t1.join(); t2.join(); System.out.println(\u0026quot;Both threads have finished\u0026quot;); } } In this example, we create two threads t1 and t2 and start them. We then use the join() method to wait for both threads to finish before printing out a message indicating that both threads have finished.\nWhen t1.join() and t2.join() are called, the main thread will block and wait until both t1 and t2 have finished executing. Once both threads have completed, the main thread will continue executing and print out the final message.\n5. Resource Sharing in Threads\nIn Java, resource sharing can be achieved using the concept of synchronized monitors. A synchronized monitor is a mechanism that allows only one thread to access a shared resource at a time.\nTo use synchronized monitors in Java, you can use the synchronized keyword to define a block of code that needs to be executed by only one thread at a time. The synchronized keyword can be applied to a method or a block of code.\nHere\u0026rsquo;s an example of using synchronized monitors to share a resource in Java:\npublic class SharedResource { private int value; public synchronized void increment() { value++; } public synchronized int getValue() { return value; } } public class ResourceSharingExample { public static void main(String[] args) { SharedResource sharedResource = new SharedResource(); // create multiple threads to access the shared resource Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { sharedResource.increment(); } }); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { sharedResource.increment(); } }); // start the threads t1.start(); t2.start(); // wait for the threads to finish try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } // print the final value of the shared resource System.out.println(\u0026quot;Value: \u0026quot; + sharedResource.getValue()); } } In this example, the SharedResource class represents a shared resource that contains a single integer value. The increment() method and getValue() method are both marked as synchronized, which means that only one thread can access them at a time.\nThe ResourceSharingExample class creates two threads that access the shared resource using the increment() method. The threads run concurrently, but because of the synchronized monitors, only one thread can execute the increment() method at a time. The final value of the shared resource is printed at the end of the program, which should be 2000 in this case.\nWe also achieve some result using Object lock instead of synchronized monitors in Java.\npublic class SharedResource { private int value; private final Object lock = new Object(); public void increment() { synchronized (lock) { value++; } } public int getValue() { synchronized (lock) { return value; } } } public class ResourceSharingExample { public static void main(String[] args) { SharedResource sharedResource = new SharedResource(); // create multiple threads to access the shared resource Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { sharedResource.increment(); } }); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { sharedResource.increment(); } }); // start the threads t1.start(); t2.start(); // wait for the threads to finish try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } // print the final value of the shared resource System.out.println(\u0026quot;Value: \u0026quot; + sharedResource.getValue()); } } Using mutiple object locks threads can access the shared resources concurrently without interfering with each other.\npublic class SharedResource { private int value1; private int value2; private final Object lock1 = new Object(); private final Object lock2 = new Object(); public void incrementValue1() { synchronized (lock1) { value1++; } } public int getValue1() { synchronized (lock1) { return value1; } } public void incrementValue2() { synchronized (lock2) { value2++; } } public int getValue2() { synchronized (lock2) { return value2; } } } public class ResourceSharingExample { public static void main(String[] args) { SharedResource sharedResource = new SharedResource(); // create multiple threads to access the shared resource Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { sharedResource.incrementValue1(); } }); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { sharedResource.incrementValue2(); } }); // start the threads t1.start(); t2.start(); // wait for the threads to finish try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } // print the final values of the shared resources System.out.println(\u0026quot;Value1: \u0026quot; + sharedResource.getValue1()); System.out.println(\u0026quot;Value2: \u0026quot; + sharedResource.getValue2()); } } In this example, the SharedResource class contains two object locks, lock1 and lock2, and two methods for each value, incrementValue1(), getValue1(), incrementValue2(), and getValue2(). The incrementValue1() method and getValue1() method use lock1 to synchronize access to value1, while the incrementValue2() method and getValue2() method use lock2 to synchronize access to value2.\nThe ResourceSharingExample class creates two threads that access the shared resources using incrementValue1() and incrementValue2() methods. Because two different object locks are used to synchronize access to two different values, the threads can access the shared resources concurrently without interfering with each other. The final values of the shared resources are printed at the end of the program.\n6. Reentrant lock\nA ReentrantLock is a synchronization mechanism in Java that provides a way to protect shared resources from simultaneous access by multiple threads. It is called \u0026ldquo;reentrant\u0026rdquo; because a thread that already holds the lock can acquire it again without blocking, unlike traditional synchronization using the synchronized keyword.\nimport java.util.concurrent.locks.ReentrantLock; public class SharedResource { private int value; private ReentrantLock lock = new ReentrantLock(); public void incrementValue() { lock.lock(); try { value++; } finally { lock.unlock(); } } public int getValue() { lock.lock(); try { return value; } finally { lock.unlock(); } } } public class ResourceSharingExample { public static void main(String[] args) { SharedResource sharedResource = new SharedResource(); // create multiple threads to access the shared resource Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { sharedResource.incrementValue(); } }); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { sharedResource.incrementValue(); } }); // start the threads t1.start(); t2.start(); // wait for the threads to finish try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } // print the final value of the shared resource System.out.println(\u0026quot;Value: \u0026quot; + sharedResource.getValue()); } } In this example, the SharedResource class contains a single ReentrantLock and two methods for incrementing and retrieving the value variable. The lock object is used to synchronize access to the value variable.\nThe ResourceSharingExample class creates two threads that access the shared resource using the incrementValue() method. Because a ReentrantLock is used to synchronize access to the shared resource, the threads can access the shared resource concurrently without interfering with each other.\nReentrantLock is like a special key that allows threads to take turns accessing a shared resource. And if a thread already has the key, it can use it again without waiting in line. It provides query methods for testing lock\u0026rsquo;s internal state.\nExample of using ReentrantLock and tryLock() method in Java:\nimport java.util.concurrent.locks.ReentrantLock; public class Example { public static void main(String[] args) { ReentrantLock lock = new ReentrantLock(); // acquire the lock using tryLock() method boolean isLockAcquired = lock.tryLock(); if (isLockAcquired) { try { // perform critical section operations here System.out.println(\u0026quot;Lock acquired and critical section entered.\u0026quot;); } finally { // release the lock lock.unlock(); System.out.println(\u0026quot;Lock released.\u0026quot;); } } else { System.out.println(\u0026quot;Could not acquire lock. Another thread is holding the lock.\u0026quot;); } } } Example of using ReentrantReadWriteLock and tryLock() method in Java:\nimport java.util.HashMap; import java.util.Map; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class Example { private Map\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); private ReadWriteLock lock = new ReentrantReadWriteLock(); public void put(String key, String value) { lock.writeLock().lock(); // acquire write lock try { map.put(key, value); // perform write operation } finally { lock.writeLock().unlock(); // release write lock } } public String get(String key) { lock.readLock().lock(); // acquire read lock try { return map.get(key); // perform read operation } finally { lock.readLock().unlock(); // release read lock } } } In this example, we have a Map object that is accessed by multiple threads. To ensure thread safety and prevent race conditions, we use a ReadWriteLock to control access to the map.\nThe put() method acquires a write lock using the writeLock() method, performs a write operation on the map, and then releases the write lock using the unlock() method.\nThe get() method acquires a read lock using the readLock() method, performs a read operation on the map, and then releases the read lock using the unlock() method.\nWith this approach, multiple threads can simultaneously read from the map, but only one thread can write to the map at a time. This can significantly improve performance in scenarios where reads are much more frequent than writes.\n7. Volatile Keyword\nIn Java, the volatile keyword is used as a modifier to indicate that a variable\u0026rsquo;s value may be modified by multiple threads at the same time.\nWhen a variable is marked as volatile, the JVM ensures that any write to that variable is immediately visible to other threads that may access it. This means that changes made to the variable by one thread will be immediately reflected in the value seen by other threads. Without the volatile keyword, there is no guarantee that changes made by one thread will be immediately visible to another thread, which can lead to hard-to-detect bugs.\nThe volatile keyword can be used with any primitive type, as well as with references to objects. However, it\u0026rsquo;s important to note that using volatile does not provide atomicity, which means that if multiple threads try to modify the same variable at the same time, race conditions and inconsistencies can still occur.\nIn general, the volatile keyword should only be used when there is a specific need for multiple threads to access the same variable, and the programmer is sure that the volatile variable will be accessed in a safe and consistent way.\nHere\u0026rsquo;s an example to illustrate the use of volatile keyword in Java:\npublic class Counter { private volatile int count; public synchronized void increment() { count++; } public int getCount() { return count; } } In this example, we have a Counter class with a private volatile integer field called count. The increment() method is used to increment the value of count by one, and the getCount() method returns the current value of count.\nWithout the volatile keyword, there is no guarantee that changes made to count by one thread will be immediately visible to another thread. However, since count is marked as volatile, the JVM ensures that any write to count is immediately visible to other threads that may access it.\nConsider the following example usage of the Counter class by multiple threads:\npublic class Main { public static void main(String[] args) { Counter counter = new Counter(); Thread thread1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 10000; i++) { counter.increment(); } }); Thread thread2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 10000; i++) { counter.increment(); } }); thread1.start(); thread2.start(); try { thread1.join(); thread2.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026quot;Final count: \u0026quot; + counter.getCount()); } } In this example, we create two threads, thread1 and thread2, which both increment the Counter object\u0026rsquo;s count field 10,000 times. We then wait for both threads to complete using the join() method, and output the final value of count.\nWithout the volatile keyword on the count field in the Counter class, there is no guarantee that the final value of count will be 20,000. However, with count marked as volatile, we can be sure that changes made by one thread will be immediately visible to the other thread, and the final value of count will be 20,000.\n8. Deadlocks In Java, a deadlock occurs when two or more threads are blocked, waiting for each other to release the locks they hold. As a result, none of the threads can make progress and the program hangs.\nHere\u0026rsquo;s an example to illustrate how a deadlock can occur in Java:\npublic class DeadlockExample { private Object lock1 = new Object(); private Object lock2 = new Object(); public void method1() { synchronized (lock1) { System.out.println(\u0026quot;Acquired lock1 in method1\u0026quot;); try { Thread.sleep(1000); } catch (InterruptedException e) {} synchronized (lock2) { System.out.println(\u0026quot;Acquired lock2 in method1\u0026quot;); } } } public void method2() { synchronized (lock2) { System.out.println(\u0026quot;Acquired lock2 in method2\u0026quot;); try { Thread.sleep(1000); } catch (InterruptedException e) {} synchronized (lock1) { System.out.println(\u0026quot;Acquired lock1 in method2\u0026quot;); } } } public static void main(String[] args) { final DeadlockExample example = new DeadlockExample(); Thread thread1 = new Thread(new Runnable() { public void run() { example.method1(); } }); Thread thread2 = new Thread(new Runnable() { public void run() { example.method2(); } }); thread1.start(); thread2.start(); } } In this example, there are two methods, method1() and method2(), which each synchronize on a different lock. The main() method creates two threads that each call one of these methods.\nNow, suppose that thread1 acquires lock1 and then calls method2(), which tries to acquire lock2. At the same time, thread2 has already acquired lock2 and is trying to acquire lock1. Both threads are blocked waiting for the other thread to release its lock, causing a deadlock.\nDeadlock can occur in a concurrent system when the following conditions are met:\nMutual Exclusion: At least one resource is held in a mutually exclusive mode, meaning only one thread can use it at a time.\nHold and Wait: A thread is holding at least one resource and is waiting to acquire additional resources that are currently held by other threads.\nNo Preemption: Resources cannot be preempted or taken away from threads that are holding them. The only way to release a resource is for the thread to voluntarily release it.\nCircular Wait: A circular chain of threads exists, where each thread is waiting for a resource that is held by the next thread in the chain. In other words, there is a cycle in the resource allocation graph.\nTo avoid deadlocks, you can use some techniques like:\nAcquire locks in a fixed order.\nUse timeouts when acquiring locks to avoid indefinitely waiting for a lock.\nUse tryLock() instead of synchronized blocks to acquire locks in a non-blocking way.\nUse higher-level concurrency utilities like java.util.concurrent classes, which handle synchronization and - locking automatically.\n","content_html":"\u003cp\u003e\u003cstrong\u003e1. Thread creation\u003c/strong\u003e : In Java, you can create a thread by either extending the Thread class or implementing the Runnable interface. Here\u0026rsquo;s how you can do it:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eExtending the Thread class:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class MyThread extends Thread {\n    public void run() {\n        // code to be executed in this thread\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can create an instance of the MyThread class and start the thread using the start() method:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eMyThread myThread = new MyThread();\nmyThread.start();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eImplementing the Runnable interface:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class MyRunnable implements Runnable {\n    public void run() {\n        // code to be executed in this thread\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can create an instance of the MyRunnable class and pass it to a Thread object\u0026rsquo;s constructor:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eMyRunnable myRunnable = new MyRunnable();\nThread thread = new Thread(myRunnable);\nthread.start();\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn both cases, the run() method contains the code that will be executed when the thread is started. You should not call the run() method directly, but rather use the start() method to start the thread.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e2. Thread Termination\u003c/strong\u003e :\nFollowing are reasons to terminate a thread:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThreads in a computer consume various resources, such as memory, kernel resources, CPU cycles, and cache memory.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIf a thread finished its work, but the application is still running we want to clean up the thread\u0026rsquo;s resources.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIf a thread is misbehaving, we want to stop it.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe application will not stop as long as at least one thread is still running.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn Java, you can terminate a thread by calling the interrupt() method on the thread object. This method sets a flag on the thread to indicate that it should stop executing. However, it is up to the thread\u0026rsquo;s code to check for the interrupt flag and terminate gracefully.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class MyThread extends Thread {\n    @Override\n    public void run() {\n        while (!Thread.currentThread().isInterrupted()) {\n            // do some work\n        }\n        System.out.println(\u0026quot;Thread is terminating.\u0026quot;);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        MyThread thread = new MyThread();\n        thread.start();\n\n        // Interrupt the thread\n        thread.interrupt();\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, the MyThread class extends the Thread class and overrides the run() method to do some work in a loop. Inside the loop, the thread checks if it has been interrupted using the isInterrupted() method.\u003c/p\u003e\n\u003cp\u003eIn the Main class, we create an instance of MyThread and start it. When the interrupt() method is called, the isInterrupted() method in the MyThread class will return true, causing the thread to exit the loop and terminate gracefully.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e3. Daemon Threads\u003c/strong\u003e :\nIn Java, a daemon thread is a type of thread that runs in the background and does not prevent the Java Virtual Machine (JVM) from exiting when the program finishes execution.\u003c/p\u003e\n\u003cp\u003eDaemon threads are typically used for tasks that need to run continuously in the background, such as garbage collection or other system-level tasks. They are also commonly used in server applications to perform tasks like cleaning up old connections or handling periodic maintenance tasks.\u003c/p\u003e\n\u003cp\u003eTo create a daemon thread in Java, you can use the setDaemon() method on a Thread object. For example, the following code creates a new thread and sets it as a daemon thread:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eThread myThread = new Thread(new Runnable() {\n    public void run() {\n        // Do some background task here\n    }\n});\nmyThread.setDaemon(true);\nmyThread.start();\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOnce a thread is set as a daemon thread, you cannot change it back to a non-daemon thread.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e4. Joining Threads\u003c/strong\u003e :\u003c/p\u003e\n\u003cp\u003eJoining threads in Java is done using the join() method, which allows one thread to wait for another thread to complete before continuing. Here\u0026rsquo;s a simple example of how to use the join() method to join two threads:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class JoinExample {\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread t1 = new Thread(() -\u0026gt; {\n            System.out.println(\u0026quot;Thread 1 is running\u0026quot;);\n            try {\n                Thread.sleep(2000); // simulate some work being done\n            } catch (InterruptedException e) {\n                System.out.println(\u0026quot;Thread 1 was interrupted\u0026quot;);\n            }\n            System.out.println(\u0026quot;Thread 1 is finished\u0026quot;);\n        });\n\n        Thread t2 = new Thread(() -\u0026gt; {\n            System.out.println(\u0026quot;Thread 2 is running\u0026quot;);\n            try {\n                Thread.sleep(1000); // simulate some work being done\n            } catch (InterruptedException e) {\n                System.out.println(\u0026quot;Thread 2 was interrupted\u0026quot;);\n            }\n            System.out.println(\u0026quot;Thread 2 is finished\u0026quot;);\n        });\n\n        t1.start();\n        t2.start();\n\n        // wait for both threads to finish\n        t1.join();\n        t2.join();\n\n        System.out.println(\u0026quot;Both threads have finished\u0026quot;);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, we create two threads t1 and t2 and start them. We then use the join() method to wait for both threads to finish before printing out a message indicating that both threads have finished.\u003c/p\u003e\n\u003cp\u003eWhen t1.join() and t2.join() are called, the main thread will block and wait until both t1 and t2 have finished executing. Once both threads have completed, the main thread will continue executing and print out the final message.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e5. Resource Sharing in Threads\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIn Java, resource sharing can be achieved using the concept of synchronized monitors. A synchronized monitor is a mechanism that allows only one thread to access a shared resource at a time.\u003c/p\u003e\n\u003cp\u003eTo use synchronized monitors in Java, you can use the synchronized keyword to define a block of code that needs to be executed by only one thread at a time. The synchronized keyword can be applied to a method or a block of code.\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s an example of using synchronized monitors to share a resource in Java:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SharedResource {\n    private int value;\n\n    public synchronized void increment() {\n        value++;\n    }\n\n    public synchronized int getValue() {\n        return value;\n    }\n}\n\npublic class ResourceSharingExample {\n    public static void main(String[] args) {\n        SharedResource sharedResource = new SharedResource();\n\n        // create multiple threads to access the shared resource\n        Thread t1 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 1000; i++) {\n                sharedResource.increment();\n            }\n        });\n\n        Thread t2 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 1000; i++) {\n                sharedResource.increment();\n            }\n        });\n\n        // start the threads\n        t1.start();\n        t2.start();\n\n        // wait for the threads to finish\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // print the final value of the shared resource\n        System.out.println(\u0026quot;Value: \u0026quot; + sharedResource.getValue());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, the SharedResource class represents a shared resource that contains a single integer value. The increment() method and getValue() method are both marked as synchronized, which means that only one thread can access them at a time.\u003c/p\u003e\n\u003cp\u003eThe ResourceSharingExample class creates two threads that access the shared resource using the increment() method. The threads run concurrently, but because of the synchronized monitors, only one thread can execute the increment() method at a time. The final value of the shared resource is printed at the end of the program, which should be 2000 in this case.\u003c/p\u003e\n\u003cp\u003eWe also achieve some result using Object lock instead of synchronized monitors in Java.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SharedResource {\n    private int value;\n    private final Object lock = new Object();\n\n    public void increment() {\n        synchronized (lock) {\n            value++;\n        }\n    }\n\n    public int getValue() {\n        synchronized (lock) {\n            return value;\n        }\n    }\n}\n\npublic class ResourceSharingExample {\n    public static void main(String[] args) {\n        SharedResource sharedResource = new SharedResource();\n\n        // create multiple threads to access the shared resource\n        Thread t1 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 1000; i++) {\n                sharedResource.increment();\n            }\n        });\n\n        Thread t2 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 1000; i++) {\n                sharedResource.increment();\n            }\n        });\n\n        // start the threads\n        t1.start();\n        t2.start();\n\n        // wait for the threads to finish\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // print the final value of the shared resource\n        System.out.println(\u0026quot;Value: \u0026quot; + sharedResource.getValue());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUsing mutiple object locks threads can access the shared resources concurrently without interfering with each other.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SharedResource {\n    private int value1;\n    private int value2;\n    private final Object lock1 = new Object();\n    private final Object lock2 = new Object();\n\n    public void incrementValue1() {\n        synchronized (lock1) {\n            value1++;\n        }\n    }\n\n    public int getValue1() {\n        synchronized (lock1) {\n            return value1;\n        }\n    }\n\n    public void incrementValue2() {\n        synchronized (lock2) {\n            value2++;\n        }\n    }\n\n    public int getValue2() {\n        synchronized (lock2) {\n            return value2;\n        }\n    }\n}\n\npublic class ResourceSharingExample {\n    public static void main(String[] args) {\n        SharedResource sharedResource = new SharedResource();\n\n        // create multiple threads to access the shared resource\n        Thread t1 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 1000; i++) {\n                sharedResource.incrementValue1();\n            }\n        });\n\n        Thread t2 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 1000; i++) {\n                sharedResource.incrementValue2();\n            }\n        });\n\n        // start the threads\n        t1.start();\n        t2.start();\n\n        // wait for the threads to finish\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // print the final values of the shared resources\n        System.out.println(\u0026quot;Value1: \u0026quot; + sharedResource.getValue1());\n        System.out.println(\u0026quot;Value2: \u0026quot; + sharedResource.getValue2());\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, the SharedResource class contains two object locks, lock1 and lock2, and two methods for each value, incrementValue1(), getValue1(), incrementValue2(), and getValue2(). The incrementValue1() method and getValue1() method use lock1 to synchronize access to value1, while the incrementValue2() method and getValue2() method use lock2 to synchronize access to value2.\u003c/p\u003e\n\u003cp\u003eThe ResourceSharingExample class creates two threads that access the shared resources using incrementValue1() and incrementValue2() methods. Because two different object locks are used to synchronize access to two different values, the \u003cstrong\u003ethreads can access the shared resources concurrently without interfering with each other\u003c/strong\u003e. The final values of the shared resources are printed at the end of the program.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e6. Reentrant lock\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eA ReentrantLock is a synchronization mechanism in Java that provides a way to protect shared resources from simultaneous access by multiple threads. It is called \u0026ldquo;reentrant\u0026rdquo; because a thread that already holds the lock can acquire it again without blocking, unlike traditional synchronization using the synchronized keyword.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eimport java.util.concurrent.locks.ReentrantLock;\n\npublic class SharedResource {\n    private int value;\n    private ReentrantLock lock = new ReentrantLock();\n\n    public void incrementValue() {\n        lock.lock();\n        try {\n            value++;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public int getValue() {\n        lock.lock();\n        try {\n            return value;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic class ResourceSharingExample {\n    public static void main(String[] args) {\n        SharedResource sharedResource = new SharedResource();\n\n        // create multiple threads to access the shared resource\n        Thread t1 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 1000; i++) {\n                sharedResource.incrementValue();\n            }\n        });\n\n        Thread t2 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 1000; i++) {\n                sharedResource.incrementValue();\n            }\n        });\n\n        // start the threads\n        t1.start();\n        t2.start();\n\n        // wait for the threads to finish\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // print the final value of the shared resource\n        System.out.println(\u0026quot;Value: \u0026quot; + sharedResource.getValue());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, the SharedResource class contains a single ReentrantLock and two methods for incrementing and retrieving the value variable. The lock object is used to synchronize access to the value variable.\u003c/p\u003e\n\u003cp\u003eThe ResourceSharingExample class creates two threads that access the shared resource using the incrementValue() method. Because a ReentrantLock is used to synchronize access to the shared resource, the threads can access the shared resource concurrently without interfering with each other.\u003c/p\u003e\n\u003cp\u003eReentrantLock is like a special key that allows threads to take turns accessing a shared resource. And if a thread already has the key, it can use it again without waiting in line. It provides query methods for testing lock\u0026rsquo;s internal state.\u003c/p\u003e\n\u003cp\u003eExample of using ReentrantLock and tryLock() method in Java:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Example {\n    public static void main(String[] args) {\n        ReentrantLock lock = new ReentrantLock();\n\n        // acquire the lock using tryLock() method\n        boolean isLockAcquired = lock.tryLock();\n\n        if (isLockAcquired) {\n            try {\n                // perform critical section operations here\n                System.out.println(\u0026quot;Lock acquired and critical section entered.\u0026quot;);\n            } finally {\n                // release the lock\n                lock.unlock();\n                System.out.println(\u0026quot;Lock released.\u0026quot;);\n            }\n        } else {\n            System.out.println(\u0026quot;Could not acquire lock. Another thread is holding the lock.\u0026quot;);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eExample of using ReentrantReadWriteLock and tryLock() method in Java:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\npublic class Example {\n    private Map\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;();\n    private ReadWriteLock lock = new ReentrantReadWriteLock();\n\n    public void put(String key, String value) {\n        lock.writeLock().lock(); // acquire write lock\n        try {\n            map.put(key, value); // perform write operation\n        } finally {\n            lock.writeLock().unlock(); // release write lock\n        }\n    }\n\n    public String get(String key) {\n        lock.readLock().lock(); // acquire read lock\n        try {\n            return map.get(key); // perform read operation\n        } finally {\n            lock.readLock().unlock(); // release read lock\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, we have a Map object that is accessed by multiple threads. To ensure thread safety and prevent race conditions, we use a ReadWriteLock to control access to the map.\u003c/p\u003e\n\u003cp\u003eThe put() method acquires a write lock using the writeLock() method, performs a write operation on the map, and then releases the write lock using the unlock() method.\u003c/p\u003e\n\u003cp\u003eThe get() method acquires a read lock using the readLock() method, performs a read operation on the map, and then releases the read lock using the unlock() method.\u003c/p\u003e\n\u003cp\u003eWith this approach, multiple threads can simultaneously read from the map, but only one thread can write to the map at a time. This can significantly improve performance in scenarios where reads are much more frequent than writes.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e7. Volatile Keyword\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIn Java, the volatile keyword is used as a modifier to indicate that a variable\u0026rsquo;s value may be modified by multiple threads at the same time.\u003c/p\u003e\n\u003cp\u003eWhen a variable is marked as volatile, the JVM ensures that any write to that variable is immediately visible to other threads that may access it. This means that changes made to the variable by one thread will be immediately reflected in the value seen by other threads. Without the volatile keyword, there is no guarantee that changes made by one thread will be immediately visible to another thread, which can lead to hard-to-detect bugs.\u003c/p\u003e\n\u003cp\u003eThe volatile keyword can be used with any primitive type, as well as with references to objects. However, it\u0026rsquo;s important to note that using volatile does not provide atomicity, which means that if multiple threads try to modify the same variable at the same time, race conditions and inconsistencies can still occur.\u003c/p\u003e\n\u003cp\u003eIn general, the volatile keyword should only be used when there is a specific need for multiple threads to access the same variable, and the programmer is sure that the volatile variable will be accessed in a safe and consistent way.\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s an example to illustrate the use of volatile keyword in Java:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Counter {\n    private volatile int count;\n\n    public synchronized void increment() {\n        count++;\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, we have a Counter class with a private volatile integer field called count. The increment() method is used to increment the value of count by one, and the getCount() method returns the current value of count.\u003c/p\u003e\n\u003cp\u003eWithout the volatile keyword, there is no guarantee that changes made to count by one thread will be immediately visible to another thread. However, since count is marked as volatile, the JVM ensures that any write to count is immediately visible to other threads that may access it.\u003c/p\u003e\n\u003cp\u003eConsider the following example usage of the Counter class by multiple threads:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Main {\n    public static void main(String[] args) {\n        Counter counter = new Counter();\n\n        Thread thread1 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 10000; i++) {\n                counter.increment();\n            }\n        });\n\n        Thread thread2 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 10000; i++) {\n                counter.increment();\n            }\n        });\n\n        thread1.start();\n        thread2.start();\n\n        try {\n            thread1.join();\n            thread2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(\u0026quot;Final count: \u0026quot; + counter.getCount());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, we create two threads, thread1 and thread2, which both increment the Counter object\u0026rsquo;s count field 10,000 times. We then wait for both threads to complete using the join() method, and output the final value of count.\u003c/p\u003e\n\u003cp\u003eWithout the volatile keyword on the count field in the Counter class, there is no guarantee that the final value of count will be 20,000. However, with count marked as volatile, we can be sure that changes made by one thread will be immediately visible to the other thread, and the final value of count will be 20,000.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e8. Deadlocks\u003c/strong\u003e\nIn Java, a deadlock occurs when two or more threads are blocked, waiting for each other to release the locks they hold. As a result, none of the threads can make progress and the program hangs.\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s an example to illustrate how a deadlock can occur in Java:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class DeadlockExample {\n    private Object lock1 = new Object();\n    private Object lock2 = new Object();\n\n    public void method1() {\n        synchronized (lock1) {\n            System.out.println(\u0026quot;Acquired lock1 in method1\u0026quot;);\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {}\n            synchronized (lock2) {\n                System.out.println(\u0026quot;Acquired lock2 in method1\u0026quot;);\n            }\n        }\n    }\n\n    public void method2() {\n        synchronized (lock2) {\n            System.out.println(\u0026quot;Acquired lock2 in method2\u0026quot;);\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {}\n            synchronized (lock1) {\n                System.out.println(\u0026quot;Acquired lock1 in method2\u0026quot;);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        final DeadlockExample example = new DeadlockExample();\n        Thread thread1 = new Thread(new Runnable() {\n            public void run() {\n                example.method1();\n            }\n        });\n        Thread thread2 = new Thread(new Runnable() {\n            public void run() {\n                example.method2();\n            }\n        });\n        thread1.start();\n        thread2.start();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, there are two methods, method1() and method2(), which each synchronize on a different lock. The main() method creates two threads that each call one of these methods.\u003c/p\u003e\n\u003cp\u003eNow, suppose that thread1 acquires lock1 and then calls method2(), which tries to acquire lock2. At the same time, thread2 has already acquired lock2 and is trying to acquire lock1. Both threads are blocked waiting for the other thread to release its lock, causing a deadlock.\u003c/p\u003e\n\u003cp\u003eDeadlock can occur in a concurrent system when the following conditions are met:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMutual Exclusion: At least one resource is held in a mutually exclusive mode, meaning only one thread can use it at a time.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHold and Wait: A thread is holding at least one resource and is waiting to acquire additional resources that are currently held by other threads.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eNo Preemption: Resources cannot be preempted or taken away from threads that are holding them. The only way to release a resource is for the thread to voluntarily release it.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCircular Wait: A circular chain of threads exists, where each thread is waiting for a resource that is held by the next thread in the chain. In other words, there is a cycle in the resource allocation graph.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo avoid deadlocks, you can use some techniques like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eAcquire locks in a fixed order.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eUse timeouts when acquiring locks to avoid indefinitely waiting for a lock.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eUse tryLock() instead of synchronized blocks to acquire locks in a non-blocking way.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eUse higher-level concurrency utilities like java.util.concurrent classes, which handle synchronization and - locking automatically.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","url":"https://karthikselvam.com/posts/2023/01/23/threads/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"23016-23-09T10:2323:00+00:00","date_modified":"23016-23-09T10:2323:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"f7d5285750b0c221397309ad910af98f154422a2","title":"Handling Transactions in Microservices","summary":"2023","content_text":"Handling transactions involving more than one microservice can be challenging since each microservice typically has its own data store and transaction management. However, there are several best practices that can help to ensure consistency and reliability across microservices:\nThe Saga pattern: This involves breaking the transaction into multiple smaller transactions, each of which is handled by a separate microservice. If a transaction fails, the other services can be rolled back, ensuring that the system remains consistent. Let\u0026rsquo;s say you have a system where a user can place an order that involves multiple microservices. The order might involve checking inventory levels, processing payments, and shipping products. You can use the Saga pattern to handle this transaction by breaking it down into smaller transactions, each handled by a separate microservice. If one of the transactions fails, the other transactions can be rolled back, ensuring that the system remains consistent. For example, the payment service fails to process a payment. The shipping service can be notified to cancel the shipment, and the inventory service can be notified to restock the item. This ensures that the system remains consistent even though one of the transactions failed.\nDistributed transaction coordinator: A distributed transaction coordinator can help to manage transactions across multiple microservices. The coordinator can ensure that all transactions are either committed or rolled back as a single unit, ensuring consistency across the system.For example, you could use a tool like Apache Kafka to implement a distributed transaction coordinator. When a user places an order, the order microservice can publish a message to a Kafka topic. Each microservice that needs to handle the transaction can subscribe to the topic and perform its own transaction. If one of the microservices fails, the coordinator can ensure that all transactions are either committed or rolled back as a single unit, ensuring consistency across the system.\nCompensating transactions: A compensating transaction is a transaction that undoes the effects of a previous transaction. This can be used to handle failures in the system by rolling back the changes made by previous transactions and restoring the system to its previous state.For example, Let\u0026rsquo;s say you have a system where a user can transfer money between accounts. This transaction involves two microservices: one to debit the account and another to credit the account. If the credit service fails, you can use a compensating transaction to handle the failure. The debit service can be notified to reverse the debit transaction, ensuring that the system remains consistent.\nEvent-driven architectures: In an event-driven architecture, each microservice publishes events when it completes a transaction. Other microservices can subscribe to these events and use them to trigger their own transactions. This can help to ensure consistency across the system and reduce the risk of failures.For example, Let\u0026rsquo;s say you have a system where a user can place an order that involves multiple microservices. Each microservice can publish an event when it completes a transaction. For example, the inventory service can publish an event when it updates the inventory level, and the shipping service can publish an event when it ships the product. Other microservices can subscribe to these events and use them to trigger their own transactions. This can help to ensure consistency across the system and reduce the risk of failures.\nIdempotency: Idempotency is the property of a system where performing the same operation multiple times has the same result as performing it once. By designing microservices to be idempotent, you can reduce the risk of failures and ensure consistency across the system.For example, Let\u0026rsquo;s say you have a system where a user can update their profile information. To ensure idempotency, you can design the microservice to only update the profile if the request includes a unique identifier, such as a UUID. If the same request is made multiple times, the microservice will recognize the duplicate request and return the same result as the original request. This ensures that the system remains consistent even if the same request is made multiple times.\n","content_html":"\u003cp\u003eHandling transactions involving more than one microservice can be challenging since each microservice typically has its own data store and transaction management. However, there are several best practices that can help to ensure consistency and reliability across microservices:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eThe Saga pattern\u003c/strong\u003e: This involves breaking the transaction into multiple smaller transactions, each of which is handled by a separate microservice. If a transaction fails, the other services can be rolled back, ensuring that the system remains consistent. Let\u0026rsquo;s say you have a system where a user can place an order that involves multiple microservices. The order might involve checking inventory levels, processing payments, and shipping products. You can use the Saga pattern to handle this transaction by breaking it down into smaller transactions, each handled by a separate microservice. If one of the transactions fails, the other transactions can be rolled back, ensuring that the system remains consistent. For example, the payment service fails to process a payment. The shipping service can be notified to cancel the shipment, and the inventory service can be notified to restock the item. This ensures that the system remains consistent even though one of the transactions failed.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eDistributed transaction coordinator\u003c/strong\u003e: A distributed transaction coordinator can help to manage transactions across multiple microservices. The coordinator can ensure that all transactions are either committed or rolled back as a single unit, ensuring consistency across the system.For example, you could use a tool like Apache Kafka to implement a distributed transaction coordinator. When a user places an order, the order microservice can publish a message to a Kafka topic. Each microservice that needs to handle the transaction can subscribe to the topic and perform its own transaction. If one of the microservices fails, the coordinator can ensure that all transactions are either committed or rolled back as a single unit, ensuring consistency across the system.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eCompensating transactions\u003c/strong\u003e: A compensating transaction is a transaction that undoes the effects of a previous transaction. This can be used to handle failures in the system by rolling back the changes made by previous transactions and restoring the system to its previous state.For example, Let\u0026rsquo;s say you have a system where a user can transfer money between accounts. This transaction involves two microservices: one to debit the account and another to credit the account. If the credit service fails, you can use a compensating transaction to handle the failure. The debit service can be notified to reverse the debit transaction, ensuring that the system remains consistent.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eEvent-driven architectures\u003c/strong\u003e: In an event-driven architecture, each microservice publishes events when it completes a transaction. Other microservices can subscribe to these events and use them to trigger their own transactions. This can help to ensure consistency across the system and reduce the risk of failures.For example, Let\u0026rsquo;s say you have a system where a user can place an order that involves multiple microservices. Each microservice can publish an event when it completes a transaction. For example, the inventory service can publish an event when it updates the inventory level, and the shipping service can publish an event when it ships the product. Other microservices can subscribe to these events and use them to trigger their own transactions. This can help to ensure consistency across the system and reduce the risk of failures.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eIdempotency\u003c/strong\u003e: Idempotency is the property of a system where performing the same operation multiple times has the same result as performing it once. By designing microservices to be idempotent, you can reduce the risk of failures and ensure consistency across the system.For example, Let\u0026rsquo;s say you have a system where a user can update their profile information. To ensure idempotency, you can design the microservice to only update the profile if the request includes a unique identifier, such as a UUID. If the same request is made multiple times, the microservice will recognize the duplicate request and return the same result as the original request. This ensures that the system remains consistent even if the same request is made multiple times.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n","url":"https://karthikselvam.com/posts/2023/01/23/transactions/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"23016-23-09T10:2323:00+00:00","date_modified":"23016-23-09T10:2323:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"34048b647a7ed31bc27fb456a1935ccebc4b4340","title":"Mastering Arrays","summary":"2023","content_text":"In this article, we will solve array-related problems that are commonly encountered in interviews.\n1. Contains Duplicate.\nclass Solution { public boolean containsDuplicate(int[] nums) { // Use a hash set to keep track of seen elements HashSet\u0026lt;Integer\u0026gt; seen = new HashSet\u0026lt;\u0026gt;(); for (int num : nums) { // If we've already seen this element, then we have a duplicate if (seen.contains(num)) { return true; } // Otherwise, add it to the set seen.add(num); } // If we make it through the loop without finding a duplicate, then there isn't one return false; } } Time complexity: O(n) We loop through the array of integers once, which takes O(n) time. The hash set\u0026rsquo;s average time complexity for insertion and lookup is O(1), so the total time complexity of the loop is also O(n).\nSpace complexity: O(n) In the worst case, all elements in the input array are distinct and we must store them all in the hash set. The hash set will therefore have a size of n, so the space complexity is O(n).\n2. Valid Anagram.\npublic boolean isAnagram(String s, String t) { // Check if the lengths of the two strings are the same if (s.length() != t.length()) { return false; } // Create an array to count the occurrences of characters int[] count = new int[26]; // Iterate over the two strings and update the count array for (int i = 0; i \u0026lt; s.length(); i++) { // Increment the count of the character in the first string count[s.charAt(i) - 'a']++; // Decrement the count of the character in the second string count[t.charAt(i) - 'a']--; } // Iterate over the count array and check if all the counts are 0 for (int c : count) { if (c != 0) { // If any count is non-zero, the two strings are not anagrams return false; } } // If all counts are 0, the two strings are anagrams return true; } Time complexity: O(n), where n is the length of the strings, since we iterate over the two strings once.\nSpace complexity: O(1), since we use a fixed-size array of size 26 to count the occurrences of characters.\n3. Two Sum.\npublic int[] twoSum(int[] nums, int target) { // Create a hash table to store the indices of each element Map\u0026lt;Integer, Integer\u0026gt; indexMap = new HashMap\u0026lt;\u0026gt;(); // Iterate over the array for (int i = 0; i \u0026lt; nums.length; i++) { // Calculate the complement of the current element int complement = target - nums[i]; // Check if the complement is in the hash table if (indexMap.containsKey(complement)) { // If it is, return the indices of the two numbers return new int[] { indexMap.get(complement), i }; } // If the complement is not in the hash table, add the current element and its index indexMap.put(nums[i], i); } // If no two numbers add up to the target, return null return null; } Time complexity: O(n), where n is the length of the array, since we iterate over the array once.\nSpace complexity: O(n), since we may store all n elements of the array in the hash table.\n4. Group Anagrams.\nclass Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) { // create a map to store the anagram groups Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // iterate through each string in the input array for (String str : strs) { // convert the string to a character array char[] arr = str.toCharArray(); // sort the characters in the array Arrays.sort(arr); // create a new string from the sorted characters String sorted = new String(arr); // check if the sorted string is already a key in the map if (!map.containsKey(sorted)) { // if not, create a new list for this group map.put(sorted, new ArrayList\u0026lt;\u0026gt;()); } // add the current string to the appropriate group map.get(sorted).add(str); } // create a list to hold the anagram groups List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groups = new ArrayList\u0026lt;\u0026gt;(); // add each group to the list for (List\u0026lt;String\u0026gt; group : map.values()) { groups.add(group); } // return the list of anagram groups return groups; } } Time complexity: O(n * k log k), where n is the number of strings in the input array and k is the maximum length of a string in the array. The main loop iterates through each string in the array and sorts its characters, which takes O(k log k) time per string.\nSpace complexity: O(n * k), where n is the number of strings in the input array and k is the maximum length of a string in the array. The map can potentially store all n strings, and each string may have up to k characters. Additionally, the list of anagram groups also takes O(n * k) space.\n5. Product of Array Except Self.\nclass Solution { public int[] productExceptSelf(int[] nums) { int n = nums.length; int[] res = new int[n]; // Initialize the result array with 1 for (int i = 0; i \u0026lt; n; i++) { res[i] = 1; } // Calculate the left products int left = 1; for (int i = 1; i \u0026lt; n; i++) { left *= nums[i - 1]; res[i] *= left; } // Calculate the right products int right = 1; for (int i = n - 2; i \u0026gt;= 0; i--) { right *= nums[i + 1]; res[i] *= right; } return res; } } Suppose we have the input array nums = [1, 2, 3, 4]. The goal is to calculate the product of all elements in the array except the current element. In other words, for each element nums[i], we need to calculate the product of all elements except nums[i].\nTo solve this problem, we can first initialize the result array res with all ones, because the product of any number with one is the number itself. So, res = [1, 1, 1, 1].\nNext, we traverse the array from left to right and calculate the product of all elements to the left of each element. For the first element, there are no elements to the left, so we skip it. For the second element, the product of all elements to the left is simply the first element, so we set res[1] to 1 * 1 = 1. For the third element, the product of all elements to the left is 1 * 2 = 2, so we set res[2] to 1 * 2 = 2. For the fourth element, the product of all elements to the left is 1 * 2 * 3 = 6, so we set res[3] to 1 * 2 * 3 = 6. After this step, res = [1, 1, 2, 6].\nNext, we traverse the array from right to left and calculate the product of all elements to the right of each element. For the last element, there are no elements to the right, so we skip it. For the third element, the product of all elements to the right is simply the fourth element, so we set res[2] to 2 * 4 = 8. For the second element, the product of all elements to the right is 4 * 3 = 12, so we set res[1] to 1 * 12 = 12. For the first element, the product of all elements to the right is 4 * 3 * 2 = 24, so we set res[0] to 1 * 24 = 24. After this step, res = [24, 12, 8, 6].\nThus, the output for the input array nums = [1, 2, 3, 4] is [24, 12, 8, 6], which is the product of all elements in the array except the current element.\nTime Complexity: O(n) - The solution traverses the array three times, each taking O(n) time. Thus, the overall time complexity is O(n).\nSpace Complexity: O(1) - The solution uses only constant space for storing the variables, and the output array is not considered in the space complexity calculation.If we consider the output array in the space complexity calculation, the space complexity would be O(n).\n","content_html":"\u003cp\u003eIn this article, we will solve array-related problems that are commonly encountered in interviews.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. \u003ca href=\"https://leetcode.com/problems/contains-duplicate/\"\u003eContains Duplicate\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        // Use a hash set to keep track of seen elements\n        HashSet\u0026lt;Integer\u0026gt; seen = new HashSet\u0026lt;\u0026gt;();\n        \n        for (int num : nums) {\n            // If we've already seen this element, then we have a duplicate\n            if (seen.contains(num)) {\n                return true;\n            }\n            \n            // Otherwise, add it to the set\n            seen.add(num);\n        }\n        \n        // If we make it through the loop without finding a duplicate, then there isn't one\n        return false;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n) We loop through the array of integers once, which takes O(n) time.\nThe hash set\u0026rsquo;s average time complexity for insertion and lookup is O(1), so the total time complexity of the loop is also O(n).\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(n) In the worst case, all elements in the input array are distinct and we must store them all in the hash set. The hash set will therefore have a size of n, so the space complexity is O(n).\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e2. \u003ca href=\"https://leetcode.com/problems/valid-anagram/\"\u003eValid Anagram\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic boolean isAnagram(String s, String t) {\n    // Check if the lengths of the two strings are the same\n    if (s.length() != t.length()) {\n        return false;\n    }\n    \n    // Create an array to count the occurrences of characters\n    int[] count = new int[26];\n    \n    // Iterate over the two strings and update the count array\n    for (int i = 0; i \u0026lt; s.length(); i++) {\n        // Increment the count of the character in the first string\n        count[s.charAt(i) - 'a']++;\n        // Decrement the count of the character in the second string\n        count[t.charAt(i) - 'a']--;\n    }\n    \n    // Iterate over the count array and check if all the counts are 0\n    for (int c : count) {\n        if (c != 0) {\n            // If any count is non-zero, the two strings are not anagrams\n            return false;\n        }\n    }\n    \n    // If all counts are 0, the two strings are anagrams\n    return true;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n), where n is the length of the strings, since we iterate over the two strings once.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(1), since we use a fixed-size array of size 26 to count the occurrences of characters.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e3. \u003ca href=\"https://leetcode.com/problems/two-sum/\"\u003eTwo Sum\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic int[] twoSum(int[] nums, int target) {\n    // Create a hash table to store the indices of each element\n    Map\u0026lt;Integer, Integer\u0026gt; indexMap = new HashMap\u0026lt;\u0026gt;();\n    \n    // Iterate over the array\n    for (int i = 0; i \u0026lt; nums.length; i++) {\n        // Calculate the complement of the current element\n        int complement = target - nums[i];\n        // Check if the complement is in the hash table\n        if (indexMap.containsKey(complement)) {\n            // If it is, return the indices of the two numbers\n            return new int[] { indexMap.get(complement), i };\n        }\n        // If the complement is not in the hash table, add the current element and its index\n        indexMap.put(nums[i], i);\n    }\n    \n    // If no two numbers add up to the target, return null\n    return null;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n), where n is the length of the array, since we iterate over the array once.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(n), since we may store all n elements of the array in the hash table.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e4. \u003ca href=\"https://leetcode.com/problems/group-anagrams/\"\u003eGroup Anagrams\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) {\n        // create a map to store the anagram groups\n        Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;();\n        \n        // iterate through each string in the input array\n        for (String str : strs) {\n            // convert the string to a character array\n            char[] arr = str.toCharArray();\n            // sort the characters in the array\n            Arrays.sort(arr);\n            // create a new string from the sorted characters\n            String sorted = new String(arr);\n            \n            // check if the sorted string is already a key in the map\n            if (!map.containsKey(sorted)) {\n                // if not, create a new list for this group\n                map.put(sorted, new ArrayList\u0026lt;\u0026gt;());\n            }\n            \n            // add the current string to the appropriate group\n            map.get(sorted).add(str);\n        }\n        \n        // create a list to hold the anagram groups\n        List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groups = new ArrayList\u0026lt;\u0026gt;();\n        \n        // add each group to the list\n        for (List\u0026lt;String\u0026gt; group : map.values()) {\n            groups.add(group);\n        }\n        \n        // return the list of anagram groups\n        return groups;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n * k log k), where n is the number of strings in the input array and k is the maximum length of a string in the array. The main loop iterates through each string in the array and sorts its characters, which takes O(k log k) time per string.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(n * k), where n is the number of strings in the input array and k is the maximum length of a string in the array. The map can potentially store all n strings, and each string may have up to k characters. Additionally, the list of anagram groups also takes O(n * k) space.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e5. \u003ca href=\"https://leetcode.com/problems/product-of-array-except-self/\"\u003eProduct of Array Except Self\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        int[] res = new int[n];\n        \n        // Initialize the result array with 1\n        for (int i = 0; i \u0026lt; n; i++) {\n            res[i] = 1;\n        }\n        \n        // Calculate the left products\n        int left = 1;\n        for (int i = 1; i \u0026lt; n; i++) {\n            left *= nums[i - 1];\n            res[i] *= left;\n        }\n        \n        // Calculate the right products\n        int right = 1;\n        for (int i = n - 2; i \u0026gt;= 0; i--) {\n            right *= nums[i + 1];\n            res[i] *= right;\n        }\n        \n        return res;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSuppose we have the input array nums = [1, 2, 3, 4]. The goal is to calculate the product of all elements in the array except the current element. In other words, for each element nums[i], we need to calculate the product of all elements except nums[i].\u003c/p\u003e\n\u003cp\u003eTo solve this problem, we can first initialize the result array res with all ones, because the product of any number with one is the number itself. So, res = [1, 1, 1, 1].\u003c/p\u003e\n\u003cp\u003eNext, we traverse the array from left to right and calculate the product of all elements to the left of each element. For the first element, there are no elements to the left, so we skip it. For the second element, the product of all elements to the left is simply the first element, so we set res[1] to 1 * 1 = 1. For the third element, the product of all elements to the left is 1 * 2 = 2, so we set res[2] to 1 * 2 = 2. For the fourth element, the product of all elements to the left is 1 * 2 * 3 = 6, so we set res[3] to 1 * 2 * 3 = 6. After this step, res = [1, 1, 2, 6].\u003c/p\u003e\n\u003cp\u003eNext, we traverse the array from right to left and calculate the product of all elements to the right of each element. For the last element, there are no elements to the right, so we skip it. For the third element, the product of all elements to the right is simply the fourth element, so we set res[2] to 2 * 4 = 8. For the second element, the product of all elements to the right is 4 * 3 = 12, so we set res[1] to 1 * 12 = 12. For the first element, the product of all elements to the right is 4 * 3 * 2 = 24, so we set res[0] to 1 * 24 = 24. After this step, res = [24, 12, 8, 6].\u003c/p\u003e\n\u003cp\u003eThus, the output for the input array nums = [1, 2, 3, 4] is [24, 12, 8, 6], which is the product of all elements in the array except the current element.\u003c/p\u003e\n\u003cp\u003eTime Complexity: O(n) - The solution traverses the array three times, each taking O(n) time. Thus, the overall time complexity is O(n).\u003c/p\u003e\n\u003cp\u003eSpace Complexity: O(1) - The solution uses only constant space for storing the variables, and the output array is not considered in the space complexity calculation.If we consider the output array in the space complexity calculation, the space complexity would be O(n).\u003c/p\u003e\n","url":"https://karthikselvam.com/posts/2023/01/22/arrays/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"22016-22-09T10:2222:00+00:00","date_modified":"22016-22-09T10:2222:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}}]}