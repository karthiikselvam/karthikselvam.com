{"version":"https://jsonfeed.org/version/1","title":"Karthik Selvam","home_page_url":"https://karthikselvam.com/","feed_url":"https://ronaldsvilcins.com/feed.json","description":"","icon":"https://ronaldsvilcins.com/assets/apple-touch-icon.png","favicon":"https://ronaldsvilcins.com/assets/favicon.ico","expired":false,"author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"},"items":[{"id":"cd31544a69cbb5c629dff9b7ba853f94a9fcbd76","title":"Capacity Estimation on the fly","summary":"2023","content_text":"Capacity estimation is a crucial component of system design interviews, and it can be quite challenging if one is not adequately prepared. However, with the right approach, it is possible to accurately estimate the storage, bandwidth, and memory/cache requirements needed for a particular system. This article provides a comprehensive framework for capacity estimation, which will enable you to confidently tackle capacity-related questions during system design interviews.\nTypically following estimates are required :\nStorage Bandwidth Memory/Cache Assumptions:\n1. Storage Estimates\nSingle character requires 2 bytes, while long and double require 8 bytes of space. An average photo takes up 200 KB of space, while a high-quality photo takes up 2 MB of space. For videos, we assume 50 MB of space per minute of video. Examples:\nSocial media: tweet can be assumed 140 char then 140*2 bytes = 280 bytes tweet. Tiny URL: Average URL length \u0026lt;100 char. Longer URLs needing tiny URL will generally be more than 150 char, lets say 200 char. then each URL assume as 200*2 = 400 bytes Database id or price etc field can be double or long so 8 bytes per field. 2. Traffic estimates\nFor social media applications like Facebook, Instagram, Twitter we can assume 1 billion total users, with 500 million daily active users. A chat application like WhatsApp, and Facebook Messenger, has 500 million total users, with 100 million daily active users. For video streaming applications like YouTube, Netflix, and Hulu, we can assume 1 billion total users, with 800 million daily active users. For cloud or file storage applications like Google Drive, Dropbox, and Microsoft OneDrive, we can assume 1 billion total users, with 500 million daily active users. 3. Time Assumptions\nA year has 365 days, so 5 years have 1825 days, which we round up to 2000 days. A day has 24 hours, which is 86400 seconds, which we round up to 100,000 seconds. Capacity Estimation for Social Media application\nAssuming each post or tweet has 140 characters, and each character requires 2 bytes, each tweet or post has a size of approximately 300 bytes. Let’s assume 1 billion total users and 500 million daily active users, we can assume that 10 million users post photos daily, with an average size of 200 KB. Using these assumptions, we can calculate the following:\nStorage: Text data storage: 300 bytes x 500,000,000 = 150,000,000,000 = 150 GB of tweet/post data per day Photo storage: 200 KB x 10,000,000 = 2,000 GB = 2 TB per day.\nTotal storage for 5 years: 150 GB x 2000 days = 300,000 GB = 300 TB for tweet/post data, and 2 TB x 2000 days = 4,000 TB for photos.\nBandwidth: Text data bandwidth: 150 GB per day / 100,000 seconds = 1.5 MB per second Photo bandwidth: 2 TB per day / 100,000 seconds = 200 MB per second\nMemory/Cache: Assuming we want to cache 20 posts/tweets per user, 300 bytes * 500,000,000 daily users * 20 = 150 GB * 20 = 3000 GB = 3 TB of cache. If one machine/server can keep 150 GB of cache, we need 20 machines/servers for caching.\nCapacity Estimation for TinyURL\nAssuming the average length of a URL is 100 characters, and each character requires 2 bytes, each URL has a size of approximately 200 bytes. Let’s assume 1 billion total users, 100 million daily active users. So 100 million urls are generated per day. Using these assumptions, we can calculate the following:\nStorage: URL data storage: 200 bytes x 100,000,000 = 20,000,000,000 = 20 GB per day\nTotal storage for 5 years: 20 GB per day x 2000 days = 40,000 GB = 40 TB\nBandwidth: URL bandwidth: 20 GB per day / 100,000 seconds = 0.2 MB per second.\nMemory/Cache: Assuming we want to cache 20 urls per user, 200 bytes * 100,000,000 daily users * 20 = 20 GB * 20 = 400 GB of cache. If one machine/server can keep 150 GB of cache, we need 3 machines/servers for caching.\nThe framework outlined above provides a clear approach to tackle capacity estimation problems during interviews.\n","content_html":"\u003cp\u003eCapacity estimation is a crucial component of system design interviews, and it can be quite challenging if one is not adequately prepared. However, with the right approach, it is possible to accurately estimate the storage, bandwidth, and memory/cache requirements needed for a particular system. This article provides a comprehensive framework for capacity estimation, which will enable you to confidently tackle capacity-related questions during system design interviews.\u003c/p\u003e\n\u003cp\u003eTypically following estimates are required :\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eStorage\u003c/li\u003e\n\u003cli\u003eBandwidth\u003c/li\u003e\n\u003cli\u003eMemory/Cache\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003cp\u003eAssumptions:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. Storage Estimates\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSingle character requires 2 bytes, while long and double require 8 bytes of space.\u003c/li\u003e\n\u003cli\u003eAn average photo takes up 200 KB of space, while a high-quality photo takes up 2 MB of space.\u003c/li\u003e\n\u003cli\u003eFor videos, we assume 50 MB of space per minute of video.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eExamples:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSocial media: tweet can be assumed 140 char then 140*2 bytes = 280 bytes tweet.\u003c/li\u003e\n\u003cli\u003eTiny URL: Average URL length \u0026lt;100 char. Longer URLs needing tiny URL will generally be more than 150 char, lets say 200 char. then each URL assume as 200*2 = 400 bytes\u003c/li\u003e\n\u003cli\u003eDatabase id or price etc field can be double or long so 8 bytes per field.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e2. Traffic estimates\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFor social media applications like Facebook, Instagram, Twitter we can assume 1 billion total users, with 500 million daily active users.\u003c/li\u003e\n\u003cli\u003eA chat application like WhatsApp, and Facebook Messenger, has 500 million total users, with 100 million daily active users.\u003c/li\u003e\n\u003cli\u003eFor video streaming applications like YouTube, Netflix, and Hulu, we can assume 1 billion total users, with 800 million daily active users.\u003c/li\u003e\n\u003cli\u003eFor cloud or file storage applications like Google Drive, Dropbox, and Microsoft OneDrive, we can assume 1 billion total users, with 500 million daily active users.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e3. Time Assumptions\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA year has 365 days, so 5 years have 1825 days, which we round up to 2000 days.\u003c/li\u003e\n\u003cli\u003eA day has 24 hours, which is 86400 seconds, which we round up to 100,000 seconds.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003eCapacity Estimation for Social Media application\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAssuming each post or tweet has 140 characters, and each character requires 2 bytes, each tweet or post has a size of approximately 300 bytes. Let’s assume 1 billion total users and 500 million daily active users, we can assume that 10 million users post photos daily, with an average size of 200 KB. Using these assumptions, we can calculate the following:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eStorage\u003c/strong\u003e:\nText data storage: 300 bytes x 500,000,000 = 150,000,000,000 = 150 GB of tweet/post data per day\nPhoto storage: 200 KB x 10,000,000 = 2,000 GB = 2 TB per day.\u003c/p\u003e\n\u003cp\u003eTotal storage for 5 years: 150 GB x 2000 days = 300,000 GB = 300 TB for tweet/post data, and 2 TB x 2000 days = 4,000 TB for photos.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBandwidth\u003c/strong\u003e:\nText data bandwidth: 150 GB per day / 100,000 seconds = 1.5 MB per second\nPhoto bandwidth: 2 TB per day / 100,000 seconds = 200 MB per second\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eMemory/Cache\u003c/strong\u003e:\nAssuming we want to cache 20 posts/tweets per user, 300 bytes * 500,000,000 daily users * 20 = 150 GB * 20 = 3000 GB = 3 TB of cache. If one machine/server can keep 150 GB of cache, we need 20 machines/servers for caching.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003eCapacity Estimation for TinyURL\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAssuming the average length of a URL is 100 characters, and each character requires 2 bytes, each URL has a size of approximately 200 bytes. Let’s assume 1 billion total users, 100 million daily active users. So 100 million urls are generated per day. Using these assumptions, we can calculate the following:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eStorage\u003c/strong\u003e:\nURL data storage: 200 bytes x 100,000,000 = 20,000,000,000 = 20 GB per day\u003c/p\u003e\n\u003cp\u003eTotal storage for 5 years: 20 GB per day x 2000 days = 40,000 GB = 40 TB\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBandwidth\u003c/strong\u003e:\nURL bandwidth: 20 GB per day / 100,000 seconds = 0.2 MB per second.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eMemory/Cache\u003c/strong\u003e:\nAssuming we want to cache 20 urls per user, 200 bytes * 100,000,000 daily users * 20 = 20 GB * 20 = 400 GB of cache. If one machine/server can keep 150 GB of cache, we need 3 machines/servers for caching.\u003c/p\u003e\n\u003cp\u003eThe framework outlined above provides a clear approach to tackle capacity estimation problems during interviews.\u003c/p\u003e\n","url":"https://karthikselvam.com/posts/2023/03/23/2023-03-23/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"23036-23-09T30:2323:00+00:00","date_modified":"23036-23-09T30:2323:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"e6f6a613933a7c246b5ddb2c8d9fa5b114ca460a","title":"Understanding SOLID Principles","summary":"2023","content_text":"SOLID is an acronym of the following:\nS: Single Responsibility Principle O: Open Closed Principle L: Liskov\u0026rsquo;s Substitution Principle I: Interface Segregation Principle D: Dependency Inversion Principle 1. What is Single Responsibility Principle ?\nS stands for One class should have one, and only one, responsibility. S tells us to write a class for only one goal. As long as we write a class for only one goal, we will sustain high maintainability and visibility control across the application modules. In other words, by sustaining high maintainability, this principle has a significant business impact, and by providing visibility control across the application modules, this principle sustains encapsulation.\nFor example, the following class computes the area and converts it to inches:\npublic class RectangleAreaCalculator { private static final double INCH_TERM = 0.0254d; private final int width; private final int height; public RectangleAreaCalculator(int width, int height) { this.width = width; this.height = height; } public int area() { return width * height; } // this method breaks SRP public double metersToInches(int area) { return area / INCH_TERM; } } The situation can be remedied by removing the metersToInches() method from RectangleAreaCalculator, as follows:\npublic class RectangleAreaCalculator { private final int width; private final int height; public RectangleAreaCalculator(int width, int height) { this.width = width; this.height = height; } public int area() { return width * height; } } Now, RectangleAreaCalculator does only one thing (it computes the rectangle area), thereby observing the SRP.\nNext, metersToInches() can be extracted in a separate class.\npublic class AreaConverter { private static final double INCH_TERM = 0.0254d; private static final double FEET_TERM = 0.3048d; public double metersToInches(int area) { return area / INCH_TERM; } public double metersToFeet(int area) { return area / FEET_TERM; } } 2. What is Open Closed Principle ?\nO stands for Software components should be open for extension, but closed for modification. O sustains the fact that our classes should not contain constraints that will require other developers to modify our classes in order to accomplish their job – other developers should only extend our classes to accomplish their job.\nEach shape will implement the Shape interface. Therefore, the code is pretty straightforward:\npublic interface Shape { } public class Rectangle implements Shape { private final int width; rivate final int height; // constructor and getters omitted for brevity } public class Circle implements Shape { private final int radius; // constructor and getter omitted for brevity } At this point, we can easily use the constructors of these classes to create rectangles and circles of different sizes. Once we have several shapes, we want to sum their areas. For this, we can define an AreaCalculator class as follows:\npublic class AreaCalculator { private final List\u0026lt;Shape\u0026gt; shapes; public AreaCalculator(List\u0026lt;Shape\u0026gt; shapes) { this.shapes = shapes; } // adding more shapes requires us to modify this class // this code is not OCP compliant public double sum() { int sum = 0; for (Shape shape : shapes) { if (shape.getClass().equals(Circle.class)) { sum += Math.PI * Math.pow(((Circle) shape).getRadius(), 2); } else if(shape.getClass().equals(Rectangle.class)) { sum += ((Rectangle) shape).getHeight() * ((Rectangle) shape).getWidth(); } } return sum; } } Since each shape has its own formula for area, we require an if-else (or switch) structure to determine the type of shape. Furthermore, if we want to add a new shape (for example, a triangle), we have to modify the AreaCalculator class to add a new if case. This means that the preceding code breaks the OCP.\nThe main idea is to extract from AreaCalculator the area formula of each shape in the corresponding Shape class. Hence, the rectangle will compute its area, the circle as well, and so on. To enforce the fact that each shape must calculate its area, we add the area() method to the Shape contract:\npublic interface Shape { public double area(); } Next, Rectangle and Circle implements Shape as follows:\npublic class Rectangle implements Shape { private final int width; private final int height; public Rectangle(int width, int height) { this.width = width; this.height = height; } public double area() { return width * height; } } public class Circle implements Shape { private final int radius; public Circle(int radius) { this.radius = radius; } @Override public double area() { return Math.PI * Math.pow(radius, 2); } } Now, the AreaCalculator can loop the list of shapes and sum the areas by calling the proper area() method.\npublic class AreaCalculator { private final List\u0026lt;Shape\u0026gt; shapes; public AreaCalculator(List\u0026lt;Shape\u0026gt; shapes) { this.shapes = shapes; } public double sum() { int sum = 0; for (Shape shape : shapes) { sum += shape.area(); } return sum; } } 3. What is Liskov\u0026rsquo;s Substitution Principle ?\nL stands for Derived types must be completely substitutable for their base types. L sustains the fact that objects of subclasses must behave in the same way as the objects of superclasses, so every subclass (or derived class) should be capable of substituting their superclass without any issues. Most of the time, this is useful for runtime-type identification followed by the cast. For example, consider foo(p), where p is of the type T. Then, foo(q) should work fine if q is of the type S and S is a subtype of T.\nSuppose we have a class hierarchy for different shapes, with a base class Shape and two derived classes Circle and Rectangle. Each class has a method area() to calculate the area of the shape.\npublic abstract class Shape { public abstract double area(); } public class Circle extends Shape { private double radius; public Circle(double radius) { this.radius = radius; } @Override public double area() { return 3.14 * radius * radius; } } public class Rectangle extends Shape { private double length; private double width; public Rectangle(double length, double width) { this.length = length; this.width = width; } @Override public double area() { return length * width; } } Now suppose we have a method calculateTotalArea that takes an array of shapes and returns the total area of all the shapes in the array:\npublic static double calculateTotalArea(Shape[] shapes) { double totalArea = 0.0; for (Shape shape : shapes) { totalArea += shape.area(); } return totalArea; } According to Liskov\u0026rsquo;s Substitution Principle, we should be able to pass an array of Circle or Rectangle objects to this method without any problems, since both classes inherit from the Shape base class and implement the area() method.\nCircle circle = new Circle(5); Rectangle rectangle = new Rectangle(3, 4); Shape[] shapes = {circle, rectangle}; double totalArea = calculateTotalArea(shapes); // returns 83.5 This demonstrates that the Circle and Rectangle classes can be used interchangeably with the Shape class, without causing any errors or unexpected behavior in the program.\n4. What is Interface Segregation Principle ?\nI stands for the Interface Segregation Principle (ISP). I stands for Clients should not be forced to implement unnecessary methods that they will not use.\nThis principle stands for Clients should not be forced to implement unnecessary methods that they will not use. In other words, we should split an interface into two or more interfaces until clients are not forced to implement methods that they will not use. For example, consider the Connection interface, which has three methods: connect(), socket(), and http().\npublic interface Connection { public void socket(); public void http(); public void connect(); } WwwPingConnection is a class that pings different websites via HTTP; hence, it requires the http() method, but doesn\u0026rsquo;t need the socket() method. Notice the dummy socket() implementation – since WwwPingConnection implements Connection, it is forced to provide an implementation to the socket() method as well:\npublic class WwwPingConnection implements Connection { private final String www; public WwwPingConnection(String www) { this.www = www; } @Override public void http() { System.out.println(\u0026quot;Setup an HTTP connection to \u0026quot; + www); } @Override public void connect() { System.out.println(\u0026quot;Connect to \u0026quot; + www); } // this method breaks Interface Segregation Principle @Override public void socket() { } } Having an empty implementation or throwing a meaningful exception from methods that are not needed, such as socket(), is a really ugly solution. Check the following code:\nWwwPingConnection www = new WwwPingConnection 'www.yahoo.com'); www.socket(); // we can call this method! www.connect(); What do we expect to obtain from this code? A working code that does nothing, or an exception caused by the connect() method because there is no HTTP endpoint? Or, we can throw an exception from socket() of the type: Socket is not supported!. Then, why is it here?! Hence, it is now time to refactor the code to follow the ISP. In order to comply with the ISP, we need to segregate the Connection interface. Since the connect() method is required by any client, we leave it in this interface.\npublic interface Connection { public void connect(); } The http() and socket() methods are distributed in to separate interfaces that extend the Connection interface as follows:\npublic interface HttpConnection extends Connection { public void http(); } public interface SocketConnection extends Connection { public void socket(); } This time, the WwwPingConnection class can implement only the HttpConnection interface and use the http() method:\npublic class WwwPingConnection implements HttpConnection { private final String www; public WwwPingConnection(String www) { this.www = www; } @Override public void http() { System.out.println(\u0026quot;Setup an HTTP connection to \u0026quot; + www); } @Override public void connect() { System.out.println(\u0026quot;Connect to \u0026quot; + www); } } 5. What is Dependency Inversion Principle ?\nD stands for the Dependency Inversion Principle. This principle stands for Depend on abstractions, not on concretions. This means that we should rely on abstract layers to bind concrete modules together instead of having concrete modules that depend on other concrete modules. To accomplish this, all concrete modules should expose abstractions only.\nA database JDBC URL, PostgreSQLJdbcUrl, can be a low-level module, while a class that connects to the database may represent a high-level module, such as ConnectToDatabase#connect().\npublic class PostgreSQLJdbcUrl { private final String dbName; public PostgreSQLJdbcUrl(String dbName) { this.dbName = dbName; } public String get() { return \u0026quot;jdbc:// ... \u0026quot; + this.dbName; } } public class ConnectToDatabase { public void connect(PostgreSQLJdbcUrl postgresql) { System.out.println(\u0026quot;Connecting to \u0026quot; + postgresql.get()); } } If we create another type of JDBC URL (for example, MySQLJdbcUrl), then we cannot use the preceding connect(PostgreSQLJdbcUrl postgreSQL) method. So, we have to drop this dependency on concrete and create a dependency on abstraction.\nThe abstraction can be represented by an interface that should be implemented by each type of JDBC URL\npublic interface JdbcUrl { public String get(); } Next, PostgreSQLJdbcUrl implements JdbcUrl to return a JDBC URL specific to PostgreSQL databases:\npublic class PostgreSQLJdbcUrl implements JdbcUrl { private final String dbName; public PostgreSQLJdbcUrl(String dbName) { this.dbName = dbName; } @Override public String get() { return \u0026quot;jdbc:// ... \u0026quot; + this.dbName; } } In precisely the same manner, we can write MySQLJdbcUrl, OracleJdbcUrl, and so on. Finally, the ConnectToDatabase#connect() method is dependent on the JdbcUrl abstraction, so it can connect to any JDBC URL that implements this abstraction.\npublic class ConnectToDatabase { public void connect(JdbcUrl jdbcUrl) { System.out.println(\u0026quot;Connecting to \u0026quot; + jdbcUrl.get()); } } That\u0026rsquo;s it, now you have solid understanding of SOLID principles.\n","content_html":"\u003cp\u003eSOLID is an acronym of the following:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eS: Single Responsibility Principle\u003c/li\u003e\n\u003cli\u003eO: Open Closed Principle\u003c/li\u003e\n\u003cli\u003eL: Liskov\u0026rsquo;s Substitution Principle\u003c/li\u003e\n\u003cli\u003eI: Interface Segregation Principle\u003c/li\u003e\n\u003cli\u003eD: Dependency Inversion Principle\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e1. What is Single Responsibility Principle ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eS stands for One class should have one, and only one, responsibility. S tells us to write a class for only one goal. As long as we write a class for only one goal, we will sustain high maintainability and visibility control across the application modules. In other words, by sustaining high maintainability, this principle has a significant business impact, and by providing visibility control across the application modules, this principle sustains encapsulation.\u003c/p\u003e\n\u003cp\u003eFor example, the following class computes the area and converts it to inches:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class RectangleAreaCalculator {\n    private static final double INCH_TERM = 0.0254d;\n    private final int width;\n    private final int height;\n    \n    public RectangleAreaCalculator(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n    \n    public int area() {\n        return width * height;\n    }\n    \n    // this method breaks SRP\n    public double metersToInches(int area) {\n        return area / INCH_TERM;\n    } \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe situation can be remedied by removing the metersToInches() method from RectangleAreaCalculator, as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class RectangleAreaCalculator {\n    private final int width;\n    private final int height;\n    \n    public RectangleAreaCalculator(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n \n    public int area() {\n        return width * height;\n    } \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, RectangleAreaCalculator does only one thing (it computes the rectangle area), thereby observing the SRP.\u003c/p\u003e\n\u003cp\u003eNext, metersToInches() can be extracted in a separate class.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class AreaConverter {\n    private static final double INCH_TERM = 0.0254d;\n    private static final double FEET_TERM = 0.3048d;\n    \n    public double metersToInches(int area) {\n        return area / INCH_TERM;\n    }\n    \n    public double metersToFeet(int area) {\n        return area / FEET_TERM;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e2. What is Open Closed Principle ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eO stands for Software components should be open for extension, but closed for modification. O sustains the fact that our classes should not contain constraints that will require other developers to modify our classes in order to accomplish their job – other developers should only extend our classes to accomplish their job.\u003c/p\u003e\n\u003cp\u003eEach shape will implement the Shape interface. Therefore, the code is pretty straightforward:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public interface Shape { \n    }\n    \n    public class Rectangle implements Shape {\n        private final int width;\n        rivate final int height;\n        // constructor and getters omitted for brevity\n    }\n    \n    public class Circle implements Shape {\n        private final int radius;\n        // constructor and getter omitted for brevity\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAt this point, we can easily use the constructors of these classes to create rectangles and circles of different sizes. Once we have several shapes, we want to sum their areas. For this, we can define an AreaCalculator class as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public class AreaCalculator {\n        private final List\u0026lt;Shape\u0026gt; shapes;\n        public AreaCalculator(List\u0026lt;Shape\u0026gt; shapes) {\n            this.shapes = shapes;\n    }\n \n    // adding more shapes requires us to modify this class\n    // this code is not OCP compliant\n    public double sum() {\n        int sum = 0;\n        for (Shape shape : shapes) {\n            if (shape.getClass().equals(Circle.class)) {\n                sum += Math.PI * Math.pow(((Circle) shape).getRadius(), 2);\n            } else \n            if(shape.getClass().equals(Rectangle.class)) {\n                sum += ((Rectangle) shape).getHeight() * ((Rectangle) shape).getWidth();\n            }\n        }\n        return sum;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSince each shape has its own formula for area, we require an if-else (or switch) structure to determine the type of shape. Furthermore, if we want to add a new shape (for example, a triangle), we have to modify the AreaCalculator class to add a new if case. This means that the preceding code breaks the OCP.\u003c/p\u003e\n\u003cp\u003eThe main idea is to extract from AreaCalculator the area formula of each shape in the corresponding Shape class. Hence, the rectangle will compute its area, the circle as well, and so on. To enforce the fact that each shape must calculate its area, we add the area() method to the Shape contract:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface Shape { \n    public double area();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, Rectangle and Circle implements Shape as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e public class Rectangle implements Shape {\n    private final int width;\n    private final int height;\n\n public Rectangle(int width, int height) {\n    this.width = width;\n    this.height = height;\n }\n\n  public double area() {\n    return width * height;\n }\n}\n\npublic class Circle implements Shape {\n    private final int radius;\n    public Circle(int radius) {\n        this.radius = radius;\n    }\n \n    @Override\n    public double area() {\n        return Math.PI * Math.pow(radius, 2);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, the AreaCalculator can loop the list of shapes and sum the areas by calling the  proper area() method.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class AreaCalculator {\n    private final List\u0026lt;Shape\u0026gt; shapes;\n    public AreaCalculator(List\u0026lt;Shape\u0026gt; shapes) {\n        this.shapes = shapes;\n    }\n\n     public double sum() {\n        int sum = 0;\n        for (Shape shape : shapes) {\n            sum += shape.area();\n        }\n        return sum;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e3. What is Liskov\u0026rsquo;s Substitution Principle ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eL stands for Derived types must be completely substitutable for their base types. L sustains the fact that objects of subclasses must behave in the same way as the objects of superclasses, so every subclass (or derived class) should be capable of substituting their superclass without any issues. Most of the time, this is useful for runtime-type identification followed by the cast. For example, consider foo(p), where p is of the type T. Then, foo(q) should work fine if q is of the type S and S is a subtype of T.\u003c/p\u003e\n\u003cp\u003eSuppose we have a class hierarchy for different shapes, with a base class Shape and two derived classes Circle and Rectangle. Each class has a method area() to calculate the area of the shape.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic abstract class Shape {\n    public abstract double area();\n}\n\npublic class Circle extends Shape {\n    private double radius;\n\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n\n    @Override\n    public double area() {\n        return 3.14 * radius * radius;\n    }\n}\n\npublic class Rectangle extends Shape {\n    private double length;\n    private double width;\n\n    public Rectangle(double length, double width) {\n        this.length = length;\n        this.width = width;\n    }\n\n    @Override\n    public double area() {\n        return length * width;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow suppose we have a method calculateTotalArea that takes an array of shapes and returns the total area of all the shapes in the array:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epublic static double calculateTotalArea(Shape[] shapes) {\n    double totalArea = 0.0;\n    for (Shape shape : shapes) {\n        totalArea += shape.area();\n    }\n    return totalArea;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAccording to Liskov\u0026rsquo;s Substitution Principle, we should be able to pass an array of Circle or Rectangle objects to this method without any problems, since both classes inherit from the Shape base class and implement the area() method.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCircle circle = new Circle(5);\nRectangle rectangle = new Rectangle(3, 4);\nShape[] shapes = {circle, rectangle};\ndouble totalArea = calculateTotalArea(shapes); // returns 83.5\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis demonstrates that the Circle and Rectangle classes can be used interchangeably with the Shape class, without causing any errors or unexpected behavior in the program.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e4. What is Interface Segregation Principle ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI stands for the Interface Segregation Principle (ISP). I stands for Clients should not be forced to implement unnecessary methods that they will not use.\u003c/p\u003e\n\u003cp\u003eThis principle stands for Clients should not be forced to implement unnecessary methods that they will not use. In other words, we should split an interface into two or more interfaces until clients are not forced to implement methods that they will not use. For example, consider the Connection interface, which has three methods: connect(), socket(), and http().\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface Connection {\n    public void socket();\n    public void http();\n    public void connect();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWwwPingConnection is a class that pings different websites via HTTP; hence, it requires the http() method, but doesn\u0026rsquo;t need the socket() method. Notice the dummy socket() implementation – since WwwPingConnection implements Connection, it is forced to provide an implementation to the socket() method as well:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class WwwPingConnection implements Connection {\n    private final String www;\n\n    public WwwPingConnection(String www) {\n        this.www = www;\n    }\n\n    @Override\n    public void http() {\n        System.out.println(\u0026quot;Setup an HTTP connection to \u0026quot; + www);\n    }\n\n    @Override\n    public void connect() {\n    System.out.println(\u0026quot;Connect to \u0026quot; + www);\n    }\n\n    // this method breaks Interface Segregation Principle\n    @Override\n    public void socket() {\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHaving an empty implementation or throwing a meaningful exception from methods that are not needed, such as socket(), is a really ugly solution. Check the following code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eWwwPingConnection www = new WwwPingConnection 'www.yahoo.com');\nwww.socket(); // we can call this method!\nwww.connect();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhat do we expect to obtain from this code? A working code that does nothing, or an  exception caused by the connect() method because there is no HTTP endpoint? Or, we  can throw an exception from socket() of the type: Socket is not supported!. Then, why is  it here?! Hence, it is now time to refactor the code to follow the ISP. In order to comply with the ISP, we need to segregate the Connection interface. Since the connect() method is required by any client, we leave it in this interface.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface Connection {\n    public void connect();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe http() and socket() methods are distributed in to separate interfaces that extend the Connection interface as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface HttpConnection extends Connection {\n    public void http();\n    }\npublic interface SocketConnection extends Connection {\n    public void socket();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis time, the WwwPingConnection class can implement only the HttpConnection interface and use the http() method:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class WwwPingConnection implements HttpConnection {\n    private final String www;\n    \n    public WwwPingConnection(String www) {\n        this.www = www;\n    }\n\n    @Override\n    public void http() {\n        System.out.println(\u0026quot;Setup an HTTP connection to \u0026quot; + www);\n    }\n \n    @Override\n    public void connect() {\n        System.out.println(\u0026quot;Connect to \u0026quot; + www);\n    } \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e5. What is Dependency Inversion Principle ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eD stands for the Dependency Inversion Principle. This principle stands for Depend on abstractions, not on concretions. This means that we should rely on abstract layers to bind concrete modules together instead of having concrete modules that depend on other concrete modules. To accomplish this, all concrete modules should expose abstractions only.\u003c/p\u003e\n\u003cp\u003eA database JDBC URL, PostgreSQLJdbcUrl, can be a low-level module, while a class that connects to the database may represent a high-level module, such as ConnectToDatabase#connect().\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class PostgreSQLJdbcUrl {\n    private final String dbName;\n    public PostgreSQLJdbcUrl(String dbName) {\n        this.dbName = dbName;\n    }\n    public String get() {\n        return \u0026quot;jdbc:// ... \u0026quot; + this.dbName;\n    }\n}\n\npublic class ConnectToDatabase {\n    public void connect(PostgreSQLJdbcUrl postgresql) {\n        System.out.println(\u0026quot;Connecting to \u0026quot; + postgresql.get());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf we create another type of JDBC URL (for example, MySQLJdbcUrl), then we cannot use the preceding connect(PostgreSQLJdbcUrl postgreSQL) method. So, we have to drop this dependency on concrete and create a dependency on abstraction.\u003c/p\u003e\n\u003cp\u003eThe abstraction can be represented by an interface that should be implemented by each type of JDBC URL\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epublic interface JdbcUrl {\n    public String get();\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, PostgreSQLJdbcUrl implements JdbcUrl to return a JDBC URL specific to PostgreSQL databases:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class PostgreSQLJdbcUrl implements JdbcUrl {\n    private final String dbName;\n\n    public PostgreSQLJdbcUrl(String dbName) {\n        this.dbName = dbName;\n    }\n\n    @Override\n    public String get() {\n        return \u0026quot;jdbc:// ... \u0026quot; + this.dbName;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn precisely the same manner, we can write MySQLJdbcUrl, OracleJdbcUrl, and so on. Finally, the ConnectToDatabase#connect() method is dependent on the JdbcUrl abstraction, so it can connect to any JDBC URL that implements this abstraction.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class ConnectToDatabase {\n    public void connect(JdbcUrl jdbcUrl) {\n        System.out.println(\u0026quot;Connecting to \u0026quot; + jdbcUrl.get());\n }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat\u0026rsquo;s it, now you have solid understanding of SOLID principles.\u003c/p\u003e\n","url":"https://karthikselvam.com/posts/2023/01/24/solid_principles/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"24016-24-09T10:2424:00+00:00","date_modified":"24016-24-09T10:2424:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"f7d5285750b0c221397309ad910af98f154422a2","title":"Handling Transactions in Microservices","summary":"2023","content_text":"Handling transactions involving more than one microservice can be challenging since each microservice typically has its own data store and transaction management. However, there are several best practices that can help to ensure consistency and reliability across microservices:\nThe Saga pattern: This involves breaking the transaction into multiple smaller transactions, each of which is handled by a separate microservice. If a transaction fails, the other services can be rolled back, ensuring that the system remains consistent. Let\u0026rsquo;s say you have a system where a user can place an order that involves multiple microservices. The order might involve checking inventory levels, processing payments, and shipping products. You can use the Saga pattern to handle this transaction by breaking it down into smaller transactions, each handled by a separate microservice. If one of the transactions fails, the other transactions can be rolled back, ensuring that the system remains consistent. For example, the payment service fails to process a payment. The shipping service can be notified to cancel the shipment, and the inventory service can be notified to restock the item. This ensures that the system remains consistent even though one of the transactions failed.\nDistributed transaction coordinator: A distributed transaction coordinator can help to manage transactions across multiple microservices. The coordinator can ensure that all transactions are either committed or rolled back as a single unit, ensuring consistency across the system.For example, you could use a tool like Apache Kafka to implement a distributed transaction coordinator. When a user places an order, the order microservice can publish a message to a Kafka topic. Each microservice that needs to handle the transaction can subscribe to the topic and perform its own transaction. If one of the microservices fails, the coordinator can ensure that all transactions are either committed or rolled back as a single unit, ensuring consistency across the system.\nCompensating transactions: A compensating transaction is a transaction that undoes the effects of a previous transaction. This can be used to handle failures in the system by rolling back the changes made by previous transactions and restoring the system to its previous state.For example, Let\u0026rsquo;s say you have a system where a user can transfer money between accounts. This transaction involves two microservices: one to debit the account and another to credit the account. If the credit service fails, you can use a compensating transaction to handle the failure. The debit service can be notified to reverse the debit transaction, ensuring that the system remains consistent.\nEvent-driven architectures: In an event-driven architecture, each microservice publishes events when it completes a transaction. Other microservices can subscribe to these events and use them to trigger their own transactions. This can help to ensure consistency across the system and reduce the risk of failures.For example, Let\u0026rsquo;s say you have a system where a user can place an order that involves multiple microservices. Each microservice can publish an event when it completes a transaction. For example, the inventory service can publish an event when it updates the inventory level, and the shipping service can publish an event when it ships the product. Other microservices can subscribe to these events and use them to trigger their own transactions. This can help to ensure consistency across the system and reduce the risk of failures.\nIdempotency: Idempotency is the property of a system where performing the same operation multiple times has the same result as performing it once. By designing microservices to be idempotent, you can reduce the risk of failures and ensure consistency across the system.For example, Let\u0026rsquo;s say you have a system where a user can update their profile information. To ensure idempotency, you can design the microservice to only update the profile if the request includes a unique identifier, such as a UUID. If the same request is made multiple times, the microservice will recognize the duplicate request and return the same result as the original request. This ensures that the system remains consistent even if the same request is made multiple times.\n","content_html":"\u003cp\u003eHandling transactions involving more than one microservice can be challenging since each microservice typically has its own data store and transaction management. However, there are several best practices that can help to ensure consistency and reliability across microservices:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eThe Saga pattern\u003c/strong\u003e: This involves breaking the transaction into multiple smaller transactions, each of which is handled by a separate microservice. If a transaction fails, the other services can be rolled back, ensuring that the system remains consistent. Let\u0026rsquo;s say you have a system where a user can place an order that involves multiple microservices. The order might involve checking inventory levels, processing payments, and shipping products. You can use the Saga pattern to handle this transaction by breaking it down into smaller transactions, each handled by a separate microservice. If one of the transactions fails, the other transactions can be rolled back, ensuring that the system remains consistent. For example, the payment service fails to process a payment. The shipping service can be notified to cancel the shipment, and the inventory service can be notified to restock the item. This ensures that the system remains consistent even though one of the transactions failed.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eDistributed transaction coordinator\u003c/strong\u003e: A distributed transaction coordinator can help to manage transactions across multiple microservices. The coordinator can ensure that all transactions are either committed or rolled back as a single unit, ensuring consistency across the system.For example, you could use a tool like Apache Kafka to implement a distributed transaction coordinator. When a user places an order, the order microservice can publish a message to a Kafka topic. Each microservice that needs to handle the transaction can subscribe to the topic and perform its own transaction. If one of the microservices fails, the coordinator can ensure that all transactions are either committed or rolled back as a single unit, ensuring consistency across the system.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eCompensating transactions\u003c/strong\u003e: A compensating transaction is a transaction that undoes the effects of a previous transaction. This can be used to handle failures in the system by rolling back the changes made by previous transactions and restoring the system to its previous state.For example, Let\u0026rsquo;s say you have a system where a user can transfer money between accounts. This transaction involves two microservices: one to debit the account and another to credit the account. If the credit service fails, you can use a compensating transaction to handle the failure. The debit service can be notified to reverse the debit transaction, ensuring that the system remains consistent.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eEvent-driven architectures\u003c/strong\u003e: In an event-driven architecture, each microservice publishes events when it completes a transaction. Other microservices can subscribe to these events and use them to trigger their own transactions. This can help to ensure consistency across the system and reduce the risk of failures.For example, Let\u0026rsquo;s say you have a system where a user can place an order that involves multiple microservices. Each microservice can publish an event when it completes a transaction. For example, the inventory service can publish an event when it updates the inventory level, and the shipping service can publish an event when it ships the product. Other microservices can subscribe to these events and use them to trigger their own transactions. This can help to ensure consistency across the system and reduce the risk of failures.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eIdempotency\u003c/strong\u003e: Idempotency is the property of a system where performing the same operation multiple times has the same result as performing it once. By designing microservices to be idempotent, you can reduce the risk of failures and ensure consistency across the system.For example, Let\u0026rsquo;s say you have a system where a user can update their profile information. To ensure idempotency, you can design the microservice to only update the profile if the request includes a unique identifier, such as a UUID. If the same request is made multiple times, the microservice will recognize the duplicate request and return the same result as the original request. This ensures that the system remains consistent even if the same request is made multiple times.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n","url":"https://karthikselvam.com/posts/2023/01/23/2023-01-23/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"23016-23-09T10:2323:00+00:00","date_modified":"23016-23-09T10:2323:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}}]}