{"version":"https://jsonfeed.org/version/1","title":"Karthik Selvam","home_page_url":"https://karthikselvam.com/","feed_url":"https://ronaldsvilcins.com/feed.json","description":"","icon":"https://ronaldsvilcins.com/assets/apple-touch-icon.png","favicon":"https://ronaldsvilcins.com/assets/favicon.ico","expired":false,"author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"},"items":[{"id":"942dd25f11aa40ca8143cf297dc0a9c9125b5279","title":"Understanding PostgreSQL’s Write-Ahead Logging (WAL)","summary":"2023","content_text":"PostgreSQL’s Write-Ahead Logging (WAL) is at the heart of its durability and crash recovery. If you’ve ever wondered how PostgreSQL ensures your data is safe—even in the event of a crash—this post will walk you through the architecture, flow, and the actual source code that makes it all work.\nHigh-Level Architecture \u0026amp; Flow of WAL # What is WAL? # WAL is a mechanism that ensures all changes to the database are first recorded in a log before being applied to the data files. This guarantees that, even if the system crashes, PostgreSQL can recover to a consistent state.\nKey Components # WAL Buffers:\nIn-memory buffers that temporarily hold WAL records before they’re written to disk. WAL Files:\nOn-disk files (in pg_wal/), typically 16MB each, storing the WAL records. WAL Writer Process:\nA background process that flushes WAL buffers to disk. Checkpointer:\nEnsures data files are consistent with WAL. Archiver:\nOptionally archives completed WAL segments for point-in-time recovery (PITR). Sequence of Events # Change Initiation:\nA transaction modifies data (e.g., an INSERT). WAL Record Creation:\nThe change is encoded as a WAL record in memory. WAL Buffering:\nThe WAL record is placed in the WAL buffers. WAL Flush:\nBefore a transaction commits, its WAL records are flushed to disk. WAL File Management:\nWAL files are rotated, archived, and recycled as needed. Crash Recovery:\nOn restart after a crash, WAL is replayed to bring the database to a consistent state. Mapping WAL to the PostgreSQL Source Code # Let’s walk through the main code files and functions for each component.\n1. WAL Record Creation # File: xlog.c Key Struct: XLogRecord Key Functions: XLogInsert(): Called whenever a change is made (e.g., tuple insert/update/delete). Constructs a WAL record and appends it to the WAL buffers. XLogRegisterData(), XLogRegisterBuffer(): Used by lower-level code to register data and buffers that should be included in the WAL record. 2. WAL Buffering and Flushing # File: xlog.c Key Struct: XLogCtlData (shared memory control structure for WAL) Key Functions: XLogWrite(): Flushes WAL buffers to disk. XLogFlush(): Ensures that WAL up to a certain point is safely on disk (called before commit). XLogBackgroundFlush(): Used by the WAL writer background process. 3. WAL Writer Process # File: walwriter.c Key Function: WalWriterMain(): Main loop for the WAL writer background process, periodically flushing WAL buffers. 4. WAL File Management # File: xlog.c Key Functions: XLogFileInit(), XLogFileOpen(), XLogFileClose(): Manage creation, opening, and closing of WAL segment files. XLogFileName(): Generates the filename for a given WAL segment. 5. Crash Recovery # File: xlog.c Key Function: StartupXLOG(): Main function for crash recovery; reads and replays WAL records. 6. Archiving # File: xlogarchive.c Key Functions: XLogArchiveNotify(), XLogArchiveCheckDone() Important Structs, Macros, and Configurations # XLogRecPtr: 64-bit pointer to a WAL location. XLogRecord: Struct representing a single WAL record. XLogCtlData: Shared memory structure for WAL state. Configuration Parameters (in postgresql.conf):\nwal_level wal_buffers wal_writer_delay archive_mode, archive_command max_wal_size, min_wal_size Step-by-Step Exploration # WAL Record Creation:\nStart in xlog.c with XLogInsert(). See how a WAL record is constructed and added to the buffer. Explore how XLogRegisterData() and XLogRegisterBuffer() are used to build the record.\nWAL Buffering and Flushing:\nFollow XLogWrite() and XLogFlush(). See how WAL buffers are managed and flushed to disk. Understand the role of XLogCtlData.\nWAL Writer Process:\nLook at WalWriterMain() in walwriter.c. See how the background process periodically flushes WAL.\nWAL File Management:\nExplore XLogFileInit(), XLogFileOpen(), etc. See how WAL files are created, opened, and rotated.\nCrash Recovery:\nStudy StartupXLOG(). See how WAL is replayed after a crash.\nConclusion # PostgreSQL’s WAL system is a robust, well-architected mechanism that ensures your data is safe and recoverable. By understanding both the high-level flow and the underlying source code, you gain insight into one of the most critical parts of PostgreSQL’s architecture.\n","content_html":"\u003cp\u003ePostgreSQL’s Write-Ahead Logging (WAL) is at the heart of its durability and crash recovery. If you’ve ever wondered how PostgreSQL ensures your data is safe—even in the event of a crash—this post will walk you through the architecture, flow, and the actual source code that makes it all work.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"high-level-architecture--flow-of-wal\"\u003eHigh-Level Architecture \u0026amp; Flow of WAL \u003ca href=\"#high-level-architecture--flow-of-wal\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"what-is-wal\"\u003eWhat is WAL? \u003ca href=\"#what-is-wal\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eWAL is a mechanism that ensures all changes to the database are first recorded in a log before being applied to the data files. This guarantees that, even if the system crashes, PostgreSQL can recover to a consistent state.\u003c/p\u003e\n\u003ch3 id=\"key-components\"\u003eKey Components \u003ca href=\"#key-components\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eWAL Buffers:\u003c/strong\u003e\u003cbr\u003e\nIn-memory buffers that temporarily hold WAL records before they’re written to disk.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWAL Files:\u003c/strong\u003e\u003cbr\u003e\nOn-disk files (in \u003ccode\u003epg_wal/\u003c/code\u003e), typically 16MB each, storing the WAL records.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWAL Writer Process:\u003c/strong\u003e\u003cbr\u003e\nA background process that flushes WAL buffers to disk.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCheckpointer:\u003c/strong\u003e\u003cbr\u003e\nEnsures data files are consistent with WAL.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eArchiver:\u003c/strong\u003e\u003cbr\u003e\nOptionally archives completed WAL segments for point-in-time recovery (PITR).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"sequence-of-events\"\u003eSequence of Events \u003ca href=\"#sequence-of-events\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eChange Initiation:\u003c/strong\u003e\u003cbr\u003e\nA transaction modifies data (e.g., an \u003ccode\u003eINSERT\u003c/code\u003e).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWAL Record Creation:\u003c/strong\u003e\u003cbr\u003e\nThe change is encoded as a WAL record in memory.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWAL Buffering:\u003c/strong\u003e\u003cbr\u003e\nThe WAL record is placed in the WAL buffers.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWAL Flush:\u003c/strong\u003e\u003cbr\u003e\nBefore a transaction commits, its WAL records are flushed to disk.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWAL File Management:\u003c/strong\u003e\u003cbr\u003e\nWAL files are rotated, archived, and recycled as needed.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCrash Recovery:\u003c/strong\u003e\u003cbr\u003e\nOn restart after a crash, WAL is replayed to bring the database to a consistent state.\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"mapping-wal-to-the-postgresql-source-code\"\u003eMapping WAL to the PostgreSQL Source Code \u003ca href=\"#mapping-wal-to-the-postgresql-source-code\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eLet’s walk through the main code files and functions for each component.\u003c/p\u003e\n\u003ch3 id=\"1-wal-record-creation\"\u003e1. WAL Record Creation \u003ca href=\"#1-wal-record-creation\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eFile:\u003c/strong\u003e xlog.c\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKey Struct:\u003c/strong\u003e \u003ccode\u003eXLogRecord\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKey Functions:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eXLogInsert()\u003c/code\u003e: Called whenever a change is made (e.g., tuple insert/update/delete). Constructs a WAL record and appends it to the WAL buffers.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eXLogRegisterData()\u003c/code\u003e, \u003ccode\u003eXLogRegisterBuffer()\u003c/code\u003e: Used by lower-level code to register data and buffers that should be included in the WAL record.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"2-wal-buffering-and-flushing\"\u003e2. WAL Buffering and Flushing \u003ca href=\"#2-wal-buffering-and-flushing\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eFile:\u003c/strong\u003e xlog.c\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKey Struct:\u003c/strong\u003e \u003ccode\u003eXLogCtlData\u003c/code\u003e (shared memory control structure for WAL)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKey Functions:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eXLogWrite()\u003c/code\u003e: Flushes WAL buffers to disk.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eXLogFlush()\u003c/code\u003e: Ensures that WAL up to a certain point is safely on disk (called before commit).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eXLogBackgroundFlush()\u003c/code\u003e: Used by the WAL writer background process.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"3-wal-writer-process\"\u003e3. WAL Writer Process \u003ca href=\"#3-wal-writer-process\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eFile:\u003c/strong\u003e walwriter.c\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKey Function:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eWalWriterMain()\u003c/code\u003e: Main loop for the WAL writer background process, periodically flushing WAL buffers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"4-wal-file-management\"\u003e4. WAL File Management \u003ca href=\"#4-wal-file-management\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eFile:\u003c/strong\u003e xlog.c\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKey Functions:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eXLogFileInit()\u003c/code\u003e, \u003ccode\u003eXLogFileOpen()\u003c/code\u003e, \u003ccode\u003eXLogFileClose()\u003c/code\u003e: Manage creation, opening, and closing of WAL segment files.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eXLogFileName()\u003c/code\u003e: Generates the filename for a given WAL segment.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"5-crash-recovery\"\u003e5. Crash Recovery \u003ca href=\"#5-crash-recovery\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eFile:\u003c/strong\u003e xlog.c\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKey Function:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eStartupXLOG()\u003c/code\u003e: Main function for crash recovery; reads and replays WAL records.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"6-archiving\"\u003e6. Archiving \u003ca href=\"#6-archiving\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eFile:\u003c/strong\u003e xlogarchive.c\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKey Functions:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eXLogArchiveNotify()\u003c/code\u003e, \u003ccode\u003eXLogArchiveCheckDone()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"important-structs-macros-and-configurations\"\u003eImportant Structs, Macros, and Configurations \u003ca href=\"#important-structs-macros-and-configurations\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eXLogRecPtr\u003c/code\u003e\u003c/strong\u003e: 64-bit pointer to a WAL location.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eXLogRecord\u003c/code\u003e\u003c/strong\u003e: Struct representing a single WAL record.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eXLogCtlData\u003c/code\u003e\u003c/strong\u003e: Shared memory structure for WAL state.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eConfiguration Parameters (in \u003ccode\u003epostgresql.conf\u003c/code\u003e):\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ewal_level\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ewal_buffers\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ewal_writer_delay\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003earchive_mode\u003c/code\u003e, \u003ccode\u003earchive_command\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emax_wal_size\u003c/code\u003e, \u003ccode\u003emin_wal_size\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"step-by-step-exploration\"\u003eStep-by-Step Exploration \u003ca href=\"#step-by-step-exploration\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eWAL Record Creation:\u003c/strong\u003e\u003cbr\u003e\nStart in \u003ccode\u003exlog.c\u003c/code\u003e with \u003ccode\u003eXLogInsert()\u003c/code\u003e. See how a WAL record is constructed and added to the buffer. Explore how \u003ccode\u003eXLogRegisterData()\u003c/code\u003e and \u003ccode\u003eXLogRegisterBuffer()\u003c/code\u003e are used to build the record.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eWAL Buffering and Flushing:\u003c/strong\u003e\u003cbr\u003e\nFollow \u003ccode\u003eXLogWrite()\u003c/code\u003e and \u003ccode\u003eXLogFlush()\u003c/code\u003e. See how WAL buffers are managed and flushed to disk. Understand the role of \u003ccode\u003eXLogCtlData\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eWAL Writer Process:\u003c/strong\u003e\u003cbr\u003e\nLook at \u003ccode\u003eWalWriterMain()\u003c/code\u003e in \u003ccode\u003ewalwriter.c\u003c/code\u003e. See how the background process periodically flushes WAL.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eWAL File Management:\u003c/strong\u003e\u003cbr\u003e\nExplore \u003ccode\u003eXLogFileInit()\u003c/code\u003e, \u003ccode\u003eXLogFileOpen()\u003c/code\u003e, etc. See how WAL files are created, opened, and rotated.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eCrash Recovery:\u003c/strong\u003e\u003cbr\u003e\nStudy \u003ccode\u003eStartupXLOG()\u003c/code\u003e. See how WAL is replayed after a crash.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion \u003ca href=\"#conclusion\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003ePostgreSQL’s WAL system is a robust, well-architected mechanism that ensures your data is safe and recoverable. By understanding both the high-level flow and the underlying source code, you gain insight into one of the most critical parts of PostgreSQL’s architecture.\u003c/p\u003e\n\u003chr\u003e\n","url":"https://karthikselvam.com/posts/2025/05/22/interview_preparation/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"22056-22-09T50:2222:00+00:00","date_modified":"22056-22-09T50:2222:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"1e7081d736f43ad30574ac906d26acdd03c38ed9","title":"Trees","summary":"2024","content_text":"1. Binary Tree Inorder Traversal.\npublic class BinaryTreeInorderTraversal { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); inorderHelper(root, result); return result; } private void inorderHelper(TreeNode node, List\u0026lt;Integer\u0026gt; result) { if (node == null) { return; } // Traverse the left subtree inorderHelper(node.left, result); // Visit the root node result.add(node.val); // Traverse the right subtree inorderHelper(node.right, result); } } /*Iterative Approach using Stack */ public class BinaryTreeInorderTraversalIterative { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode current = root; while (current != null || !stack.isEmpty()) { // Reach the leftmost node of the current node while (current != null) { stack.push(current); current = current.left; } // Current must be null at this point current = stack.pop(); result.add(current.val); // Add the node to the result // Visit the right subtree current = current.right; } return result; } } 2. Preorder Traversal.\npublic class BinaryTreePreorderTraversal { public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); preorderHelper(root, result); return result; } private void preorderHelper(TreeNode node, List\u0026lt;Integer\u0026gt; result) { if (node == null) { return; } // Visit the root node result.add(node.val); // Traverse the left subtree preorderHelper(node.left, result); // Traverse the right subtree preorderHelper(node.right, result); } } /*Iterative Approach using Stack */ public class BinaryTreePreorderTraversalIterative { public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return result; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); result.add(node.val); // Push right child first so that left child is processed first if (node.right != null) { stack.push(node.right); } if (node.left != null) { stack.push(node.left); } } return result; } } 3. Postorder Traversal.\npublic class BinaryTreePostorderTraversal { public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); postorderHelper(root, result); return result; } private void postorderHelper(TreeNode node, List\u0026lt;Integer\u0026gt; result) { if (node == null) { return; } // Traverse the left subtree postorderHelper(node.left, result); // Traverse the right subtree postorderHelper(node.right, result); // Visit the root node result.add(node.val); } } /*Iterative Approach using Stack */ public class BinaryTreePostorderTraversalIterative { public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return result; Stack\u0026lt;TreeNode\u0026gt; stack1 = new Stack\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack2 = new Stack\u0026lt;\u0026gt;(); stack1.push(root); while (!stack1.isEmpty()) { TreeNode node = stack1.pop(); stack2.push(node); if (node.left != null) { stack1.push(node.left); } if (node.right != null) { stack1.push(node.right); } } while (!stack2.isEmpty()) { result.add(stack2.pop().val); } return result; } } 3. Level Order Traversal.\npublic class BinaryTreeLevelOrderTraversal { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return result; Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(root); while (!queue.isEmpty()) { int levelSize = queue.size(); List\u0026lt;Integer\u0026gt; currentLevel = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; levelSize; i++) { TreeNode currentNode = queue.poll(); currentLevel.add(currentNode.val); if (currentNode.left != null) { queue.add(currentNode.left); } if (currentNode.right != null) { queue.add(currentNode.right); } } result.add(currentLevel); } return result; } } 4. Find the maximum depth of a binary tree.\npublic int maxDepth(TreeNode root) { if (root == null) { return 0; } int leftDepth = maxDepth(root.left); int rightDepth = maxDepth(root.right); return Math.max(leftDepth, rightDepth) + 1; } 5. Check if a binary tree is height-balanced.\npublic boolean isBalanced(TreeNode root) { return checkHeight(root) != -1; } private int checkHeight(TreeNode node) { if (node == null) { return 0; // Base case: the height of an empty tree is 0 } int leftHeight = checkHeight(node.left); int rightHeight = checkHeight(node.right); if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) \u0026gt; 1) { return -1; // Not balanced } return Math.max(leftHeight, rightHeight) + 1; // Height of the current node } 6. Validate Binary Search Tree.\npublic boolean isValidBST(TreeNode root) { return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE); } private boolean isValidBST(TreeNode node, long min, long max) { if (node == null) { return true; // An empty node is always a valid BST } if (node.val \u0026lt;= min || node.val \u0026gt;= max) { return false; // Node's value is out of the allowed range } // Recursively validate the left subtree and right subtree return isValidBST(node.left, min, node.val) \u0026amp;\u0026amp; isValidBST(node.right, node.val, max); } 7. Find the lowest common ancestor of two nodes in a BST.\nIn a BST: If both nodes (p and q) are less than the root node, then the LCA must be in the left subtree. If both nodes (p and q) are greater than the root node, then the LCA must be in the right subtree. If one node is on the left and the other node is on the right of the root, then the root is the LCA.\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null) { return null; } // If both p and q are less than root, LCA is in the left subtree if (p.val \u0026lt; root.val \u0026amp;\u0026amp; q.val \u0026lt; root.val) { return lowestCommonAncestor(root.left, p, q); } // If both p and q are greater than root, LCA is in the right subtree if (p.val \u0026gt; root.val \u0026amp;\u0026amp; q.val \u0026gt; root.val) { return lowestCommonAncestor(root.right, p, q); } // If one node is on the left and the other is on the right, root is the LCA return root; } 8. Insert a node into a BST.\nStart at the Root: Begin at the root node. Traverse the Tree: Depending on the value of the node to be inserted: If the value is less than the current node\u0026rsquo;s value, move to the left child. If the value is greater than or equal to the current node\u0026rsquo;s value, move to the right child. Insert the Node: When you find an appropriate null position (left or right child), insert the new node there.\npublic TreeNode insertIntoBST(TreeNode root, int val) { if (root == null) { return new TreeNode(val); // Create a new node if the tree is empty } if (val \u0026lt; root.val) { root.left = insertIntoBST(root.left, val); // Insert in the left subtree } else { root.right = insertIntoBST(root.right, val); // Insert in the right subtree } return root; // Return the unchanged root } 9. Delete Node in a BST. To delete a node in a Binary Search Tree (BST), you need to consider three main cases based on the number of children the node to be deleted has: Node with No Children (Leaf Node): Simply remove the node. Node with One Child: Remove the node and replace it with its single child. Node with Two Children: Find the node\u0026rsquo;s in-order predecessor (maximum value in the left subtree) or in-order successor (minimum value in the right subtree), swap values with the node to be deleted, and then delete the predecessor or successor.\npublic TreeNode deleteNode(TreeNode root, int key) { if (root == null) { return null; } if (key \u0026lt; root.val) { root.left = deleteNode(root.left, key); } else if (key \u0026gt; root.val) { root.right = deleteNode(root.right, key); } else { // Node to be deleted found if (root.left == null) { return root.right; // Node with only right child or no child } if (root.right == null) { return root.left; // Node with only left child } // Node with two children: Get the inorder predecessor (largest in the left subtree) TreeNode minNode = getMin(root.right); root.val = minNode.val; // Replace value with inorder successor's value root.right = deleteNode(root.right, minNode.val); // Delete the inorder successor } return root; } private TreeNode getMin(TreeNode node) { while (node.left != null) { node = node.left; } return node; } 9. Convert Sorted Array to Binary Search Tree. Find the Middle Element: Choose the middle element of the array to be the root. This ensures that the tree will be balanced. Recursively Build Left and Right Subtrees: Apply the same process to the left and right subarrays to build the left and right subtrees.\npublic TreeNode sortedArrayToBST(int[] nums) { return sortedArrayToBSTHelper(nums, 0, nums.length - 1); } private TreeNode sortedArrayToBSTHelper(int[] nums, int left, int right) { if (left \u0026gt; right) { return null; // Base case: No elements to form a subtree } int mid = left + (right - left) / 2; // Find the middle index TreeNode root = new TreeNode(nums[mid]); // Create the root node root.left = sortedArrayToBSTHelper(nums, left, mid - 1); // Recursively build the left subtree root.right = sortedArrayToBSTHelper(nums, mid + 1, right); // Recursively build the right subtree return root; } 9. Serialize and Deserialize Binary Tree.\nSerialization: Traverse the tree and record the value of each node. Use a delimiter to mark the end of children or the absence of children (e.g., null). Deserialization: Reconstruct the tree using the serialized data. Use the recorded values to build the tree structure, handling null values to manage missing nodes.\npublic String serialize(TreeNode root) { if (root == null) { return \u0026quot;null,\u0026quot;; } StringBuilder sb = new StringBuilder(); serializeHelper(root, sb); return sb.toString(); } private void serializeHelper(TreeNode root, StringBuilder sb) { if (root == null) { sb.append(\u0026quot;null,\u0026quot;); return; } sb.append(root.val).append(\u0026quot;,\u0026quot;); serializeHelper(root.left, sb); serializeHelper(root.right, sb); } // Deserialization public TreeNode deserialize(String data) { String[] values = data.split(\u0026quot;,\u0026quot;); Queue\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (String value : values) { queue.add(value); } return deserializeHelper(queue); } private TreeNode deserializeHelper(Queue\u0026lt;String\u0026gt; queue) { String value = queue.poll(); if (value.equals(\u0026quot;null\u0026quot;)) { return null; } TreeNode node = new TreeNode(Integer.parseInt(value)); node.left = deserializeHelper(queue); node.right = deserializeHelper(queue); return node; } 10. Binary Tree Zigzag Level Order Traversal.\nUse a Queue: Use a queue to perform a level order traversal (BFS). Alternate Directions: Keep track of the current level\u0026rsquo;s direction. Use a flag to alternate between appending nodes from left to right and from right to left. Add Nodes to the Current Level: Depending on the direction, either add the nodes at the current level to the end of the current level\u0026rsquo;s list or to the front.\npublic List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; zigzagLevelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) { return result; } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); boolean leftToRight = true; while (!queue.isEmpty()) { int levelSize = queue.size(); LinkedList\u0026lt;Integer\u0026gt; currentLevel = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; levelSize; i++) { TreeNode currentNode = queue.poll(); if (leftToRight) { currentLevel.add(currentNode.val); } else { currentLevel.addFirst(currentNode.val); } if (currentNode.left != null) { queue.offer(currentNode.left); } if (currentNode.right != null) { queue.offer(currentNode.right); } } result.add(currentLevel); leftToRight = !leftToRight; // Toggle the direction } return result; } 11. Diameter of Binary Tree.\nHeight of Subtrees: The diameter can be computed by using the height of the left and right subtrees for each node. Recursive Depth-First Search (DFS): Traverse the tree using DFS and calculate the height of each subtree. During this traversal, compute the diameter as the sum of the heights of the left and right subtrees. Update Maximum Diameter: Keep track of the maximum diameter encountered during the DFS traversal.\npublic class DiameterOfBinaryTree { private int diameter = 0; public int diameterOfBinaryTree(TreeNode root) { if (root == null) { return 0; } calculateHeight(root); return diameter; } private int calculateHeight(TreeNode node) { if (node == null) { return 0; } int leftHeight = calculateHeight(node.left); int rightHeight = calculateHeight(node.right); // Update the diameter if the path through this node is longer diameter = Math.max(diameter, leftHeight + rightHeight); // Return the height of the subtree rooted at this node return 1 + Math.max(leftHeight, rightHeight); } } 12. Find the kth smallest element in a BST..\nIn-Order Traversal: Perform an in-order traversal of the BST. This traversal visits nodes in ascending order because, in a BST, the left subtree contains smaller elements, the root is the next smallest, and the right subtree contains larger elements. Tracking the k-th Element: During the in-order traversal, keep a count of the nodes visited. When the count equals k, the current node is the k-th smallest element.\npublic class KthSmallestElementInBST { private int count = 0; private int result = Integer.MIN_VALUE; public int kthSmallest(TreeNode root, int k) { inOrderTraversal(root, k); return result; } private void inOrderTraversal(TreeNode node, int k) { if (node == null) { return; } // Traverse the left subtree inOrderTraversal(node.left, k); // Process the current node count++; if (count == k) { result = node.val; return; } // Traverse the right subtree inOrderTraversal(node.right, k); } } 13. Find the maximum path sum in a binary tree (path can start and end at any node).\nFor each node, calculate the maximum sum of the path that passes through the node and update the global maximum if this value is higher.\npublic class MaxPathSum { private int maxSum = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) { calculateMaxSum(root); return maxSum; } private int calculateMaxSum(TreeNode node) { if (node == null) { return 0; } // Calculate the max path sum from the left and right subtrees int leftMax = Math.max(0, calculateMaxSum(node.left)); // if the value is negative, ignore it int rightMax = Math.max(0, calculateMaxSum(node.right)); // Calculate the path sum that passes through the current node int currentPathSum = node.val + leftMax + rightMax; // Update the global max sum if the current path sum is greater maxSum = Math.max(maxSum, currentPathSum); // Return the maximum path sum including the current node and one of its subtrees return node.val + Math.max(leftMax, rightMax); } } 14. Construct Binary Tree from Preorder and Inorder Traversal.\nStart with the first element in the preorder array as the root. Find the index of this root element in the inorder array. Elements to the left of this index in the inorder array form the left subtree, and elements to the right form the right subtree. Recursively construct the left and right subtrees using the corresponding segments of the preorder and inorder arrays.\npublic class ConstructBinaryTree { private int preorderIndex = 0; private Map\u0026lt;Integer, Integer\u0026gt; inorderIndexMap = new HashMap\u0026lt;\u0026gt;(); public TreeNode buildTree(int[] preorder, int[] inorder) { // Build a map to store value -\u0026gt; index relations from inorder traversal for (int i = 0; i \u0026lt; inorder.length; i++) { inorderIndexMap.put(inorder[i], i); } return constructTree(preorder, 0, inorder.length - 1); } private TreeNode constructTree(int[] preorder, int inorderStart, int inorderEnd) { if (inorderStart \u0026gt; inorderEnd) { return null; } // Get the current root from preorder traversal int rootVal = preorder[preorderIndex++]; TreeNode root = new TreeNode(rootVal); // Find the index of the root in inorder traversal int inorderIndex = inorderIndexMap.get(rootVal); // Recursively construct the left and right subtrees root.left = constructTree(preorder, inorderStart, inorderIndex - 1); root.right = constructTree(preorder, inorderIndex + 1, inorderEnd); return root; } } int[] preorder = {3, 9, 20, 15, 7}; int[] inorder = {9, 3, 15, 20, 7}; ","content_html":"\u003cp\u003e\u003cstrong\u003e1. Binary Tree Inorder Traversal.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class BinaryTreeInorderTraversal {\n\n    public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) {\n        List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\n        inorderHelper(root, result);\n        return result;\n    }\n\n    private void inorderHelper(TreeNode node, List\u0026lt;Integer\u0026gt; result) {\n        if (node == null) {\n            return;\n        }\n        // Traverse the left subtree\n        inorderHelper(node.left, result);\n        // Visit the root node\n        result.add(node.val);\n        // Traverse the right subtree\n        inorderHelper(node.right, result);\n    }\n}\n\n/*Iterative Approach using Stack */\npublic class BinaryTreeInorderTraversalIterative {\n\n    public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) {\n        List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\n        Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;();\n        TreeNode current = root;\n\n        while (current != null || !stack.isEmpty()) {\n            // Reach the leftmost node of the current node\n            while (current != null) {\n                stack.push(current);\n                current = current.left;\n            }\n            // Current must be null at this point\n            current = stack.pop();\n            result.add(current.val); // Add the node to the result\n            // Visit the right subtree\n            current = current.right;\n        }\n\n        return result;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e2. Preorder Traversal.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class BinaryTreePreorderTraversal {\n    public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) {\n        List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\n        preorderHelper(root, result);\n        return result;\n    }\n\n    private void preorderHelper(TreeNode node, List\u0026lt;Integer\u0026gt; result) {\n        if (node == null) {\n            return;\n        }\n        // Visit the root node\n        result.add(node.val);\n        // Traverse the left subtree\n        preorderHelper(node.left, result);\n        // Traverse the right subtree\n        preorderHelper(node.right, result);\n    }\n}\n\n/*Iterative Approach using Stack */\npublic class BinaryTreePreorderTraversalIterative {\n\n    public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) {\n        List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\n        if (root == null) return result;\n\n        Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;();\n        stack.push(root);\n\n        while (!stack.isEmpty()) {\n            TreeNode node = stack.pop();\n            result.add(node.val);\n\n            // Push right child first so that left child is processed first\n            if (node.right != null) {\n                stack.push(node.right);\n            }\n            if (node.left != null) {\n                stack.push(node.left);\n            }\n        }\n\n        return result;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e3. Postorder Traversal.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class BinaryTreePostorderTraversal {\n    public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) {\n        List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\n        postorderHelper(root, result);\n        return result;\n    }\n\n    private void postorderHelper(TreeNode node, List\u0026lt;Integer\u0026gt; result) {\n        if (node == null) {\n            return;\n        }\n        // Traverse the left subtree\n        postorderHelper(node.left, result);\n        // Traverse the right subtree\n        postorderHelper(node.right, result);\n        // Visit the root node\n        result.add(node.val);\n    }\n}\n\n/*Iterative Approach using Stack */\npublic class BinaryTreePostorderTraversalIterative {\n    public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) {\n        List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\n        if (root == null) return result;\n\n        Stack\u0026lt;TreeNode\u0026gt; stack1 = new Stack\u0026lt;\u0026gt;();\n        Stack\u0026lt;TreeNode\u0026gt; stack2 = new Stack\u0026lt;\u0026gt;();\n        stack1.push(root);\n\n        while (!stack1.isEmpty()) {\n            TreeNode node = stack1.pop();\n            stack2.push(node);\n\n            if (node.left != null) {\n                stack1.push(node.left);\n            }\n            if (node.right != null) {\n                stack1.push(node.right);\n            }\n        }\n\n        while (!stack2.isEmpty()) {\n            result.add(stack2.pop().val);\n        }\n\n        return result;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e3. Level Order Traversal.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class BinaryTreeLevelOrderTraversal {\n    public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) {\n        List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\n        if (root == null) return result;\n\n        Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;();\n        queue.add(root);\n\n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            List\u0026lt;Integer\u0026gt; currentLevel = new ArrayList\u0026lt;\u0026gt;();\n\n            for (int i = 0; i \u0026lt; levelSize; i++) {\n                TreeNode currentNode = queue.poll();\n                currentLevel.add(currentNode.val);\n\n                if (currentNode.left != null) {\n                    queue.add(currentNode.left);\n                }\n                if (currentNode.right != null) {\n                    queue.add(currentNode.right);\n                }\n            }\n            result.add(currentLevel);\n        }\n\n        return result;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e4. Find the maximum depth of a binary tree.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftDepth = maxDepth(root.left);\n        int rightDepth = maxDepth(root.right);\n        return Math.max(leftDepth, rightDepth) + 1;\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e5. Check if a binary tree is height-balanced.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public boolean isBalanced(TreeNode root) {\n        return checkHeight(root) != -1;\n    }\n\n    private int checkHeight(TreeNode node) {\n        if (node == null) {\n            return 0; // Base case: the height of an empty tree is 0\n        }\n\n        int leftHeight = checkHeight(node.left);\n        int rightHeight = checkHeight(node.right);\n\n        if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) \u0026gt; 1) {\n            return -1; // Not balanced\n        }\n\n        return Math.max(leftHeight, rightHeight) + 1; // Height of the current node\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e6. Validate Binary Search Tree.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public boolean isValidBST(TreeNode root) {\n        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n    \n    private boolean isValidBST(TreeNode node, long min, long max) {\n        if (node == null) {\n            return true; // An empty node is always a valid BST\n        }\n        \n        if (node.val \u0026lt;= min || node.val \u0026gt;= max) {\n            return false; // Node's value is out of the allowed range\n        }\n        \n        // Recursively validate the left subtree and right subtree\n        return isValidBST(node.left, min, node.val) \u0026amp;\u0026amp; isValidBST(node.right, node.val, max);\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e7. Find the lowest common ancestor of two nodes in a BST.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIn a BST: If both nodes (p and q) are less than the root node, then the LCA must be in the left subtree. If both nodes (p and q) are greater than the root node, then the LCA must be in the right subtree. If one node is on the left and the other node is on the right of the root, then the root is the LCA.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null) {\n            return null;\n        }\n        \n        // If both p and q are less than root, LCA is in the left subtree\n        if (p.val \u0026lt; root.val \u0026amp;\u0026amp; q.val \u0026lt; root.val) {\n            return lowestCommonAncestor(root.left, p, q);\n        }\n        \n        // If both p and q are greater than root, LCA is in the right subtree\n        if (p.val \u0026gt; root.val \u0026amp;\u0026amp; q.val \u0026gt; root.val) {\n            return lowestCommonAncestor(root.right, p, q);\n        }\n        \n        // If one node is on the left and the other is on the right, root is the LCA\n        return root;\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e8. Insert a node into a BST.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eStart at the Root: Begin at the root node.\nTraverse the Tree: Depending on the value of the node to be inserted: If the value is less than the current node\u0026rsquo;s value, move to the left child. If the value is greater than or equal to the current node\u0026rsquo;s value, move to the right child.\nInsert the Node: When you find an appropriate null position (left or right child), insert the new node there.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public TreeNode insertIntoBST(TreeNode root, int val) {\n        if (root == null) {\n            return new TreeNode(val); // Create a new node if the tree is empty\n        }\n        \n        if (val \u0026lt; root.val) {\n            root.left = insertIntoBST(root.left, val); // Insert in the left subtree\n        } else {\n            root.right = insertIntoBST(root.right, val); // Insert in the right subtree\n        }\n        \n        return root; // Return the unchanged root\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e9. Delete Node in a BST.\u003c/strong\u003e\nTo delete a node in a Binary Search Tree (BST), you need to consider three main cases based on the number of children the node to be deleted has: Node with No Children (Leaf Node): Simply remove the node.\nNode with One Child: Remove the node and replace it with its single child.\nNode with Two Children: Find the node\u0026rsquo;s in-order predecessor (maximum value in the left subtree) or in-order successor (minimum value in the right subtree), swap values with the node to be deleted, and then delete the predecessor or successor.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public TreeNode deleteNode(TreeNode root, int key) {\n        if (root == null) {\n            return null;\n        }\n        \n        if (key \u0026lt; root.val) {\n            root.left = deleteNode(root.left, key);\n        } else if (key \u0026gt; root.val) {\n            root.right = deleteNode(root.right, key);\n        } else {\n            // Node to be deleted found\n            if (root.left == null) {\n                return root.right; // Node with only right child or no child\n            }\n            if (root.right == null) {\n                return root.left; // Node with only left child\n            }\n            \n            // Node with two children: Get the inorder predecessor (largest in the left subtree)\n            TreeNode minNode = getMin(root.right);\n            root.val = minNode.val; // Replace value with inorder successor's value\n            root.right = deleteNode(root.right, minNode.val); // Delete the inorder successor\n        }\n        \n        return root;\n    }\n    \n    private TreeNode getMin(TreeNode node) {\n        while (node.left != null) {\n            node = node.left;\n        }\n        return node;\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e9. Convert Sorted Array to Binary Search Tree.\u003c/strong\u003e\nFind the Middle Element: Choose the middle element of the array to be the root. This ensures that the tree will be balanced.\nRecursively Build Left and Right Subtrees: Apply the same process to the left and right subarrays to build the left and right subtrees.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e     public TreeNode sortedArrayToBST(int[] nums) {\n        return sortedArrayToBSTHelper(nums, 0, nums.length - 1);\n    }\n\n    private TreeNode sortedArrayToBSTHelper(int[] nums, int left, int right) {\n        if (left \u0026gt; right) {\n            return null; // Base case: No elements to form a subtree\n        }\n\n        int mid = left + (right - left) / 2; // Find the middle index\n        TreeNode root = new TreeNode(nums[mid]); // Create the root node\n\n        root.left = sortedArrayToBSTHelper(nums, left, mid - 1); // Recursively build the left subtree\n        root.right = sortedArrayToBSTHelper(nums, mid + 1, right); // Recursively build the right subtree\n\n        return root;\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e9. Serialize and Deserialize Binary Tree.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eSerialization: Traverse the tree and record the value of each node. Use a delimiter to mark the end of children or the absence of children (e.g., null).\nDeserialization: Reconstruct the tree using the serialized data. Use the recorded values to build the tree structure, handling null values to manage missing nodes.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public String serialize(TreeNode root) {\n        if (root == null) {\n            return \u0026quot;null,\u0026quot;;\n        }\n        StringBuilder sb = new StringBuilder();\n        serializeHelper(root, sb);\n        return sb.toString();\n    }\n\n    private void serializeHelper(TreeNode root, StringBuilder sb) {\n        if (root == null) {\n            sb.append(\u0026quot;null,\u0026quot;);\n            return;\n        }\n        sb.append(root.val).append(\u0026quot;,\u0026quot;);\n        serializeHelper(root.left, sb);\n        serializeHelper(root.right, sb);\n    }\n\n    // Deserialization\n    public TreeNode deserialize(String data) {\n        String[] values = data.split(\u0026quot;,\u0026quot;);\n        Queue\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;();\n        for (String value : values) {\n            queue.add(value);\n        }\n        return deserializeHelper(queue);\n    }\n\n    private TreeNode deserializeHelper(Queue\u0026lt;String\u0026gt; queue) {\n        String value = queue.poll();\n        if (value.equals(\u0026quot;null\u0026quot;)) {\n            return null;\n        }\n        TreeNode node = new TreeNode(Integer.parseInt(value));\n        node.left = deserializeHelper(queue);\n        node.right = deserializeHelper(queue);\n        return node;\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e10. Binary Tree Zigzag Level Order Traversal.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eUse a Queue: Use a queue to perform a level order traversal (BFS).\nAlternate Directions: Keep track of the current level\u0026rsquo;s direction. Use a flag to alternate between appending nodes from left to right and from right to left.\nAdd Nodes to the Current Level: Depending on the direction, either add the nodes at the current level to the end of the current level\u0026rsquo;s list or to the front.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; zigzagLevelOrder(TreeNode root) {\n        List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\n        if (root == null) {\n            return result;\n        }\n\n        Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;();\n        queue.offer(root);\n        boolean leftToRight = true;\n\n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            LinkedList\u0026lt;Integer\u0026gt; currentLevel = new LinkedList\u0026lt;\u0026gt;();\n\n            for (int i = 0; i \u0026lt; levelSize; i++) {\n                TreeNode currentNode = queue.poll();\n                \n                if (leftToRight) {\n                    currentLevel.add(currentNode.val);\n                } else {\n                    currentLevel.addFirst(currentNode.val);\n                }\n                \n                if (currentNode.left != null) {\n                    queue.offer(currentNode.left);\n                }\n                if (currentNode.right != null) {\n                    queue.offer(currentNode.right);\n                }\n            }\n\n            result.add(currentLevel);\n            leftToRight = !leftToRight; // Toggle the direction\n        }\n\n        return result;\n    }\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e11. Diameter of Binary Tree.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eHeight of Subtrees: The diameter can be computed by using the height of the left and right subtrees for each node.\nRecursive Depth-First Search (DFS): Traverse the tree using DFS and calculate the height of each subtree. During this traversal, compute the diameter as the sum of the heights of the left and right subtrees. Update Maximum Diameter: Keep track of the maximum diameter encountered during the DFS traversal.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class DiameterOfBinaryTree {\n    private int diameter = 0;\n    public int diameterOfBinaryTree(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        calculateHeight(root);\n        return diameter;\n    }\n    \n    private int calculateHeight(TreeNode node) {\n        if (node == null) {\n            return 0;\n        }\n        \n        int leftHeight = calculateHeight(node.left);\n        int rightHeight = calculateHeight(node.right);\n        \n        // Update the diameter if the path through this node is longer\n        diameter = Math.max(diameter, leftHeight + rightHeight);\n        \n        // Return the height of the subtree rooted at this node\n        return 1 + Math.max(leftHeight, rightHeight);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e12. Find the kth smallest element in a BST..\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIn-Order Traversal: Perform an in-order traversal of the BST. This traversal visits nodes in ascending order because, in a BST, the left subtree contains smaller elements, the root is the next smallest, and the right subtree contains larger elements.\nTracking the k-th Element: During the in-order traversal, keep a count of the nodes visited. When the count equals k, the current node is the k-th smallest element.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class KthSmallestElementInBST {\n    private int count = 0;\n    private int result = Integer.MIN_VALUE;\n\n    public int kthSmallest(TreeNode root, int k) {\n        inOrderTraversal(root, k);\n        return result;\n    }\n\n    private void inOrderTraversal(TreeNode node, int k) {\n        if (node == null) {\n            return;\n        }\n\n        // Traverse the left subtree\n        inOrderTraversal(node.left, k);\n\n        // Process the current node\n        count++;\n        if (count == k) {\n            result = node.val;\n            return;\n        }\n\n        // Traverse the right subtree\n        inOrderTraversal(node.right, k);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e13. Find the maximum path sum in a binary tree (path can start and end at any node).\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eFor each node, calculate the maximum sum of the path that passes through the node and update the global maximum if this value is higher.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class MaxPathSum {\n    private int maxSum = Integer.MIN_VALUE;\n\n    public int maxPathSum(TreeNode root) {\n        calculateMaxSum(root);\n        return maxSum;\n    }\n\n    private int calculateMaxSum(TreeNode node) {\n        if (node == null) {\n            return 0;\n        }\n\n        // Calculate the max path sum from the left and right subtrees\n        int leftMax = Math.max(0, calculateMaxSum(node.left));  // if the value is negative, ignore it\n        int rightMax = Math.max(0, calculateMaxSum(node.right));\n\n        // Calculate the path sum that passes through the current node\n        int currentPathSum = node.val + leftMax + rightMax;\n\n        // Update the global max sum if the current path sum is greater\n        maxSum = Math.max(maxSum, currentPathSum);\n\n        // Return the maximum path sum including the current node and one of its subtrees\n        return node.val + Math.max(leftMax, rightMax);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e14. Construct Binary Tree from Preorder and Inorder Traversal.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eStart with the first element in the preorder array as the root. Find the index of this root element in the inorder array. Elements to the left of this index in the inorder array form the left subtree, and elements to the right form the right subtree. Recursively construct the left and right subtrees using the corresponding segments of the preorder and inorder arrays.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class ConstructBinaryTree {\n    private int preorderIndex = 0;\n    private Map\u0026lt;Integer, Integer\u0026gt; inorderIndexMap = new HashMap\u0026lt;\u0026gt;();\n\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        // Build a map to store value -\u0026gt; index relations from inorder traversal\n        for (int i = 0; i \u0026lt; inorder.length; i++) {\n            inorderIndexMap.put(inorder[i], i);\n        }\n        return constructTree(preorder, 0, inorder.length - 1);\n    }\n\n    private TreeNode constructTree(int[] preorder, int inorderStart, int inorderEnd) {\n        if (inorderStart \u0026gt; inorderEnd) {\n            return null;\n        }\n\n        // Get the current root from preorder traversal\n        int rootVal = preorder[preorderIndex++];\n        TreeNode root = new TreeNode(rootVal);\n\n        // Find the index of the root in inorder traversal\n        int inorderIndex = inorderIndexMap.get(rootVal);\n\n        // Recursively construct the left and right subtrees\n        root.left = constructTree(preorder, inorderStart, inorderIndex - 1);\n        root.right = constructTree(preorder, inorderIndex + 1, inorderEnd);\n\n        return root;\n    }\n}\n    int[] preorder = {3, 9, 20, 15, 7};\n    int[] inorder = {9, 3, 15, 20, 7};\n\u003c/code\u003e\u003c/pre\u003e\n","url":"https://karthikselvam.com/posts/2024/10/08/trees_part_2/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"8106-08-09T100:88:00+00:00","date_modified":"8106-08-09T100:88:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"693a349d516b54923a177f95dd1c2548242214d7","title":"Fundamental Analsysis Framework","summary":"2024","content_text":" Understand the Company and Industry Company Overview: Begin by understanding what the company does, its products or services, its market position, and its business model. Industry Analysis: Analyze the industry the company operates in, including its growth prospects, competitive landscape, and key trends. Use frameworks like Porter’s Five Forces to understand the industry\u0026rsquo;s dynamics. Financial Statement Analysis Income Statement: Revenue Growth: Look at the company’s top-line growth over time. Profit Margins: Analyze gross margin, operating margin, and net margin to understand profitability. Gross Margin shows how much profit is made after covering the cost of goods sold. Operating Margin shows how much profit remains after covering operating expenses. Net Margin shows the final profit after all expenses, including interest and taxes. Earnings Per Share (EPS): Evaluate trends in EPS, which reflects profitability on a per-share basis. Balance Sheet: Assets and Liabilities: Assess the company’s asset base, including cash, receivables, and long-term investments, compared to its liabilities. Debt Levels: Evaluate the company’s debt-to-equity ratio and other leverage ratios to understand its financial risk. Liquidity Ratios: Analyze current and quick ratios to gauge the company’s ability to meet short-term obligations. Cash Flow Statement: Operating Cash Flow: Determine how much cash the company generates from its core operations. Free Cash Flow: Evaluate free cash flow (operating cash flow minus capital expenditures), which is crucial for dividend payments, buybacks, and growth investments. Cash Flow from Investing and Financing: Look at the company’s investment in growth and how it finances its operations. Valuation Analysis Price-to-Earnings (P/E) Ratio: Compare the P/E ratio with industry peers and the broader market to gauge valuation. Price-to-Book (P/B) Ratio: Evaluate how the market values the company relative to its book value. Price-to-Sales (P/S) Ratio: Analyze the valuation relative to revenue. Discounted Cash Flow (DCF) Analysis: Perform a DCF analysis to estimate the company’s intrinsic value by projecting future cash flows and discounting them to the present value. Growth Prospects Historical Growth: Look at historical revenue, earnings, and cash flow growth rates. Future Growth Projections: Analyze analyst estimates, company guidance, and growth drivers such as market expansion, new products, or acquisitions. Profitability and Efficiency Ratios Return on Equity (ROE): Measure how effectively the company uses shareholders’ equity to generate profit. Return on Assets (ROA): Evaluate how efficiently the company uses its assets to generate earnings. Return on Invested Capital (ROIC): Assess the company\u0026rsquo;s ability to generate returns on its investments. Operating Efficiency: Use ratios like asset turnover and inventory turnover to gauge operational efficiency. Debt and Solvency Analysis Debt-to-Equity Ratio: Evaluate the proportion of debt used in the company’s capital structure. Interest Coverage Ratio: Determine the company’s ability to meet interest payments on its debt. Debt Servicing: Look at the company’s ability to repay its debt using free cash flow and operating income. Dividend Analysis (if applicable) Dividend Yield: Compare the dividend yield to industry averages. Dividend Payout Ratio: Analyze the portion of earnings paid out as dividends. Sustainability: Assess whether the dividends are sustainable based on cash flow and earnings. Management and Corporate Governance Management Quality: Review the experience and track record of the management team. Corporate Governance: Evaluate the company\u0026rsquo;s governance practices, board structure, and any history of shareholder issues. Competitive Advantage (Moat) Economic Moat: Identify whether the company has a sustainable competitive advantage, such as brand strength, patents, cost leadership, or network effects. Risk Analysis Operational Risks: Consider risks related to the company’s operations, such as supply chain issues or key dependencies. Market Risks: Assess market risks, including economic cycles, competition, and changes in consumer preferences. Regulatory Risks: Evaluate any regulatory or legal challenges the company faces. ESG (Environmental, Social, Governance) Considerations Environmental Impact: Look at the company’s environmental practices and potential risks. Social Responsibility: Consider the company’s social impact and practices. Governance: Evaluate the company’s governance practices and transparency. Peer and Industry Comparison Compare the company’s key metrics with industry averages and peer companies to gauge relative performance and valuation. Final Investment Decision Intrinsic Value vs. Market Price: Compare the stock’s intrinsic value to its current market price to determine if it’s overvalued, undervalued, or fairly valued. Buy, Hold, or Sell: Based on your analysis, decide whether to buy, hold, or sell the stock. This step-by-step analysis provides a comprehensive view of the company’s fundamentals, helping you make an informed investment decision. ","content_html":"\u003col\u003e\n\u003cli\u003eUnderstand the Company and Industry\nCompany Overview: Begin by understanding what the company does, its products or services, its market position, and its business model.\nIndustry Analysis: Analyze the industry the company operates in, including its growth prospects, competitive landscape, and key trends. Use frameworks like Porter’s Five Forces to understand the industry\u0026rsquo;s dynamics.\u003c/li\u003e\n\u003cli\u003eFinancial Statement Analysis\nIncome Statement:\nRevenue Growth: Look at the company’s top-line growth over time.\nProfit Margins: Analyze gross margin, operating margin, and net margin to understand profitability.\nGross Margin shows how much profit is made after covering the cost of goods sold. Operating Margin shows how much profit remains after covering operating expenses. Net Margin shows the final profit after all expenses, including interest and taxes.\nEarnings Per Share (EPS): Evaluate trends in EPS, which reflects profitability on a per-share basis.\nBalance Sheet:\nAssets and Liabilities: Assess the company’s asset base, including cash, receivables, and long-term investments, compared to its liabilities.\nDebt Levels: Evaluate the company’s debt-to-equity ratio and other leverage ratios to understand its financial risk.\nLiquidity Ratios: Analyze current and quick ratios to gauge the company’s ability to meet short-term obligations.\nCash Flow Statement:\nOperating Cash Flow: Determine how much cash the company generates from its core operations.\nFree Cash Flow: Evaluate free cash flow (operating cash flow minus capital expenditures), which is crucial for dividend payments, buybacks, and growth investments.\nCash Flow from Investing and Financing: Look at the company’s investment in growth and how it finances its operations.\u003c/li\u003e\n\u003cli\u003eValuation Analysis\nPrice-to-Earnings (P/E) Ratio: Compare the P/E ratio with industry peers and the broader market to gauge valuation.\nPrice-to-Book (P/B) Ratio: Evaluate how the market values the company relative to its book value.\nPrice-to-Sales (P/S) Ratio: Analyze the valuation relative to revenue.\nDiscounted Cash Flow (DCF) Analysis: Perform a DCF analysis to estimate the company’s intrinsic value by projecting future cash flows and discounting them to the present value.\u003c/li\u003e\n\u003cli\u003eGrowth Prospects\nHistorical Growth: Look at historical revenue, earnings, and cash flow growth rates.\nFuture Growth Projections: Analyze analyst estimates, company guidance, and growth drivers such as market expansion, new products, or acquisitions.\u003c/li\u003e\n\u003cli\u003eProfitability and Efficiency Ratios\nReturn on Equity (ROE): Measure how effectively the company uses shareholders’ equity to generate profit.\nReturn on Assets (ROA): Evaluate how efficiently the company uses its assets to generate earnings.\nReturn on Invested Capital (ROIC): Assess the company\u0026rsquo;s ability to generate returns on its investments.\nOperating Efficiency: Use ratios like asset turnover and inventory turnover to gauge operational efficiency.\u003c/li\u003e\n\u003cli\u003eDebt and Solvency Analysis\nDebt-to-Equity Ratio: Evaluate the proportion of debt used in the company’s capital structure.\nInterest Coverage Ratio: Determine the company’s ability to meet interest payments on its debt.\nDebt Servicing: Look at the company’s ability to repay its debt using free cash flow and operating income.\u003c/li\u003e\n\u003cli\u003eDividend Analysis (if applicable)\nDividend Yield: Compare the dividend yield to industry averages.\nDividend Payout Ratio: Analyze the portion of earnings paid out as dividends.\nSustainability: Assess whether the dividends are sustainable based on cash flow and earnings.\u003c/li\u003e\n\u003cli\u003eManagement and Corporate Governance\nManagement Quality: Review the experience and track record of the management team.\nCorporate Governance: Evaluate the company\u0026rsquo;s governance practices, board structure, and any history of shareholder issues.\u003c/li\u003e\n\u003cli\u003eCompetitive Advantage (Moat)\nEconomic Moat: Identify whether the company has a sustainable competitive advantage, such as brand strength, patents, cost leadership, or network effects.\u003c/li\u003e\n\u003cli\u003eRisk Analysis\nOperational Risks: Consider risks related to the company’s operations, such as supply chain issues or key dependencies.\nMarket Risks: Assess market risks, including economic cycles, competition, and changes in consumer preferences.\nRegulatory Risks: Evaluate any regulatory or legal challenges the company faces.\u003c/li\u003e\n\u003cli\u003eESG (Environmental, Social, Governance) Considerations\nEnvironmental Impact: Look at the company’s environmental practices and potential risks.\nSocial Responsibility: Consider the company’s social impact and practices.\nGovernance: Evaluate the company’s governance practices and transparency.\u003c/li\u003e\n\u003cli\u003ePeer and Industry Comparison\nCompare the company’s key metrics with industry averages and peer companies to gauge relative performance and valuation.\u003c/li\u003e\n\u003cli\u003eFinal Investment Decision\nIntrinsic Value vs. Market Price: Compare the stock’s intrinsic value to its current market price to determine if it’s overvalued, undervalued, or fairly valued.\nBuy, Hold, or Sell: Based on your analysis, decide whether to buy, hold, or sell the stock.\nThis step-by-step analysis provides a comprehensive view of the company’s fundamentals, helping you make an informed investment decision.\u003c/li\u003e\n\u003c/ol\u003e\n","url":"https://karthikselvam.com/posts/2024/08/17/fundamental_framework/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"17086-17-09T80:1717:00+00:00","date_modified":"17086-17-09T80:1717:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"8dc2e8a61f2e5c2c41fb8313ad5bea0e609c7ad2","title":"Command Pattern","summary":"2024","content_text":" Implement Transaction Management: Extend the Command Pattern implementation to support transaction management. This exercise will involve implementing methods to start, commit, and rollback transactions, where a transaction consists of multiple commands that are executed atomically. // Command interface interface Command { void execute(); void undo(); } // Concrete command class ConcreteCommand implements Command { private Receiver receiver; ConcreteCommand(Receiver receiver) { this.receiver = receiver; } public void execute() { receiver.action(); } public void undo() { receiver.undoAction(); } } // Receiver class Receiver { void action() { System.out.println(\u0026quot;Receiver is executing action...\u0026quot;); } void undoAction() { System.out.println(\u0026quot;Receiver is undoing action...\u0026quot;); } } // Invoker class Invoker { private List\u0026lt;Command\u0026gt; commands = new ArrayList\u0026lt;\u0026gt;(); void addCommand(Command command) { commands.add(command); } void executeCommands() { for (Command command : commands) { command.execute(); } } void undoCommands() { for (int i = commands.size() - 1; i \u0026gt;= 0; i--) { commands.get(i).undo(); } } } // Client public class Client { public static void main(String[] args) { Receiver receiver = new Receiver(); Invoker invoker = new Invoker(); // Start transaction System.out.println(\u0026quot;Starting transaction...\u0026quot;); // Add commands to the transaction invoker.addCommand(new ConcreteCommand(receiver)); invoker.addCommand(new ConcreteCommand(receiver)); invoker.addCommand(new ConcreteCommand(receiver)); // Execute commands invoker.executeCommands(); // Commit transaction System.out.println(\u0026quot;Committing transaction...\u0026quot;); // Start another transaction System.out.println(\u0026quot;Starting another transaction...\u0026quot;); // Add commands to the new transaction invoker.addCommand(new ConcreteCommand(receiver)); invoker.addCommand(new ConcreteCommand(receiver)); // Execute commands invoker.executeCommands(); // Rollback transaction System.out.println(\u0026quot;Rolling back transaction...\u0026quot;); invoker.undoCommands(); } } Implement Remote Control for Devices: Create a remote control application that allows users to control various devices (e.g., lights, TV, stereo) using the Command Pattern. Each device action (e.g., turning on/off, changing volume) should be encapsulated as a command object. // Receiver class Light { void turnOn() { System.out.println(\u0026quot;Light is on\u0026quot;); } void turnOff() { System.out.println(\u0026quot;Light is off\u0026quot;); } } class TV { void turnOn() { System.out.println(\u0026quot;TV is on\u0026quot;); } void turnOff() { System.out.println(\u0026quot;TV is off\u0026quot;); } void changeVolume(int volume) { System.out.println(\u0026quot;TV volume changed to \u0026quot; + volume); } } // Command interface interface Command { void execute(); } // Concrete commands class LightOnCommand implements Command { private Light light; LightOnCommand(Light light) { this.light = light; } public void execute() { light.turnOn(); } } class LightOffCommand implements Command { private Light light; LightOffCommand(Light light) { this.light = light; } public void execute() { light.turnOff(); } } class TVOnCommand implements Command { private TV tv; TVOnCommand(TV tv) { this.tv = tv; } public void execute() { tv.turnOn(); } } class TVOffCommand implements Command { private TV tv; TVOffCommand(TV tv) { this.tv = tv; } public void execute() { tv.turnOff(); } } class TVVolumeCommand implements Command { private TV tv; private int volume; TVVolumeCommand(TV tv, int volume) { this.tv = tv; this.volume = volume; } public void execute() { tv.changeVolume(volume); } } // Invoker class RemoteControl { private Command command; void setCommand(Command command) { this.command = command; } void pressButton() { command.execute(); } } // Client public class RemoteControlClient { public static void main(String[] args) { // Create devices Light light = new Light(); TV tv = new TV(); // Create commands Command lightOn = new LightOnCommand(light); Command lightOff = new LightOffCommand(light); Command tvOn = new TVOnCommand(tv); Command tvOff = new TVOffCommand(tv); Command tvVolume = new TVVolumeCommand(tv, 20); // Set initial volume to 20 // Create remote control RemoteControl remoteControl = new RemoteControl(); // Associate commands with remote control buttons remoteControl.setCommand(lightOn); // Button 1 turns on the light remoteControl.pressButton(); remoteControl.setCommand(tvOn); // Button 2 turns on the TV remoteControl.pressButton(); remoteControl.setCommand(tvVolume); // Button 3 changes TV volume remoteControl.pressButton(); remoteControl.setCommand(tvOff); // Button 4 turns off the TV remoteControl.pressButton(); remoteControl.setCommand(lightOff); // Button 5 turns off the light remoteControl.pressButton(); } } Implement Undo/Redo functionality: Enhance the Command Pattern implementation to support undo and redo operations. This exercise will require you to maintain a history of executed commands and implement methods to undo and redo commands. import java.util.Stack; // Receiver class Light { void turnOn() { System.out.println(\u0026quot;Light is on\u0026quot;); } void turnOff() { System.out.println(\u0026quot;Light is off\u0026quot;); } } // Command interface interface Command { void execute(); void undo(); } // Concrete commands class LightOnCommand implements Command { private Light light; LightOnCommand(Light light) { this.light = light; } public void execute() { light.turnOn(); } public void undo() { light.turnOff(); } } class LightOffCommand implements Command { private Light light; LightOffCommand(Light light) { this.light = light; } public void execute() { light.turnOff(); } public void undo() { light.turnOn(); } } // Invoker class RemoteControl { private Stack\u0026lt;Command\u0026gt; undoStack = new Stack\u0026lt;\u0026gt;(); private Stack\u0026lt;Command\u0026gt; redoStack = new Stack\u0026lt;\u0026gt;(); void executeCommand(Command command) { command.execute(); undoStack.push(command); redoStack.clear(); // Clear redo stack when a new command is executed } void undo() { if (!undoStack.isEmpty()) { Command command = undoStack.pop(); command.undo(); redoStack.push(command); } else { System.out.println(\u0026quot;Nothing to undo\u0026quot;); } } void redo() { if (!redoStack.isEmpty()) { Command command = redoStack.pop(); command.execute(); undoStack.push(command); } else { System.out.println(\u0026quot;Nothing to redo\u0026quot;); } } } // Client public class RemoteControlClient { public static void main(String[] args) { // Create devices Light light = new Light(); // Create commands Command lightOn = new LightOnCommand(light); Command lightOff = new LightOffCommand(light); // Create remote control RemoteControl remoteControl = new RemoteControl(); // Execute commands remoteControl.executeCommand(lightOn); // Turn on the light remoteControl.executeCommand(lightOff); // Turn off the light // Undo the last command remoteControl.undo(); // Should turn on the light // Redo the last undone command remoteControl.redo(); // Should turn off the light } } ","content_html":"\u003col\u003e\n\u003cli\u003eImplement Transaction Management: Extend the Command Pattern implementation to support transaction management. This exercise will involve implementing methods to start, commit, and rollback transactions, where a transaction consists of multiple commands that are executed atomically.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Command interface\ninterface Command {\n    void execute();\n    void undo();\n}\n\n// Concrete command\nclass ConcreteCommand implements Command {\n    private Receiver receiver;\n\n    ConcreteCommand(Receiver receiver) {\n        this.receiver = receiver;\n    }\n\n    public void execute() {\n        receiver.action();\n    }\n\n    public void undo() {\n        receiver.undoAction();\n    }\n}\n\n// Receiver\nclass Receiver {\n    void action() {\n        System.out.println(\u0026quot;Receiver is executing action...\u0026quot;);\n    }\n\n    void undoAction() {\n        System.out.println(\u0026quot;Receiver is undoing action...\u0026quot;);\n    }\n}\n\n// Invoker\nclass Invoker {\n    private List\u0026lt;Command\u0026gt; commands = new ArrayList\u0026lt;\u0026gt;();\n\n    void addCommand(Command command) {\n        commands.add(command);\n    }\n\n    void executeCommands() {\n        for (Command command : commands) {\n            command.execute();\n        }\n    }\n\n    void undoCommands() {\n        for (int i = commands.size() - 1; i \u0026gt;= 0; i--) {\n            commands.get(i).undo();\n        }\n    }\n}\n\n// Client\npublic class Client {\n    public static void main(String[] args) {\n        Receiver receiver = new Receiver();\n        Invoker invoker = new Invoker();\n\n        // Start transaction\n        System.out.println(\u0026quot;Starting transaction...\u0026quot;);\n        \n        // Add commands to the transaction\n        invoker.addCommand(new ConcreteCommand(receiver));\n        invoker.addCommand(new ConcreteCommand(receiver));\n        invoker.addCommand(new ConcreteCommand(receiver));\n\n        // Execute commands\n        invoker.executeCommands();\n\n        // Commit transaction\n        System.out.println(\u0026quot;Committing transaction...\u0026quot;);\n\n        // Start another transaction\n        System.out.println(\u0026quot;Starting another transaction...\u0026quot;);\n\n        // Add commands to the new transaction\n        invoker.addCommand(new ConcreteCommand(receiver));\n        invoker.addCommand(new ConcreteCommand(receiver));\n\n        // Execute commands\n        invoker.executeCommands();\n\n        // Rollback transaction\n        System.out.println(\u0026quot;Rolling back transaction...\u0026quot;);\n        invoker.undoCommands();\n    }\n}\n\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eImplement Remote Control for Devices: Create a remote control application that allows users to control various devices (e.g., lights, TV, stereo) using the Command Pattern. Each device action (e.g., turning on/off, changing volume) should be encapsulated as a command object.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e\n// Receiver\nclass Light {\n    void turnOn() {\n        System.out.println(\u0026quot;Light is on\u0026quot;);\n    }\n\n    void turnOff() {\n        System.out.println(\u0026quot;Light is off\u0026quot;);\n    }\n}\n\nclass TV {\n    void turnOn() {\n        System.out.println(\u0026quot;TV is on\u0026quot;);\n    }\n\n    void turnOff() {\n        System.out.println(\u0026quot;TV is off\u0026quot;);\n    }\n\n    void changeVolume(int volume) {\n        System.out.println(\u0026quot;TV volume changed to \u0026quot; + volume);\n    }\n}\n\n// Command interface\ninterface Command {\n    void execute();\n}\n\n// Concrete commands\nclass LightOnCommand implements Command {\n    private Light light;\n\n    LightOnCommand(Light light) {\n        this.light = light;\n    }\n\n    public void execute() {\n        light.turnOn();\n    }\n}\n\nclass LightOffCommand implements Command {\n    private Light light;\n\n    LightOffCommand(Light light) {\n        this.light = light;\n    }\n\n    public void execute() {\n        light.turnOff();\n    }\n}\n\nclass TVOnCommand implements Command {\n    private TV tv;\n\n    TVOnCommand(TV tv) {\n        this.tv = tv;\n    }\n\n    public void execute() {\n        tv.turnOn();\n    }\n}\n\nclass TVOffCommand implements Command {\n    private TV tv;\n\n    TVOffCommand(TV tv) {\n        this.tv = tv;\n    }\n\n    public void execute() {\n        tv.turnOff();\n    }\n}\n\nclass TVVolumeCommand implements Command {\n    private TV tv;\n    private int volume;\n\n    TVVolumeCommand(TV tv, int volume) {\n        this.tv = tv;\n        this.volume = volume;\n    }\n\n    public void execute() {\n        tv.changeVolume(volume);\n    }\n}\n\n// Invoker\nclass RemoteControl {\n    private Command command;\n\n    void setCommand(Command command) {\n        this.command = command;\n    }\n\n    void pressButton() {\n        command.execute();\n    }\n}\n\n// Client\npublic class RemoteControlClient {\n    public static void main(String[] args) {\n        // Create devices\n        Light light = new Light();\n        TV tv = new TV();\n\n        // Create commands\n        Command lightOn = new LightOnCommand(light);\n        Command lightOff = new LightOffCommand(light);\n        Command tvOn = new TVOnCommand(tv);\n        Command tvOff = new TVOffCommand(tv);\n        Command tvVolume = new TVVolumeCommand(tv, 20); // Set initial volume to 20\n\n        // Create remote control\n        RemoteControl remoteControl = new RemoteControl();\n\n        // Associate commands with remote control buttons\n        remoteControl.setCommand(lightOn); // Button 1 turns on the light\n        remoteControl.pressButton();\n\n        remoteControl.setCommand(tvOn); // Button 2 turns on the TV\n        remoteControl.pressButton();\n\n        remoteControl.setCommand(tvVolume); // Button 3 changes TV volume\n        remoteControl.pressButton();\n\n        remoteControl.setCommand(tvOff); // Button 4 turns off the TV\n        remoteControl.pressButton();\n\n        remoteControl.setCommand(lightOff); // Button 5 turns off the light\n        remoteControl.pressButton();\n    }\n}\n\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eImplement Undo/Redo functionality: Enhance the Command Pattern implementation to support undo and redo operations. This exercise will require you to maintain a history of executed commands and implement methods to undo and redo commands.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e\nimport java.util.Stack;\n\n// Receiver\nclass Light {\n    void turnOn() {\n        System.out.println(\u0026quot;Light is on\u0026quot;);\n    }\n\n    void turnOff() {\n        System.out.println(\u0026quot;Light is off\u0026quot;);\n    }\n}\n\n// Command interface\ninterface Command {\n    void execute();\n    void undo();\n}\n\n// Concrete commands\nclass LightOnCommand implements Command {\n    private Light light;\n\n    LightOnCommand(Light light) {\n        this.light = light;\n    }\n\n    public void execute() {\n        light.turnOn();\n    }\n\n    public void undo() {\n        light.turnOff();\n    }\n}\n\nclass LightOffCommand implements Command {\n    private Light light;\n\n    LightOffCommand(Light light) {\n        this.light = light;\n    }\n\n    public void execute() {\n        light.turnOff();\n    }\n\n    public void undo() {\n        light.turnOn();\n    }\n}\n\n// Invoker\nclass RemoteControl {\n    private Stack\u0026lt;Command\u0026gt; undoStack = new Stack\u0026lt;\u0026gt;();\n    private Stack\u0026lt;Command\u0026gt; redoStack = new Stack\u0026lt;\u0026gt;();\n\n    void executeCommand(Command command) {\n        command.execute();\n        undoStack.push(command);\n        redoStack.clear(); // Clear redo stack when a new command is executed\n    }\n\n    void undo() {\n        if (!undoStack.isEmpty()) {\n            Command command = undoStack.pop();\n            command.undo();\n            redoStack.push(command);\n        } else {\n            System.out.println(\u0026quot;Nothing to undo\u0026quot;);\n        }\n    }\n\n    void redo() {\n        if (!redoStack.isEmpty()) {\n            Command command = redoStack.pop();\n            command.execute();\n            undoStack.push(command);\n        } else {\n            System.out.println(\u0026quot;Nothing to redo\u0026quot;);\n        }\n    }\n}\n\n// Client\npublic class RemoteControlClient {\n    public static void main(String[] args) {\n        // Create devices\n        Light light = new Light();\n\n        // Create commands\n        Command lightOn = new LightOnCommand(light);\n        Command lightOff = new LightOffCommand(light);\n\n        // Create remote control\n        RemoteControl remoteControl = new RemoteControl();\n\n        // Execute commands\n        remoteControl.executeCommand(lightOn); // Turn on the light\n        remoteControl.executeCommand(lightOff); // Turn off the light\n\n        // Undo the last command\n        remoteControl.undo(); // Should turn on the light\n\n        // Redo the last undone command\n        remoteControl.redo(); // Should turn off the light\n    }\n}\n\n\n\u003c/code\u003e\u003c/pre\u003e\n","url":"https://karthikselvam.com/posts/2024/05/10/command_pattern/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"10056-10-09T50:1010:00+00:00","date_modified":"10056-10-09T50:1010:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"8753fde0384f6164c5280d39b923b644d3967856","title":"Scaling Databases","summary":"2024","content_text":"Storage services are stateful services. Compared to stateless services, stateful services have mechanisms to ensure consistency and require redundancy to avoid data loss. A stateful service may choose mechanisms like Paxos for strong consistency or eventual consistency mechanisms. These are complex decisions, and tradeoffs have to be made, which depend on the various requirements like consistency, complexity, security, latency, and performance. This is one reason we keep all services stateless as much as possible and keep state only in stateful services.\nAnother reason is that if we keep state in individual hosts of a web or backend service, we will need to implement sticky sessions, consistently routing the same user to the same host. We will also need to replicate the data in case a host fails and handle failover (such as routing the users to the appropriate new host when their host fails). By push- ing all states to a stateful storage service, we can choose the appropriate storage/data- base technology for our requirements, and take advantage of not having to design, implement, and make mistakes with managing state.\nStorage can be broadly classified into the following.\nSQL : Has relational characteristics such as tables and relationships between tables, including primary keys and foreign keys. SQL must have ACID properties. NoSQL: A database that does not have all SQL properties. Column oriented database : Organizes data into columns instead of rows for efficient filtering. Examples are Cassandra and HBase. Keyvalue store : Data is stored as a collection of key-value pairs. Each key corresponds to a disk location via a hashing algorithm. Read performance is good. Keys must be hashable, so they are primitive types and cannot be pointers to objects. Values don’t have this limitation; they can be primitives or pointers. Key-value databases are usually used for caching, employing various techniques like Least Recently Used (LRU). Cache has high performance but does not require high availability (because if the cache is unavailable, the requester can query the original data source). Examples are Memcached and Redis. Document store : Can be interpreted as a key-value database where values have no size limits or much larger limits than key-value databases. Values can be in various formats. Text, JSON, or YAML are common. An example is MongoDB. - Graph Database : Designed to efficiently store relationships between entities. Examples are Neo4j, RedisGraph, and Amazon Neptune. File storage : Data stored in files, which can be organized into directories/folders. We can see it as a form of key-value, with path as the key. Block storage : Stores data in evenly sized chunks with unique identifiers. We are unlikely to use block storage in web applications. Block storage is relevant for designing low-level components of other storage systems (such as databases). Object storage : Flatter hierarchy than file storage. Objects are usually accessed with simple HTTP APIs. Writing objects is slow, and objects cannot be modified, so object storage is suited for static data. AWS S3 is a cloud example. When to use vs. avoid databases When deciding how to store a service’s data, you may discuss using a database vs. other possibilities such as file, block, and object storage. During the interview, remember that even though you may prefer certain approaches and you can state a preference during an interview, you must be able to discuss all relevant factors and consider others’ opin- ions.\nReplication\n","content_html":"\u003cp\u003eStorage services are stateful services. Compared to stateless services, stateful services have mechanisms to ensure consistency and require redundancy to avoid data loss. A stateful service may choose mechanisms like Paxos for strong consistency or eventual consistency mechanisms. These are complex decisions, and tradeoffs have to be made, which depend on the various requirements like consistency, complexity, security, latency, and performance. This is one reason we keep all services stateless as much as possible and keep state only in stateful services.\u003c/p\u003e\n\u003cp\u003eAnother reason is that if we keep state in individual hosts of a web or backend service, we will need to implement sticky sessions, consistently routing the same user to the same host. We will also need to replicate the data in case a host fails and handle failover (such as routing the users to the appropriate new host when their host fails). By push- ing all states to a stateful storage service, we can choose the appropriate storage/data- base technology for our requirements, and take advantage of not having to design, implement, and make mistakes with managing state.\u003c/p\u003e\n\u003cp\u003eStorage can be broadly classified into the following.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSQL : Has relational characteristics such as tables and relationships between tables, including primary keys and foreign keys. SQL must have ACID properties.\u003c/li\u003e\n\u003cli\u003eNoSQL: A database that does not have all SQL properties.\u003c/li\u003e\n\u003cli\u003eColumn oriented database : Organizes data into columns instead of rows for efficient filtering. Examples are Cassandra and HBase.\u003c/li\u003e\n\u003cli\u003eKeyvalue store : Data is stored as a collection of key-value pairs. Each key corresponds to a disk location via a hashing algorithm. Read performance is good. Keys must be hashable, so they are primitive types and cannot be pointers to objects. Values don’t have this limitation; they can be primitives or pointers. Key-value databases are usually used for caching, employing various techniques like Least Recently Used (LRU). Cache has high performance but does not require high availability (because if the cache is unavailable, the requester can query the original data source). Examples are Memcached and Redis.\u003c/li\u003e\n\u003cli\u003eDocument store : Can be interpreted as a key-value database where values have no size limits or much larger limits than key-value databases. Values can be in various formats. Text, JSON, or YAML are common. An example is MongoDB.     - Graph Database : Designed to efficiently store relationships between entities. Examples are Neo4j, RedisGraph, and Amazon Neptune.\u003c/li\u003e\n\u003cli\u003eFile storage : Data stored in files, which can be organized into directories/folders. We can see it as a form of key-value, with path as the key.\u003c/li\u003e\n\u003cli\u003eBlock storage : Stores data in evenly sized chunks with unique identifiers. We are unlikely to use block storage in web applications. Block storage is relevant for designing low-level components of other storage systems (such as databases).\u003c/li\u003e\n\u003cli\u003eObject storage : Flatter hierarchy than file storage. Objects are usually accessed with simple HTTP APIs. Writing objects is slow, and objects cannot be modified, so object storage is suited for static data. AWS S3 is a cloud example.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eWhen to use vs. avoid databases\nWhen deciding how to store a service’s data, you may discuss using a database vs. other possibilities such as file, block, and object storage. During the interview, remember that even though you may prefer certain approaches and you can state a preference during an interview, you must be able to discuss all relevant factors and consider others’ opin- ions.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eReplication\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n","url":"https://karthikselvam.com/posts/2024/05/02/scaling_db/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"2056-02-09T50:22:00+00:00","date_modified":"2056-02-09T50:22:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"6270afe060f6d604d220629d6c6307d1205fff1e","title":"Non Functional Requirements","summary":"2024","content_text":"A system has functional and non-functional requirements. Functional requirements describe the inputs and outputs of the system. You can represent them as a rough API specification and endpoints.\nNon-functional requirements refer to requirements other than the system inputs and outputs. Typical non-functional requirements include the following\nScalability—The ability of a system to adjust its hardware resource usage easily and with little fuss to cost-efficiently support its load. The process of expanding to support a larger load or number of users is called scal- ing. Scaling requires increases in CPU processing power, RAM, storage capacity, and network bandwidth.Scaling can refer to vertical scaling or horizontal scaling. Vertical scaling is conceptually straightforward and can be easily achieved just by spending more money. It means upgrading to a more powerful and expensive host, one with a faster processor, more RAM, a bigger hard disk drive, a solid-state drive instead of a spinning hard disk for lower latency, or a network card with higher bandwidth.\nThere are three main disadvantages of vertical scaling.\nWe will reach a point where monetary cost increases faster than the upgraded hardware’s performance. For example, a custom mainframe that has multiple proces- sors will cost more than the same number of separate commodity machines that have one processor each.\nVertical scaling has technological limits. Regardless of budget, current technological limitations will impose a maximum amount of processing power, RAM, or storage capacity that is technologically possible on a single host.\nVertical scaling may require downtime. We must stop our host, change its hardware and then start it again. To avoid downtime, we need to provision another host, start our service on it, and then direct requests to the new host. Moreover, this is only possible if the service’s state is stored on a different machine from the old or new host.\nHorizontal scaling refers to spreading out the processing and storage requirements across multiple hosts. “True” scalability can only be achieved by horizontal scaling.\nStateless and stateful services HTTP is a stateless protocol, so a backend service that uses it is easy to scale horizontally Availability - Availability is the percentage of time a system can accept requests and return the desired response. High availability is required in most services, and other non-functional requirements may be traded off to allow high availability without unnecessary complexity. ","content_html":"\u003cp\u003eA system has functional and non-functional requirements. Functional requirements describe the inputs and outputs of the system. You can represent them as a rough API specification and endpoints.\u003c/p\u003e\n\u003cp\u003eNon-functional requirements refer to requirements other than the system inputs and outputs. Typical non-functional requirements include the following\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eScalability—The ability of a system to adjust its hardware resource usage easily and with little fuss to cost-efficiently support its load. The process of expanding to support a larger load or number of users is called scal- ing. Scaling requires increases in CPU processing power, RAM, storage capacity, and network bandwidth.Scaling can refer to vertical scaling or horizontal scaling.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eVertical scaling is conceptually straightforward and can be easily achieved just by spending more money. It means upgrading to a more powerful and expensive host, one with a faster processor, more RAM, a bigger hard disk drive, a solid-state drive instead of a spinning hard disk for lower latency, or a network card with higher bandwidth.\u003c/p\u003e\n\u003cp\u003eThere are three main disadvantages of vertical scaling.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eWe will reach a point where monetary cost increases faster than the upgraded hardware’s performance. For example, a custom mainframe that has multiple proces- sors will cost more than the same number of separate commodity machines that have one processor each.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eVertical scaling has technological limits. Regardless of budget, current technological limitations will impose a maximum amount of processing power, RAM, or storage capacity that is technologically possible on a single host.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eVertical scaling may require downtime. We must stop our host, change its hardware and then start it again. To avoid downtime, we need to provision another host, start our service on it, and then direct requests to the new host. Moreover, this is only possible if the service’s state is stored on a different machine from the old or new host.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHorizontal scaling refers to spreading out the processing and storage requirements across multiple hosts. “True” scalability can only be achieved by horizontal scaling.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eStateless and stateful services\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003eHTTP is a stateless protocol, so a backend service that uses it is easy to scale horizontally\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eAvailability - Availability is the percentage of time a system can accept requests and return the desired response.\nHigh availability is required in most services, and other non-functional requirements may be traded off to allow high availability without unnecessary complexity.\u003c/li\u003e\n\u003c/ol\u003e\n","url":"https://karthikselvam.com/posts/2024/05/01/non_functional_requirements/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"1056-01-09T50:11:00+00:00","date_modified":"1056-01-09T50:11:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"8c1ce0f8aea37fc1b6f2d50e18c905602591ea86","title":"Linked List","summary":"2024","content_text":"In this article, we will solve linked list related problems that are commonly encountered in interviews.\n1. Reverse Linked List.\npublic class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode current = head; while (current != null) { ListNode nextTemp = current.next; current.next = prev; prev = current; current = nextTemp; } return prev; // prev now points to the new head of the reversed list } } Time complexity: O(n), where n is the number of nodes in the linked list.The algorithm iterates through each node of the linked list once. The time complexity is directly proportional to the number of nodes in the list\nSpace complexity: O(1) The iterative approach uses a constant amount of extra space regardless of the size of the input linked list. We only use a few extra pointers (prev, current, nextTemp) to perform the reversal in place, hence the space complexity is constant.\n2. Merge Two Sorted Lists.\nclass Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { final ListNode root = new ListNode(); ListNode prev = root; while (list1 != null \u0026amp;\u0026amp; list2 != null) { if (list1.val \u0026lt; list2.val) { prev.next = list1; list1 = list1.next; } else { prev.next = list2; list2 = list2.next; } prev = prev.next; } prev.next = list1 != null ? list1 : list2; return root.next; } } Time complexity: O(n), where n is the number of nodes in the linked list.The algorithm iterates through each node of the linked list once. The time complexity is directly proportional to the number of nodes in the list\nSpace complexity: O(1) The iterative approach uses a constant amount of extra space regardless of the size of the input linked list. We only use a few extra pointers (prev, root) to perform the reversal in place, hence the space complexity is constant.\n3. Reorder List.\nclass Solution { public void reorderList(ListNode head) { //Find middle of list using a slow and fast pointer approach ListNode slow = head; ListNode fast = head.next; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } //Reverse the second half of the list using a tmp variable ListNode second = slow.next; ListNode prev = slow.next = null; while (second != null) { ListNode tmp = second.next; second.next = prev; prev = second; second = tmp; } //Re-assign the pointers to match the pattern ListNode first = head; second = prev; while (second != null) { ListNode tmp1 = first.next; ListNode tmp2 = second.next; first.next = second; second.next = tmp1; first = tmp1; second = tmp2; } } } Time complexity: O(n), where n is the number of nodes in the linked list.The algorithm iterates through each node of the linked list once. The time complexity is directly proportional to the number of nodes in the list\nSpace complexity: O(1) The iterative approach uses a constant amount of extra space regardless of the size of the input linked list. We only use a few extra pointers (prev, root) to perform the reversal in place, hence the space complexity is constant.\n4. Remove nth node from the end of list.\npublic class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode fast = dummy; ListNode slow = dummy; // Move fast pointer n steps ahead for (int i = 0; i \u0026lt;= n; i++) { fast = fast.next; } // Move both fast and slow pointers until fast reaches the end while (fast != null) { fast = fast.next; slow = slow.next; } // Remove the nth node from the end slow.next = slow.next.next; return dummy.next; } } Time complexity: O(n), where n is the number of nodes in the linked list.The algorithm iterates through each node of the linked list once. The time complexity is directly proportional to the number of nodes in the list\nSpace complexity: O(1) The iterative approach uses a constant amount of extra space regardless of the size of the input linked list.\n5. Linked List Cycle.\npublic class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) return true; } return false; } } Time complexity: O(n), where n is the number of nodes in the linked list.The algorithm iterates through each node of the linked list once. The time complexity is directly proportional to the number of nodes in the list\nSpace complexity: O(1) The iterative approach uses a constant amount of extra space regardless of the size of the input linked list.\n6. Find the Duplicate Number.\npublic int findDuplicate(int[] nums) { // Initialize slow and fast pointers int slow = nums[0]; int fast = nums[0]; // Move slow pointer one step and fast pointer two steps do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow != fast); // Move slow pointer to the start slow = nums[0]; // Move both pointers at the same speed until they meet while (slow != fast) { slow = nums[slow]; fast = nums[fast]; } // Return the duplicate number return slow; } Time complexity: The first phase, where we detect the cycle, takes O(n) time, where n is the length of the array.The second phase, where we find the entrance to the cycle, also takes O(n) time in the worst case.\nSpace complexity: O(1) We are only using a few extra integer variables to store indices (slow and fast pointers), so the space complexity is O(1), constant space.\n7. Merge k Sorted Lists.\n// Solution using Min Heap // Time Complexity: O(n*log(k)) // Extra Space Complexity: O(k) class Solution1 { public ListNode mergeKLists(ListNode[] lists) { if (lists == null || lists.length == 0) { return null; } PriorityQueue\u0026lt;ListNode\u0026gt; queue = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a.val - b.val); for (ListNode node : lists) { if (node != null) { queue.offer(node); } } ListNode dummy = new ListNode(0); ListNode current = dummy; while (!queue.isEmpty()) { ListNode node = queue.poll(); current.next = node; current = current.next; if (node.next != null) { queue.offer(node.next); } } return dummy.next; } } class Solution2 { public ListNode mergeKLists(ListNode[] lists) { int size = lists.length; int interval = 1; while (interval \u0026lt; size) { for (int i = 0; i \u0026lt; size - interval; i += 2 * interval) { lists[i] = mergeTwoLists(lists[i], lists[i + interval]); } interval *= 2; } return size \u0026gt; 0 ? lists[0] : null; } } Time complexity: The first phase, where we detect the cycle, takes O(n) time, where n is the length of the array.The second phase, where we find the entrance to the cycle, also takes O(n) time in the worst case.\nSpace complexity: O(1) We are only using a few extra integer variables to store indices (slow and fast pointers), so the space complexity is O(1), constant space.\n5. Copy List with Random Pointer.\nclass Solution { public Node copyRandomList(Node head) { Node cur = head; HashMap\u0026lt;Node, Node\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); while (cur != null) { map.put(cur, new Node(cur.val)); cur = cur.next; } cur = head; while (cur != null) { map.get(cur).next = map.get(cur.next); map.get(cur).random = map.get(cur.random); cur = cur.next; } return map.get(head); } } Time complexity: In the first pass, we iterate through the original list once to create a copy of each node. This operation takes O(n), where n is the number of nodes in the original list. In the second pass, we again iterate through the original list once to link the copied nodes and assign random pointers. This operation also takes O(n).\nSpace complexity: O(n) due to the HashMap and the additional nodes created for the copied list.\n","content_html":"\u003cp\u003eIn this article, we will solve linked list related problems that are commonly encountered in interviews.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. \u003ca href=\"https://leetcode.com/problems/reverse-linked-list/\"\u003eReverse Linked List\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode current = head;\n        \n        while (current != null) {\n            ListNode nextTemp = current.next;\n            current.next = prev;\n            prev = current;\n            current = nextTemp;\n        }\n        \n        return prev; // prev now points to the new head of the reversed list\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n), where n is the number of nodes in the linked list.The algorithm iterates through each node of the linked list once. The time complexity is directly proportional to the number of nodes in the list\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(1) The iterative approach uses a constant amount of extra space regardless of the size of the input linked list. We only use a few extra pointers (prev, current, nextTemp) to perform the reversal in place, hence the space complexity is constant.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e2. \u003ca href=\"https://leetcode.com/problems/merge-two-sorted-lists/\"\u003eMerge Two Sorted Lists\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        final ListNode root = new ListNode();\n        ListNode prev = root;\n        while (list1 != null \u0026amp;\u0026amp; list2 != null) {\n            if (list1.val \u0026lt; list2.val) {\n                prev.next = list1;\n                list1 = list1.next;\n            } else {\n                prev.next = list2;\n                list2 = list2.next;\n            }\n            prev = prev.next;\n        }\n        prev.next = list1 != null ? list1 : list2;\n        return root.next;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n), where n is the number of nodes in the linked list.The algorithm iterates through each node of the linked list once. The time complexity is directly proportional to the number of nodes in the list\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(1) The iterative approach uses a constant amount of extra space regardless of the size of the input linked list. We only use a few extra pointers (prev, root) to perform the reversal in place, hence the space complexity is constant.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e3. \u003ca href=\"https://leetcode.com/problems/reorder-list/\"\u003eReorder List\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public void reorderList(ListNode head) {\n        //Find middle of list using a slow and fast pointer approach\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast != null \u0026amp;\u0026amp; fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        //Reverse the second half of the list using a tmp variable\n        ListNode second = slow.next;\n        ListNode prev = slow.next = null;\n        while (second != null) {\n            ListNode tmp = second.next;\n            second.next = prev;\n            prev = second;\n            second = tmp;\n        }\n        //Re-assign the pointers to match the pattern\n        ListNode first = head;\n        second = prev;\n        while (second != null) {\n            ListNode tmp1 = first.next;\n            ListNode tmp2 = second.next;\n            first.next = second;\n            second.next = tmp1;\n            first = tmp1;\n            second = tmp2;\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n), where n is the number of nodes in the linked list.The algorithm iterates through each node of the linked list once. The time complexity is directly proportional to the number of nodes in the list\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(1) The iterative approach uses a constant amount of extra space regardless of the size of the input linked list. We only use a few extra pointers (prev, root) to perform the reversal in place, hence the space complexity is constant.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e4. \u003ca href=\"https://leetcode.com/problems/remove-nth-node-from-end-of-list/\"\u003eRemove nth node from the end of list\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode fast = dummy;\n        ListNode slow = dummy;\n        \n        // Move fast pointer n steps ahead\n        for (int i = 0; i \u0026lt;= n; i++) {\n            fast = fast.next;\n        }\n        \n        // Move both fast and slow pointers until fast reaches the end\n        while (fast != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        // Remove the nth node from the end\n        slow.next = slow.next.next;\n        \n        return dummy.next;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n), where n is the number of nodes in the linked list.The algorithm iterates through each node of the linked list once. The time complexity is directly proportional to the number of nodes in the list\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(1) The iterative approach uses a constant amount of extra space regardless of the size of the input linked list.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e5. \u003ca href=\"https://leetcode.com/problems/linked-list-cycle/\"\u003eLinked List Cycle\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Solution {\n\n    public boolean hasCycle(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast != null \u0026amp;\u0026amp; fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n), where n is the number of nodes in the linked list.The algorithm iterates through each node of the linked list once. The time complexity is directly proportional to the number of nodes in the list\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(1) The iterative approach uses a constant amount of extra space regardless of the size of the input linked list.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e6. \u003ca href=\"https://leetcode.com/problems/find-the-duplicate-number/\"\u003eFind the Duplicate Number\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public int findDuplicate(int[] nums) {\n        // Initialize slow and fast pointers\n        int slow = nums[0];\n        int fast = nums[0];\n        \n        // Move slow pointer one step and fast pointer two steps\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while (slow != fast);\n        \n        // Move slow pointer to the start\n        slow = nums[0];\n        \n        // Move both pointers at the same speed until they meet\n        while (slow != fast) {\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n        \n        // Return the duplicate number\n        return slow;\n    }\n\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: The first phase, where we detect the cycle, takes O(n) time, where n is the length of the array.The second phase, where we find the entrance to the cycle, also takes O(n) time in the worst case.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(1) We are only using a few extra integer variables to store indices (slow and fast pointers), so the space complexity is O(1), constant space.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e7. \u003ca href=\"https://leetcode.com/problems/merge-k-sorted-lists/\"\u003eMerge k Sorted Lists\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    //  Solution using Min Heap\n    //  Time Complexity: O(n*log(k))\n    //  Extra Space Complexity: O(k)\nclass Solution1 {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) {\n            return null;\n        }\n\n        PriorityQueue\u0026lt;ListNode\u0026gt; queue = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) {\n                queue.offer(node);\n            }\n        }\n\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n\n        while (!queue.isEmpty()) {\n            ListNode node = queue.poll();\n            current.next = node;\n            current = current.next;\n\n            if (node.next != null) {\n                queue.offer(node.next);\n            }\n        }\n\n        return dummy.next;\n    }\n}\n\nclass Solution2 {\n    public ListNode mergeKLists(ListNode[] lists) {\n        int size = lists.length;\n        int interval = 1;\n\n        while (interval \u0026lt; size) {\n            for (int i = 0; i \u0026lt; size - interval; i += 2 * interval) {\n                lists[i] = mergeTwoLists(lists[i], lists[i + interval]);\n            }\n\n            interval *= 2;\n        }\n\n        return size \u0026gt; 0 ? lists[0] : null;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: The first phase, where we detect the cycle, takes O(n) time, where n is the length of the array.The second phase, where we find the entrance to the cycle, also takes O(n) time in the worst case.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(1) We are only using a few extra integer variables to store indices (slow and fast pointers), so the space complexity is O(1), constant space.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e5. \u003ca href=\"https://leetcode.com/problems/copy-list-with-random-pointer\"\u003eCopy List with Random Pointer\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n\n    public Node copyRandomList(Node head) {\n        Node cur = head;\n        HashMap\u0026lt;Node, Node\u0026gt; map = new HashMap\u0026lt;\u0026gt;();\n        while (cur != null) {\n            map.put(cur, new Node(cur.val));\n            cur = cur.next;\n        }\n        cur = head;\n        while (cur != null) {\n            map.get(cur).next = map.get(cur.next);\n            map.get(cur).random = map.get(cur.random);\n            cur = cur.next;\n        }\n        return map.get(head);\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: In the first pass, we iterate through the original list once to create a copy of each node. This operation takes O(n), where n is the number of nodes in the original list. In the second pass, we again iterate through the original list once to link the copied nodes and assign random pointers. This operation also takes O(n).\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(n) due to the HashMap and the additional nodes created for the copied list.\u003c/p\u003e\n\u003chr\u003e\n","url":"https://karthikselvam.com/posts/2024/04/22/linked_list/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"22046-22-09T40:2222:00+00:00","date_modified":"22046-22-09T40:2222:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"252887e855393445fd56659608814f1d270362b1","title":"Recursion \u0026 Backtracking","summary":"2024","content_text":"In this article, we will solve recursion and backtracking related problems that are commonly encountered in interviews.\n**1. Given an array of integers, print all combinations of size X.\npublic static void printCombos(int[] a, int x) { if (a == null || a.length == 0 || x \u0026gt; a.length) return; int[] buffer = new int[x]; printCombosHelper(a, buffer, 0, 0); } public static void printCombosHelper(int[] a, int[] buffer, int startIndex, int bufferIndex) { // termination cases - buffer full if (bufferIndex == buffer.length) { printArray(buffer); return; } if (startIndex == a.length) { return; } // find candidates that go into current buffer index for (int i = startIndex; i \u0026lt; a.length; i++) { // place item into buffer buffer[bufferIndex] = a[i]; // recurse to next buffer index printCombosHelper(a, buffer, i + 1, bufferIndex + 1); } } Time complexity: O(n^x), where n is the length of array \u0026lsquo;a\u0026rsquo; and \u0026lsquo;x\u0026rsquo; is the size of combinations.\nSpace complexity: O(x), for the buffer array.\n**2. Given an array of integers A, print all its subsets.\npublic static void printSubsets(int[] a, int x) { if (a == null || a.length == 0 || x \u0026gt; a.length) return; int[] buffer = new int[x]; printCombosHelper(a, buffer, 0, 0); } public static void printSubsetsHelper(int[] a, int[] buffer, int startIndex, int bufferIndex) { printArray(buffer); // termination cases - buffer full if (bufferIndex == buffer.length) { return; } if (startIndex == a.length) { return; } // find candidates that go into current buffer index for (int i = startIndex; i \u0026lt; a.length; i++) { // place item into buffer buffer[bufferIndex] = a[i]; // recurse to next buffer index printCombosHelper(a, buffer, i + 1, bufferIndex + 1); } } Time complexity: O(n^x), where n is the length of array \u0026lsquo;a\u0026rsquo; and \u0026lsquo;x\u0026rsquo; is the size of combinations.\nSpace complexity: O(x), for the buffer array.\n3. Subsets.\nclass Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; templist = new ArrayList\u0026lt;\u0026gt;(); getSubsets(nums,result,templist,0); return result; } public void getSubsets(int[] nums, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; tempList , int start){ result.add(new ArrayList(tempList)); if(start \u0026gt;= nums.length){ return; } for(int i = start ; i \u0026lt; nums.length ; i++){ tempList.add(nums[i]); getSubsets(nums,result,tempList,i+1); tempList.remove(tempList.size()-1); } } } 3. Subsets II.\nclass Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsetsWithDup(int[] nums) { Arrays.sort(nums) ; List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; tempList = new ArrayList\u0026lt;\u0026gt;(); getSubsets(nums,result,tempList,0); return result; } public void getSubsets(int[] nums, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; tempList , int start){ result.add(new ArrayList(tempList)); if(start \u0026gt;= nums.length){ return; } for(int i =start ; i \u0026lt; nums.length ; i++){ if(i \u0026gt; start \u0026amp;\u0026amp; nums[i-1] == nums[i]){ continue; } tempList.add(nums[i]); getSubsets(nums,result,tempList,i+1); tempList.remove(tempList.size()-1); } } } Time complexity: O(n), where n is the number of nodes in the linked list.The algorithm iterates through each node of the linked list once. The time complexity is directly proportional to the number of nodes in the list\nSpace complexity: O(1) The iterative approach uses a constant amount of extra space regardless of the size of the input linked list. We only use a few extra pointers (prev, current, nextTemp) to perform the reversal in place, hence the space complexity is constant.\n**4. Given an array A, print all permutations of size X.\npublic static void printPerms(int[] a, int x) { if (a == null || a.length == 0 || x \u0026gt; a.length) return; int[] buffer = new int[x]; boolean[] isInBuffer = new boolean[a.length]; printPermsHelper(a, buffer, 0, isInBuffer); } public static void printPermsHelper(int[] a, int[] buffer, int bufferIndex, boolean[] isInBuffer) { // termination cases - buffer full if (bufferIndex == buffer.length) { printArray(buffer); return; } // find candidates that go into current buffer index for (int i = startIndex; i \u0026lt; a.length; i++) { // place item into buffer buffer[bufferIndex] = a[i]; isInBuffer[i] = true; // recurse to next buffer index printCombosHelper(a, buffer, bufferIndex + 1, isInBuffer); isInBuffer[i] = false; } } Time complexity: O(n^x), where n is the length of array \u0026lsquo;a\u0026rsquo; and \u0026lsquo;x\u0026rsquo; is the size of combinations.\nSpace complexity: O(x), for the buffer array.\n6. Palindrome Partitioning.\nclass Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; partition(String s) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; partitions = new ArrayList\u0026lt;\u0026gt;(); backtrack(s, 0, new ArrayList\u0026lt;\u0026gt;(), partitions); return partitions; } private void backtrack(String s, int start, List\u0026lt;String\u0026gt; path, List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; partitions) { if (start == s.length()) { partitions.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for (int end = start + 1; end \u0026lt;= s.length(); end++) { if (isPalindrome(s, start, end - 1)) { path.add(s.substring(start, end)); backtrack(s, end, path, partitions); path.remove(path.size() - 1); } } } private boolean isPalindrome(String s, int left, int right) { while (left \u0026lt; right) { if (s.charAt(left++) != s.charAt(right--)) { return false; } } return true; } } 7. Combination Sum.\nclass Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); backtrack(candidates, target, 0, new ArrayList\u0026lt;\u0026gt;(), result); return result; } private void backtrack(int[] candidates, int target, int start, List\u0026lt;Integer\u0026gt; combination, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result) { if (target == 0) { result.add(new ArrayList\u0026lt;\u0026gt;(combination)); return; } for (int i = start; i \u0026lt; candidates.length; i++) { if (candidates[i] \u0026lt;= target) { combination.add(candidates[i]); backtrack(candidates, target - candidates[i], i, combination, result); combination.remove(combination.size() - 1); } } } } 8. Permutations.\nclass Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); backtrack(result, new ArrayList\u0026lt;\u0026gt;(), nums); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; tempList, int[] nums) { if (tempList.size() == nums.length) { result.add(new ArrayList\u0026lt;\u0026gt;(tempList)); } else { for (int i = 0; i \u0026lt; nums.length; i++) { if (tempList.contains(nums[i])) continue; tempList.add(nums[i]); backtrack(result, tempList, nums); tempList.remove(tempList.size() - 1); } } } } 8. Combination Sum II.\nclass Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(candidates); backtrack(result, new ArrayList\u0026lt;\u0026gt;(), candidates, target, 0); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; tempList, int[] candidates, int remain, int start) { if (remain \u0026lt; 0) return; else if (remain == 0) result.add(new ArrayList\u0026lt;\u0026gt;(tempList)); else { for (int i = start; i \u0026lt; candidates.length; i++) { if (i \u0026gt; start \u0026amp;\u0026amp; candidates[i] == candidates[i - 1]) continue; // skip duplicates tempList.add(candidates[i]); backtrack(result, tempList, candidates, remain - candidates[i], i + 1); tempList.remove(tempList.size() - 1); } } } } 9. Word Search.\nclass Solution { public boolean exist(char[][] board, String word) { int rows = board.length ; int cols = board[0].length; for(int r = 0 ; r \u0026lt; rows; r++ ){ for(int c = 0 ; c \u0026lt; cols; c++){ if(dfs(board,word,r,c,rows,cols,0)){ return true; } } } return false; } public boolean dfs(char[][] board, String word, int r, int c , int rows, int cols, int index) { if(index == word.length()){ return true; } if(oob(r,c,rows,cols) || board[r][c] != word.charAt(index) || board[r][c] == '#' ){ return false; } char ch = board[r][c]; board[r][c] = '#'; boolean result = dfs(board,word,r+1,c,rows,cols,index+1) || dfs(board,word,r-1,c,rows,cols,index+1) || dfs(board,word,r,c-1,rows,cols,index+1) || dfs(board,word,r,c+1,rows,cols,index+1) ; board[r][c] = ch; return result; } public boolean oob(int r, int c , int rows , int cols) { if(r \u0026gt; rows-1 || r \u0026lt; 0 || c\u0026gt; cols-1 || c \u0026lt; 0) { return true; } else{ return false; } } } ","content_html":"\u003cp\u003eIn this article, we will solve recursion and backtracking related problems that are commonly encountered in interviews.\u003c/p\u003e\n\u003cp\u003e**1. Given an array of integers, print all combinations of size X.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static void printCombos(int[] a, int x) {\n    if (a == null || a.length == 0 || x \u0026gt; a.length)\n        return;\n    int[] buffer = new int[x];\n    printCombosHelper(a, buffer, 0, 0);\n}\n\npublic static void printCombosHelper(int[] a, int[] buffer, int startIndex, int bufferIndex) {\n    // termination cases - buffer full\n    if (bufferIndex == buffer.length) {\n        printArray(buffer);\n        return;\n    }\n    if (startIndex == a.length) {\n        return;\n    }\n    // find candidates that go into current buffer index\n    for (int i = startIndex; i \u0026lt; a.length; i++) {\n        // place item into buffer\n        buffer[bufferIndex] = a[i];\n        // recurse to next buffer index\n        printCombosHelper(a, buffer, i + 1, bufferIndex + 1);\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n^x), where n is the length of array \u0026lsquo;a\u0026rsquo; and \u0026lsquo;x\u0026rsquo; is the size of combinations.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(x), for the buffer array.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e**2. Given an array of integers A, print all its subsets.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static void printSubsets(int[] a, int x) {\n    if (a == null || a.length == 0 || x \u0026gt; a.length)\n        return;\n    int[] buffer = new int[x];\n    printCombosHelper(a, buffer, 0, 0);\n}\n\npublic static void printSubsetsHelper(int[] a, int[] buffer, int startIndex, int bufferIndex) {\n    printArray(buffer);\n    // termination cases - buffer full\n    if (bufferIndex == buffer.length) {\n        return;\n    }\n    if (startIndex == a.length) {\n        return;\n    }\n    // find candidates that go into current buffer index\n    for (int i = startIndex; i \u0026lt; a.length; i++) {\n        // place item into buffer\n        buffer[bufferIndex] = a[i];\n        // recurse to next buffer index\n        printCombosHelper(a, buffer, i + 1, bufferIndex + 1);\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n^x), where n is the length of array \u0026lsquo;a\u0026rsquo; and \u0026lsquo;x\u0026rsquo; is the size of combinations.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(x), for the buffer array.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e3. \u003ca href=\"https://leetcode.com/problems/subsets/\"\u003eSubsets\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) {\n        List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\n        List\u0026lt;Integer\u0026gt; templist  = new  ArrayList\u0026lt;\u0026gt;();\n        getSubsets(nums,result,templist,0);\n        return result;\n    }\n    \n    public void getSubsets(int[] nums, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; tempList , int start){\n            result.add(new ArrayList(tempList));\n            if(start \u0026gt;= nums.length){\n                return;\n            }\n            for(int i = start ; i \u0026lt; nums.length ; i++){\n                tempList.add(nums[i]);\n                getSubsets(nums,result,tempList,i+1);\n                tempList.remove(tempList.size()-1);\n            }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e3. \u003ca href=\"https://leetcode.com/problems/subsets-ii/\"\u003eSubsets II\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsetsWithDup(int[] nums) {\n        Arrays.sort(nums) ;\n        List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\n        List\u0026lt;Integer\u0026gt; tempList = new ArrayList\u0026lt;\u0026gt;();\n        getSubsets(nums,result,tempList,0);\n        return result;\n    }\n    \n    public void getSubsets(int[] nums, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; tempList , int start){\n       result.add(new ArrayList(tempList));\n       if(start \u0026gt;= nums.length){\n           return;\n       }\n       for(int i =start ; i \u0026lt; nums.length ; i++){\n           if(i \u0026gt; start \u0026amp;\u0026amp; nums[i-1] == nums[i]){\n                continue; \n           }\n           tempList.add(nums[i]);\n           getSubsets(nums,result,tempList,i+1);\n           tempList.remove(tempList.size()-1);\n       }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n), where n is the number of nodes in the linked list.The algorithm iterates through each node of the linked list once. The time complexity is directly proportional to the number of nodes in the list\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(1) The iterative approach uses a constant amount of extra space regardless of the size of the input linked list. We only use a few extra pointers (prev, current, nextTemp) to perform the reversal in place, hence the space complexity is constant.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e**4. Given an array A, print all permutations of size X.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static void printPerms(int[] a, int x) {\n    if (a == null || a.length == 0 || x \u0026gt; a.length)\n        return;\n    int[] buffer = new int[x];\n    boolean[] isInBuffer = new boolean[a.length];\n    printPermsHelper(a, buffer, 0, isInBuffer);\n}\n\npublic static void printPermsHelper(int[] a, int[] buffer, int bufferIndex, boolean[] isInBuffer) {\n    // termination cases - buffer full\n    if (bufferIndex == buffer.length) {\n        printArray(buffer);\n        return;\n    }\n    // find candidates that go into current buffer index\n    for (int i = startIndex; i \u0026lt; a.length; i++) {\n        // place item into buffer\n        buffer[bufferIndex] = a[i];\n        isInBuffer[i] = true;\n        // recurse to next buffer index\n        printCombosHelper(a, buffer, bufferIndex + 1, isInBuffer);\n        isInBuffer[i] = false;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n^x), where n is the length of array \u0026lsquo;a\u0026rsquo; and \u0026lsquo;x\u0026rsquo; is the size of combinations.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(x), for the buffer array.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e6. \u003ca href=\"https://leetcode.com/problems/palindrome-partitioning/\"\u003ePalindrome Partitioning\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; partition(String s) {\n        List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; partitions = new ArrayList\u0026lt;\u0026gt;();\n        backtrack(s, 0, new ArrayList\u0026lt;\u0026gt;(), partitions);\n        return partitions;\n    }\n    \n    private void backtrack(String s, int start, List\u0026lt;String\u0026gt; path, List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; partitions) {\n        if (start == s.length()) {\n            partitions.add(new ArrayList\u0026lt;\u0026gt;(path));\n            return;\n        }\n        \n        for (int end = start + 1; end \u0026lt;= s.length(); end++) {\n            if (isPalindrome(s, start, end - 1)) {\n                path.add(s.substring(start, end));\n                backtrack(s, end, path, partitions);\n                path.remove(path.size() - 1);\n            }\n        }\n    }\n    \n    private boolean isPalindrome(String s, int left, int right) {\n        while (left \u0026lt; right) {\n            if (s.charAt(left++) != s.charAt(right--)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e7. \u003ca href=\"hhttps://leetcode.com/problems/combination-sum/\"\u003eCombination Sum\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) {\n        List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\n        backtrack(candidates, target, 0, new ArrayList\u0026lt;\u0026gt;(), result);\n        return result;\n    }\n    \n    private void backtrack(int[] candidates, int target, int start, List\u0026lt;Integer\u0026gt; combination, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result) {\n        if (target == 0) {\n            result.add(new ArrayList\u0026lt;\u0026gt;(combination));\n            return;\n        }\n        \n        for (int i = start; i \u0026lt; candidates.length; i++) {\n            if (candidates[i] \u0026lt;= target) {\n                combination.add(candidates[i]);\n                backtrack(candidates, target - candidates[i], i, combination, result);\n                combination.remove(combination.size() - 1);\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e8. \u003ca href=\"https://leetcode.com/problems/permutations/\"\u003ePermutations\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) {\n        List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\n        backtrack(result, new ArrayList\u0026lt;\u0026gt;(), nums);\n        return result;\n    }\n\n    private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; tempList, int[] nums) {\n        if (tempList.size() == nums.length) {\n            result.add(new ArrayList\u0026lt;\u0026gt;(tempList));\n        } else {\n            for (int i = 0; i \u0026lt; nums.length; i++) {\n                if (tempList.contains(nums[i])) continue;\n                tempList.add(nums[i]);\n                backtrack(result, tempList, nums);\n                tempList.remove(tempList.size() - 1);\n            }\n        }\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e8. \u003ca href=\"https://leetcode.com/problems/combination-sum-ii\"\u003eCombination Sum II\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) {\n        List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\n        Arrays.sort(candidates);\n        backtrack(result, new ArrayList\u0026lt;\u0026gt;(), candidates, target, 0);\n        return result;\n    }\n\n    private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; tempList, int[] candidates, int remain, int start) {\n        if (remain \u0026lt; 0) return;\n        else if (remain == 0) result.add(new ArrayList\u0026lt;\u0026gt;(tempList));\n        else {\n            for (int i = start; i \u0026lt; candidates.length; i++) {\n                if (i \u0026gt; start \u0026amp;\u0026amp; candidates[i] == candidates[i - 1]) continue; // skip duplicates\n                tempList.add(candidates[i]);\n                backtrack(result, tempList, candidates, remain - candidates[i], i + 1);\n                tempList.remove(tempList.size() - 1);\n            }\n        }\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e9. \u003ca href=\"https://leetcode.com/problems/word-search/\"\u003eWord Search\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public boolean exist(char[][] board, String word) {\n        int rows = board.length ; \n        int cols = board[0].length;\n        \n        for(int r = 0 ; r \u0026lt; rows; r++ ){\n            for(int c = 0 ; c \u0026lt; cols; c++){\n                if(dfs(board,word,r,c,rows,cols,0)){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n   public boolean dfs(char[][] board, String word, int r, int c , int rows, int cols, int index) {\n       if(index == word.length()){\n           return true;\n       }\n       \n       if(oob(r,c,rows,cols) || board[r][c] != word.charAt(index) || board[r][c] == '#' ){\n           return false;\n       }\n       \n       char ch = board[r][c];\n       board[r][c] = '#';\n       boolean result = dfs(board,word,r+1,c,rows,cols,index+1) ||  dfs(board,word,r-1,c,rows,cols,index+1) || \n                dfs(board,word,r,c-1,rows,cols,index+1) ||  dfs(board,word,r,c+1,rows,cols,index+1) ;\n       board[r][c] = ch;\n       return result;\n   }\n    \n    public boolean oob(int r, int c , int rows , int cols) {\n       if(r \u0026gt; rows-1 || r \u0026lt; 0 || c\u0026gt; cols-1 || c \u0026lt; 0) {\n           return true;\n       } else{\n           return false;\n       }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n","url":"https://karthikselvam.com/posts/2024/04/22/recursion_backtracking/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"22046-22-09T40:2222:00+00:00","date_modified":"22046-22-09T40:2222:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"1e7081d736f43ad30574ac906d26acdd03c38ed9","title":"Trees","summary":"2024","content_text":"In this article, we will solve trees-related problems that are commonly encountered in interviews.\n1. Invert Binary Tree.\npublic TreeNode invertTree(TreeNode root) { if(root == null) { return null; } TreeNode tempNode = root.left; root.left = root.right; root.right = tempNode; invertTree(root.left); invertTree(root.right); return root; } Time complexity: O(n) The given code performs a depth-first search traversal of the binary tree, and visits each node exactly once. Therefore, the time complexity of the code is O(n), where n is the number of nodes in the binary tree.\nSpace complexity: O(n) The space complexity of the code depends on the maximum depth of the binary tree. In the worst case, if the binary tree is skewed (i.e., all the nodes are in a straight line), the maximum depth of the tree would be n (the number of nodes), and the space complexity of the code would be O(n) due to the recursive function calls. However, in the best case, if the binary tree is balanced, the maximum depth of the tree would be log(n), and the space complexity of the code would be O(log(n)).\n2. Maximum Depth of Binary Tree.\npublic int maxDepth(TreeNode root) { if(root == null){ return 0; } int left = maxDepth(root.left); int right = maxDepth(root.right); return 1 + Math.max(left,right); } Time complexity: O(n) where n is the number of nodes in the binary tree, since the code visits each node exactly once.\nSpace complexity: O(h), where h is the height of the binary tree, since the code uses a recursive approach, and the maximum depth of the recursive call stack is equal to the height of the binary tree. In the worst case, where the binary tree is skewed (i.e., all the nodes are in a straight line), the height of the tree would be n (the number of nodes), and the space complexity of the code would be O(n). However, in the best case, where the binary tree is balanced, the height of the tree would be log(n), and the space complexity of the code would be O(log(n)).\n3. Diameter of Binary Tree.\npublic int diameterOfBinaryTree(TreeNode root) { int leftDepth = depth(root.left); int rightDepth = depth(root.right); return Math.max(Math.max(diameterOfBinaryTree(root.left), diameterOfBinaryTree(root.right)), leftDepth + rightDepth); } private int depth(TreeNode root){ if(root == null){ return 0; } int left = depth(root.left); int right = depth(root.right); return 1 + Math.max(left, right); } Time complexity: O(n^2^) wwhere n is the number of nodes in the binary tree, since for each node, the code visits all the nodes in its left and right subtrees to compute the diameter.\nSpace complexity: O(h), where h is the height of the binary tree, since the code uses a recursive approach, and the maximum depth of the recursive call stack is equal to the height of the binary tree. In the worst case, where the binary tree is skewed (i.e., all the nodes are in a straight line), the height of the tree would be n (the number of nodes), and the space complexity of the code would be O(n). However, in the best case, where the binary tree is balanced, the height of the tree would be log(n), and the space complexity of the code would be O(log(n)).\nOptimized Verison : We can optimize by computing the diameter of the binary tree in a single pass, instead of recursively computing the depth of each node multiple times.\npublic int diameterOfBinaryTree(TreeNode root) { int[] max = {0}; depth(root, max); return max[0]; } private int depth(TreeNode root, int[] max) { if (root == null) { return 0; } int left = depth(root.left, max); int right = depth(root.right, max); max[0] = Math.max(max[0], left + right); return 1 + Math.max(left, right); } Time complexity: O(n) where n is the number of nodes in the binary tree.\nSpace complexity: O(h), where h is the height of the binary tree.\n4. Balanced Binary Tree.\npublic boolean isBalanced(TreeNode root) { if(root == null){ return true; } int leftHeight = height(root.left); int rightHeight = height(root.right); if(Math.abs(leftHeight - rightHeight) \u0026gt; 1){ return false; } return isBalanced(root.left) \u0026amp;\u0026amp; isBalanced(root.right); } private int height(TreeNode root){ if(root == null){ return 0; } int left = height(root.left); int right = height(root.right); return 1 + Math.max(left,right); } Time complexity: O(n log n) in the worst case, where n is the number of nodes in the binary tree. This is because the height of each node is computed recursively using the height method, which has a time complexity of O(n) in the worst case. Since the height method is called for each node in the binary tree, the overall time complexity of isBalanced is O(n log n), because the binary tree has a maximum of log n levels.\nSpace complexity: O(n) in the worst case, where n is the number of nodes in the binary tree. This is because the height method is called recursively for each node in the binary tree, and the maximum depth of the recursive call stack is equal to the height of the binary tree, which is O(n) in the worst case. Additionally, the method uses a constant amount of extra space to store the heights of the left and right subtrees of each node. Therefore, the overall space complexity of isBalanced is O(n).\nOptimized version :\npublic boolean isBalanced(TreeNode root) { return checkBalance(root) != -1; } private int checkBalance(TreeNode root) { if (root == null) { return 0; } int left = checkBalance(root.left); if (left == -1) { return -1; } int right = checkBalance(root.right); if (right == -1) { return -1; } if (Math.abs(left - right) \u0026gt; 1) { return -1; } return 1 + Math.max(left, right); } The time complexity of the optimized isBalanced method is O(n), where n is the number of nodes in the binary tree, because each node is visited only once and its height is computed in constant time. The space complexity is O(n) as well, because the maximum depth of the recursive call stack is equal to the height of the binary tree, which is O(n) in the worst case.\n5. Same Tree.\npublic boolean isSameTree(TreeNode p, TreeNode q) { if (p == null \u0026amp;\u0026amp; q == null) { return true; } if (p == null || q == null || p.val != q.val) { return false; } return isSameTree(p.left, q.left) \u0026amp;\u0026amp; isSameTree(p.right, q.right); } Time complexity: O(n), where n is the total number of nodes in the tree. This is because the function performs a recursive traversal of the entire tree, visiting each node once.\nSpace complexity: O(n), where n is the height of the tree. This is because the function uses a call stack to keep track of the recursive calls, and the maximum size of the call stack is proportional to the height of the tree. In the worst case, when the tree is completely unbalanced and resembles a linked list, the space complexity of the function becomes O(n). However, in a balanced tree, the space complexity is closer to O(log n), where log n is the height of the tree.\n6. Subtree of Another Tree.\npublic boolean isSubtree(TreeNode s, TreeNode t) { if (s == null) { return false; } if (isSameTree(s, t)) { return true; } return isSubtree(s.left, t) || isSubtree(s.right, t); } public boolean isSameTree(TreeNode p, TreeNode q) { if (p == null \u0026amp;\u0026amp; q == null) { return true; } if (p == null || q == null || p.val != q.val) { return false; } return isSameTree(p.left, q.left) \u0026amp;\u0026amp; isSameTree(p.right, q.right); } Time complexity: O(m * n), where m and n are the number of nodes in the trees s and t, respectively. This is because in the worst case, the function performs an isSameTree check for each node in s with t, which takes O(n) time. However, in the average case, the time complexity is closer to O(m), as the function will terminate early once it finds a matching subtree.\nSpace complexity: O(max(m, n)), as the function uses a call stack to keep track of the recursive calls, and the maximum size of the call stack is proportional to the height of the trees. In the worst case, when the trees are completely unbalanced and resemble linked lists, the space complexity becomes O(m) or O(n), whichever is greater.\nOptimized version :\npublic boolean isSubtree(TreeNode s, TreeNode t) { String sPreOrder = getPreOrder(s); String tPreOrder = getPreOrder(t); return sPreOrder.indexOf(tPreOrder) != -1; } private String getPreOrder(TreeNode node) { if (node == null) { return \u0026quot;null\u0026quot;; } String left = getPreOrder(node.left); String right = getPreOrder(node.right); return \u0026quot;#\u0026quot; + node.val + \u0026quot; \u0026quot; + left + \u0026quot; \u0026quot; + right; } sPreOrder: \u0026quot;#3 #4 #1 null null #2 null null #5 null null\u0026quot; tPreOrder: \u0026quot;#4 #1 null null #2 null null\u0026quot; The substring \u0026ldquo;#4 #1 null null #2 null null\u0026rdquo; is found in the string \u0026ldquo;#3 #4 #1 null null #2 null null #5 null null\u0026rdquo;, so we know that t is a subtree of s. Therefore, the function returns true.\nNote that if t were not a subtree of s, then the function would have returned false. The pre-order traversal string of t would not be a substring of the pre-order traversal string of s, so the indexOf method would return -1.\nTime complexity: O(m + n), where m and n are the number of nodes in the trees s and t, respectively. This is because the function only needs to traverse each tree once to get the pre-order traversal string, and the string matching operation takes O(m + n) time in the worst case\nSpace complexity: O(m + n), as it needs to store the pre-order traversal strings of both trees.\n7. Lowest Common Ancestor of a Binary Search Tree.\nclass Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || p == null || q == null) { return null; } if (p.val \u0026lt; root.val \u0026amp;\u0026amp; q.val \u0026lt; root.val) { return lowestCommonAncestor(root.left, p, q); } if (p.val \u0026gt; root.val \u0026amp;\u0026amp; q.val \u0026gt; root.val) { return lowestCommonAncestor(root.right, p, q); } return root; } } Time complexity: O(log N) in the best case and O(N) in the worst case, where N is the number of nodes in the BST. In the best case, when the BST is balanced, the time complexity of the algorithm is O(log N) since we eliminate half of the tree at each level. In the worst case, when the BST is skewed, the time complexity is O(N) since we may have to traverse the entire tree.\nSpace complexity: O(log N) in the best case and O(N) in the worst case. In the best case, when the BST is balanced, the space complexity of the algorithm is O(log N) since we only use a constant amount of space for each level of the recursive call stack. In the worst case, when the BST is skewed, the space complexity is O(N) since we may have to store all N nodes on the call stack.\n8. Binary Tree Level Order Traversal.\nclass Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) { return result; } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); while (!queue.isEmpty()) { int levelSize = queue.size(); List\u0026lt;Integer\u0026gt; levelNodes = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; levelSize; i++) { TreeNode node = queue.poll(); levelNodes.add(node.val); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } result.add(levelNodes); } return result; } } Time complexity: O(N), where N is the number of nodes in the binary tree, since we need to visit each node once.\nSpace complexity: O(N) since we may need to store all N nodes in the queue at once in the worst case.\n9. Binary Tree Right Side View.\nclass Solution { public List\u0026lt;Integer\u0026gt; rightSideView(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) { return result; } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); while (!queue.isEmpty()) { int levelSize = queue.size(); for (int i = 0; i \u0026lt; levelSize; i++) { TreeNode node = queue.poll(); if (i == levelSize - 1) { result.add(node.val); } if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } } return result; } } Time complexity: O(N), where N is the number of nodes in the binary tree, since we need to visit each node once.\nSpace complexity: O(N) since we may need to store all N nodes in the queue at once in the worst case.\n10. Count Good Nodes in Binary Tree.\nclass Solution { public int goodNodes(TreeNode root) { return countGoodNodes(root, Integer.MIN_VALUE); } private int countGoodNodes(TreeNode node, int maxSoFar) { if (node == null) return 0; int count = 0; if (node.val \u0026gt;= maxSoFar) { count++; maxSoFar = node.val; } count += countGoodNodes(node.left, maxSoFar); count += countGoodNodes(node.right, maxSoFar); return count; } } Time complexity: O(n), where n is the number of nodes in the binary tree. This is because we traverse each node once in a depth-first manner.\nSpace complexity:O(h), where h is the height of the binary tree. This space is used for the recursive call stack. In the worst case, where the binary tree is skewed and has a height equivalent to the number of nodes (h ≈ n), the space complexity would be O(n). However, in a balanced binary tree, the space complexity would be O(log n), where log n is the height of the tree.\n11. Validate Binary Search Tree.\nclass Solution { public boolean isValidBST(TreeNode root) { // Use long instead of int to handle edge cases where value equals Integer.MIN_VALUE or Integer.MAX_VALUE return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE); } private boolean isValidBST(TreeNode node, long minVal, long maxVal) { if (node == null) { return true; } if (node.val \u0026lt;= minVal || node.val \u0026gt;= maxVal) { return false; } return isValidBST(node.left, minVal, node.val) \u0026amp;\u0026amp; isValidBST(node.right, node.val, maxVal); } } Time complexity: O(n), where n is the number of nodes in the tree. This is because we visit each node exactly once during the in-order traversal.\nSpace complexity: O(n), where n is the number of nodes in the tree. This is because we need to store the recursive call stack during the traversal, which can be as large as the height of the tree, and in the worst case the height of the tree can be n.\n12. Kth Smallest Element in a BST.\nclass Solution { public int kthSmallest(TreeNode root, int k) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); inorder(root, list); return list.get(k - 1); } private void inorder(TreeNode root, List\u0026lt;Integer\u0026gt; list) { if (root == null) return; inorder(root.left, list); list.add(root.val); inorder(root.right, list); } } Time complexity: O(n), where n is the number of nodes in the tree. This is because we visit each node exactly once during the in-order traversal.\nSpace complexity: O(n),as it uses additional space to store the in-order traversal sequence in the list.\n13. Construct Binary Tree from Preorder and Inorder Traversal.\nclass Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { return buildTreeHelper(preorder, inorder, 0, 0, inorder.length - 1); } private TreeNode buildTreeHelper(int[] preorder, int[] inorder, int preStart, int inStart, int inEnd) { if (preStart \u0026gt; preorder.length - 1 || inStart \u0026gt; inEnd) { return null; } TreeNode root = new TreeNode(preorder[preStart]); int inIndex = 0; for (int i = inStart; i \u0026lt;= inEnd; i++) { if (inorder[i] == root.val) { inIndex = i; } } root.left = buildTreeHelper(preorder, inorder, preStart + 1, inStart, inIndex - 1); root.right = buildTreeHelper(preorder, inorder, preStart + inIndex - inStart + 1, inIndex + 1, inEnd); return root; } } Time complexity: O(n), where n is the number of nodes in the tree.\nSpace complexity: O(n),due to the recursion stack, where n is the height of the binary tree.\n14. Binary Tree Maximum Path Sum.\nclass Solution { int maxSum = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) { calculateMaxSum(root); return maxSum; } private int calculateMaxSum(TreeNode node) { if (node == null) return 0; // Calculate maximum sum in left and right subtrees int leftSum = Math.max(0, calculateMaxSum(node.left)); int rightSum = Math.max(0, calculateMaxSum(node.right)); // Update maxSum by considering the current node's path maxSum = Math.max(maxSum, node.val + leftSum + rightSum); // Return the maximum sum of the path through the current node return node.val + Math.max(leftSum, rightSum); } } Time complexity: O(n), where n is the number of nodes in the tree.\nSpace complexity: O(h), where h is the height of the binary tree, due to the recursion stack.\n15. Serialize and Deserialize Binary Tree.\npublic class Codec { // Encodes a tree to a single string. public String serialize(TreeNode root) { StringBuilder sb = new StringBuilder(); serializeHelper(root, sb); return sb.toString(); } private void serializeHelper(TreeNode node, StringBuilder sb) { if (node == null) { sb.append(\u0026quot;null\u0026quot;).append(\u0026quot;,\u0026quot;); return; } sb.append(node.val).append(\u0026quot;,\u0026quot;); serializeHelper(node.left, sb); serializeHelper(node.right, sb); } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { String[] nodes = data.split(\u0026quot;,\u0026quot;); Queue\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(Arrays.asList(nodes)); return deserializeHelper(queue); } private TreeNode deserializeHelper(Queue\u0026lt;String\u0026gt; queue) { String val = queue.poll(); if (val.equals(\u0026quot;null\u0026quot;)) return null; TreeNode node = new TreeNode(Integer.parseInt(val)); node.left = deserializeHelper(queue); node.right = deserializeHelper(queue); return node; } } Time complexity: We split the serialized string into an array of strings, which takes O(n) time. Then, we construct the binary tree recursively by visiting each node once. Therefore, the time complexity of deserialization is linear with respect to the number of nodes in the tree.\nSpace complexity: The space complexity is O(n) because we use a queue to store the nodes during deserialization, and the size of the queue can be at most O(n) when all nodes are stored in it. Additionally, the recursion stack space used during deserialization is proportional to the height of the tree, which can be at most O(n) for a skewed binary tree.\n","content_html":"\u003cp\u003eIn this article, we will solve trees-related problems that are commonly encountered in interviews.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. \u003ca href=\"https://leetcode.com/problems/invert-binary-tree/\"\u003eInvert Binary Tree\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic TreeNode invertTree(TreeNode root) {\n    if(root == null) {\n        return null;\n    }\n    TreeNode tempNode = root.left;\n    root.left = root.right;\n    root.right = tempNode;\n    invertTree(root.left);\n    invertTree(root.right);\n    return root;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n) The given code performs a depth-first search traversal of the binary tree, and visits each node exactly once. Therefore, the time complexity of the code is O(n), where n is the number of nodes in the binary tree.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(n) The space complexity of the code depends on the maximum depth of the binary tree. In the worst case, if the binary tree is skewed (i.e., all the nodes are in a straight line), the maximum depth of the tree would be n (the number of nodes), and the space complexity of the code would be O(n) due to the recursive function calls. However, in the best case, if the binary tree is balanced, the maximum depth of the tree would be log(n), and the space complexity of the code would be O(log(n)).\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e2. \u003ca href=\"https://leetcode.com/problems/maximum-depth-of-binary-tree/\"\u003eMaximum Depth of Binary Tree\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public int maxDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n\n        return  1 + Math.max(left,right);\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n) where n is the number of nodes in the binary tree, since the code visits each node exactly once.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(h), where h is the height of the binary tree, since the code uses a recursive approach, and the maximum depth of the recursive call stack is equal to the height of the binary tree. In the worst case, where the binary tree is skewed (i.e., all the nodes are in a straight line), the height of the tree would be n (the number of nodes), and the space complexity of the code would be O(n). However, in the best case, where the binary tree is balanced, the height of the tree would be log(n), and the space complexity of the code would be O(log(n)).\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e3. \u003ca href=\"https://leetcode.com/problems/diameter-of-binary-tree/\"\u003eDiameter of Binary Tree\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic int diameterOfBinaryTree(TreeNode root) {\n    int leftDepth  = depth(root.left);\n    int rightDepth = depth(root.right);\n    return Math.max(Math.max(diameterOfBinaryTree(root.left), diameterOfBinaryTree(root.right)), leftDepth + rightDepth);\n}\n\nprivate int depth(TreeNode root){\n    if(root == null){\n        return 0;\n    }\n    \n    int left = depth(root.left);\n    int right = depth(root.right);\n\n    return 1 + Math.max(left, right);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity:  O(n^2^) wwhere n is the number of nodes in the binary tree, since for each node, the code visits all the nodes in its left and right subtrees to compute the diameter.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(h), where h is the height of the binary tree, since the code uses a recursive approach, and the maximum depth of the recursive call stack is equal to the height of the binary tree. In the worst case, where the binary tree is skewed (i.e., all the nodes are in a straight line), the height of the tree would be n (the number of nodes), and the space complexity of the code would be O(n). However, in the best case, where the binary tree is balanced, the height of the tree would be log(n), and the space complexity of the code would be O(log(n)).\u003c/p\u003e\n\u003cp\u003eOptimized Verison : We can optimize by computing the diameter of the binary tree in a single pass, instead of recursively computing the depth of each node multiple times.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic int diameterOfBinaryTree(TreeNode root) {\n    int[] max = {0};\n    depth(root, max);\n    return max[0];\n}\n\nprivate int depth(TreeNode root, int[] max) {\n    if (root == null) {\n        return 0;\n    }\n    \n    int left = depth(root.left, max);\n    int right = depth(root.right, max);\n    \n    max[0] = Math.max(max[0], left + right);\n    \n    return 1 + Math.max(left, right);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity:  O(n) where n is the number of nodes in the binary tree.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(h), where h is the height of the binary tree.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e4. \u003ca href=\"https://leetcode.com/problems/balanced-binary-tree/\"\u003eBalanced Binary Tree\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic boolean isBalanced(TreeNode root) {        \n    if(root == null){\n        return true;\n    }\n    int leftHeight = height(root.left);\n    int rightHeight = height(root.right);\n\n    if(Math.abs(leftHeight - rightHeight) \u0026gt; 1){\n        return false;\n    }\n\n    return isBalanced(root.left) \u0026amp;\u0026amp; isBalanced(root.right); \n}\n\nprivate int height(TreeNode root){\n    if(root == null){\n        return 0;\n    }\n\n    int left = height(root.left);\n    int right = height(root.right);\n\n    return 1 + Math.max(left,right);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity:  O(n log n) in the worst case, where n is the number of nodes in the binary tree. This is because the height of each node is computed recursively using the height method, which has a time complexity of O(n) in the worst case. Since the height method is called for each node in the binary tree, the overall time complexity of isBalanced is O(n log n), because the binary tree has a maximum of log n levels.\u003c/p\u003e\n\u003cp\u003eSpace complexity:  O(n) in the worst case, where n is the number of nodes in the binary tree. This is because the height method is called recursively for each node in the binary tree, and the maximum depth of the recursive call stack is equal to the height of the binary tree, which is O(n) in the worst case. Additionally, the method uses a constant amount of extra space to store the heights of the left and right subtrees of each node. Therefore, the overall space complexity of isBalanced is O(n).\u003c/p\u003e\n\u003cp\u003eOptimized version :\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic boolean isBalanced(TreeNode root) {        \n    return checkBalance(root) != -1;\n}\n\nprivate int checkBalance(TreeNode root) {\n    if (root == null) {\n        return 0;\n    }\n    int left = checkBalance(root.left);\n    if (left == -1) {\n        return -1;\n    }\n    int right = checkBalance(root.right);\n    if (right == -1) {\n        return -1;\n    }\n    if (Math.abs(left - right) \u0026gt; 1) {\n        return -1;\n    }\n    return 1 + Math.max(left, right);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe time complexity of the optimized isBalanced method is O(n), where n is the number of nodes in the binary tree, because each node is visited only once and its height is computed in constant time. The space complexity is O(n) as well, because the maximum depth of the recursive call stack is equal to the height of the binary tree, which is O(n) in the worst case.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e5. \u003ca href=\"https://leetcode.com/problems/same-tree/\"\u003eSame Tree\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null \u0026amp;\u0026amp; q == null) {\n        return true;\n    }\n    if (p == null || q == null || p.val != q.val) {\n        return false;\n    }\n    return isSameTree(p.left, q.left) \u0026amp;\u0026amp; isSameTree(p.right, q.right);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity:  O(n), where n is the total number of nodes in the tree. This is because the function performs a recursive traversal of the entire tree, visiting each node once.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(n), where n is the height of the tree. This is because the function uses a call stack to keep track of the recursive calls, and the maximum size of the call stack is proportional to the height of the tree. In the worst case, when the tree is completely unbalanced and resembles a linked list, the space complexity of the function becomes O(n). However, in a balanced tree, the space complexity is closer to O(log n), where log n is the height of the tree.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e6. \u003ca href=\"https://leetcode.com/problems/subtree-of-another-tree/\"\u003eSubtree of Another Tree\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic boolean isSubtree(TreeNode s, TreeNode t) {\n    if (s == null) {\n        return false;\n    }\n    if (isSameTree(s, t)) {\n        return true;\n    }\n    return isSubtree(s.left, t) || isSubtree(s.right, t);\n}\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null \u0026amp;\u0026amp; q == null) {\n        return true;\n    }\n    if (p == null || q == null || p.val != q.val) {\n        return false;\n    }\n    return isSameTree(p.left, q.left) \u0026amp;\u0026amp; isSameTree(p.right, q.right);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity:  O(m * n), where m and n are the number of nodes in the trees s and t, respectively. This is because in the worst case, the function performs an isSameTree check for each node in s with t, which takes O(n) time. However, in the average case, the time complexity is closer to O(m), as the function will terminate early once it finds a matching subtree.\u003c/p\u003e\n\u003cp\u003eSpace complexity:  O(max(m, n)), as the function uses a call stack to keep track of the recursive calls, and the maximum size of the call stack is proportional to the height of the trees. In the worst case, when the trees are completely unbalanced and resemble linked lists, the space complexity becomes O(m) or O(n), whichever is greater.\u003c/p\u003e\n\u003cp\u003eOptimized version :\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic boolean isSubtree(TreeNode s, TreeNode t) {\n    String sPreOrder = getPreOrder(s);\n    String tPreOrder = getPreOrder(t);\n    return sPreOrder.indexOf(tPreOrder) != -1;\n}\n\nprivate String getPreOrder(TreeNode node) {\n    if (node == null) {\n        return \u0026quot;null\u0026quot;;\n    }\n    String left = getPreOrder(node.left);\n    String right = getPreOrder(node.right);\n    return \u0026quot;#\u0026quot; + node.val + \u0026quot; \u0026quot; + left + \u0026quot; \u0026quot; + right;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003esPreOrder: \u0026quot;#3 #4 #1 null null #2 null null #5 null null\u0026quot;\ntPreOrder: \u0026quot;#4 #1 null null #2 null null\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe substring \u0026ldquo;#4 #1 null null #2 null null\u0026rdquo; is found in the string \u0026ldquo;#3 #4 #1 null null #2 null null #5 null null\u0026rdquo;, so we know that t is a subtree of s. Therefore, the function returns true.\u003c/p\u003e\n\u003cp\u003eNote that if t were not a subtree of s, then the function would have returned false. The pre-order traversal string of t would not be a substring of the pre-order traversal string of s, so the indexOf method would return -1.\u003c/p\u003e\n\u003cp\u003eTime complexity: O(m + n), where m and n are the number of nodes in the trees s and t, respectively. This is because the function only needs to traverse each tree once to get the pre-order traversal string, and the string matching operation takes O(m + n) time in the worst case\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(m + n), as it needs to store the pre-order traversal strings of both trees.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e7. \u003ca href=\"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\"\u003eLowest Common Ancestor of a Binary Search Tree\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || p == null || q == null) {\n            return null;\n        }\n        \n        if (p.val \u0026lt; root.val \u0026amp;\u0026amp; q.val \u0026lt; root.val) {\n            return lowestCommonAncestor(root.left, p, q);\n        }\n        \n        if (p.val \u0026gt; root.val \u0026amp;\u0026amp; q.val \u0026gt; root.val) {\n            return lowestCommonAncestor(root.right, p, q);\n        }\n        \n        return root;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity:  O(log N) in the best case and O(N) in the worst case, where N is the number of nodes in the BST. In the best case, when the BST is balanced, the time complexity of the algorithm is O(log N) since we eliminate half of the tree at each level. In the worst case, when the BST is skewed, the time complexity is O(N) since we may have to traverse the entire tree.\u003c/p\u003e\n\u003cp\u003eSpace complexity:  O(log N) in the best case and O(N) in the worst case. In the best case, when the BST is balanced, the space complexity of the algorithm is O(log N) since we only use a constant amount of space for each level of the recursive call stack. In the worst case, when the BST is skewed, the space complexity is O(N) since we may have to store all N nodes on the call stack.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e8. \u003ca href=\"https://leetcode.com/problems/binary-tree-level-order-traversal/\"\u003eBinary Tree Level Order Traversal\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) {\n        List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\n        if (root == null) {\n            return result;\n        }\n        Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            List\u0026lt;Integer\u0026gt; levelNodes = new ArrayList\u0026lt;\u0026gt;();\n            for (int i = 0; i \u0026lt; levelSize; i++) {\n                TreeNode node = queue.poll();\n                levelNodes.add(node.val);\n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                }\n            }\n            result.add(levelNodes);\n        }\n        return result;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(N), where N is the number of nodes in the binary tree, since we need to visit each node once.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(N) since we may need to store all N nodes in the queue at once in the worst case.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e9. \u003ca href=\"https://leetcode.com/problems/binary-tree-right-side-view/\"\u003eBinary Tree Right Side View\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public List\u0026lt;Integer\u0026gt; rightSideView(TreeNode root) {\n        List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\n        if (root == null) {\n            return result;\n        }\n        Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            for (int i = 0; i \u0026lt; levelSize; i++) {\n                TreeNode node = queue.poll();\n                if (i == levelSize - 1) {\n                    result.add(node.val);\n                }\n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                }\n            }\n        }\n        return result;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(N), where N is the number of nodes in the binary tree, since we need to visit each node once.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(N) since we may need to store all N nodes in the queue at once in the worst case.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e10. \u003ca href=\"https://leetcode.com/problems/count-good-nodes-in-binary-tree/\"\u003eCount Good Nodes in Binary Tree\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public int goodNodes(TreeNode root) {\n        return countGoodNodes(root, Integer.MIN_VALUE);\n    }\n    \n    private int countGoodNodes(TreeNode node, int maxSoFar) {\n        if (node == null) return 0;\n        \n        int count = 0;\n        if (node.val \u0026gt;= maxSoFar) {\n            count++;\n            maxSoFar = node.val;\n        }\n        \n        count += countGoodNodes(node.left, maxSoFar);\n        count += countGoodNodes(node.right, maxSoFar);\n        \n        return count;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity:  O(n), where n is the number of nodes in the binary tree. This is because we traverse each node once in a depth-first manner.\u003c/p\u003e\n\u003cp\u003eSpace complexity:O(h), where h is the height of the binary tree. This space is used for the recursive call stack. In the worst case, where the binary tree is skewed and has a height equivalent to the number of nodes (h ≈ n), the space complexity would be O(n). However, in a balanced binary tree, the space complexity would be O(log n), where log n is the height of the tree.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e11. \u003ca href=\"https://leetcode.com/problems/validate-binary-search-tree/\"\u003eValidate Binary Search Tree\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        // Use long instead of int to handle edge cases where value equals Integer.MIN_VALUE or Integer.MAX_VALUE\n        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n    \n    private boolean isValidBST(TreeNode node, long minVal, long maxVal) {\n        if (node == null) {\n            return true;\n        }\n        if (node.val \u0026lt;= minVal || node.val \u0026gt;= maxVal) {\n            return false;\n        }\n        return isValidBST(node.left, minVal, node.val) \u0026amp;\u0026amp; isValidBST(node.right, node.val, maxVal);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n), where n is the number of nodes in the tree. This is because we visit each node exactly once during the in-order traversal.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(n), where n is the number of nodes in the tree. This is because we need to store the recursive call stack during the traversal, which can be as large as the height of the tree, and in the worst case the height of the tree can be n.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e12. \u003ca href=\"https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/\"\u003eKth Smallest Element in a BST\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;();\n        inorder(root, list);\n        return list.get(k - 1);\n    }\n\n    private void inorder(TreeNode root, List\u0026lt;Integer\u0026gt; list) {\n        if (root == null) return;\n        inorder(root.left, list);\n        list.add(root.val);\n        inorder(root.right, list);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n), where n is the number of nodes in the tree. This is because we visit each node exactly once during the in-order traversal.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(n),as it uses additional space to store the in-order traversal sequence in the list.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e13. \u003ca href=\"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\"\u003eConstruct Binary Tree from Preorder and Inorder Traversal\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        return buildTreeHelper(preorder, inorder, 0, 0, inorder.length - 1);\n    }\n    \n    private TreeNode buildTreeHelper(int[] preorder, int[] inorder, int preStart, int inStart, int inEnd) {\n        if (preStart \u0026gt; preorder.length - 1 || inStart \u0026gt; inEnd) {\n            return null;\n        }\n        \n        TreeNode root = new TreeNode(preorder[preStart]);\n        int inIndex = 0;\n        for (int i = inStart; i \u0026lt;= inEnd; i++) {\n            if (inorder[i] == root.val) {\n                inIndex = i;\n            }\n        }\n        \n        root.left = buildTreeHelper(preorder, inorder, preStart + 1, inStart, inIndex - 1);\n        root.right = buildTreeHelper(preorder, inorder, preStart + inIndex - inStart + 1, inIndex + 1, inEnd);\n        \n        return root;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n), where n is the number of nodes in the tree.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(n),due to the recursion stack, where n is the height of the binary tree.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e14. \u003ca href=\"https://leetcode.com/problems/binary-tree-maximum-path-sum\"\u003eBinary Tree Maximum Path Sum\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    int maxSum = Integer.MIN_VALUE;\n    \n    public int maxPathSum(TreeNode root) {\n        calculateMaxSum(root);\n        return maxSum;\n    }\n    \n    private int calculateMaxSum(TreeNode node) {\n        if (node == null) return 0;\n        \n        // Calculate maximum sum in left and right subtrees\n        int leftSum = Math.max(0, calculateMaxSum(node.left));\n        int rightSum = Math.max(0, calculateMaxSum(node.right));\n        \n        // Update maxSum by considering the current node's path\n        maxSum = Math.max(maxSum, node.val + leftSum + rightSum);\n        \n        // Return the maximum sum of the path through the current node\n        return node.val + Math.max(leftSum, rightSum);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n), where n is the number of nodes in the tree.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(h), where h is the height of the binary tree, due to the recursion stack.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e15. \u003ca href=\"https://leetcode.com/problems/serialize-and-deserialize-binary-tree\"\u003eSerialize and Deserialize Binary Tree\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        serializeHelper(root, sb);\n        return sb.toString();\n    }\n\n    private void serializeHelper(TreeNode node, StringBuilder sb) {\n        if (node == null) {\n            sb.append(\u0026quot;null\u0026quot;).append(\u0026quot;,\u0026quot;);\n            return;\n        }\n        sb.append(node.val).append(\u0026quot;,\u0026quot;);\n        serializeHelper(node.left, sb);\n        serializeHelper(node.right, sb);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String[] nodes = data.split(\u0026quot;,\u0026quot;);\n        Queue\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(Arrays.asList(nodes));\n        return deserializeHelper(queue);\n    }\n\n    private TreeNode deserializeHelper(Queue\u0026lt;String\u0026gt; queue) {\n        String val = queue.poll();\n        if (val.equals(\u0026quot;null\u0026quot;)) return null;\n        TreeNode node = new TreeNode(Integer.parseInt(val));\n        node.left = deserializeHelper(queue);\n        node.right = deserializeHelper(queue);\n        return node;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: We split the serialized string into an array of strings, which takes O(n) time. Then, we construct the binary tree recursively by visiting each node once. Therefore, the time complexity of deserialization is linear with respect to the number of nodes in the tree.\u003c/p\u003e\n\u003cp\u003eSpace complexity: The space complexity is O(n) because we use a queue to store the nodes during deserialization, and the size of the queue can be at most O(n) when all nodes are stored in it. Additionally, the recursion stack space used during deserialization is proportional to the height of the tree, which can be at most O(n) for a skewed binary tree.\u003c/p\u003e\n\u003chr\u003e\n","url":"https://karthikselvam.com/posts/2024/04/21/trees/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"21046-21-09T40:2121:00+00:00","date_modified":"21046-21-09T40:2121:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"308da03c90c69a715170163f4787d019b00be2e0","title":"Binary Search","summary":"2024","content_text":"In this article, we will solve binary search related problems that are commonly encountered in interviews.\n1. Implement a binary search on a sorted array to find the index of a target element.\npublic class BinarySearchExample { public static int binarySearch(int[] array, int target) { int left = 0; int right = array.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (array[mid] == target) { return mid; // Target found } else if (array[mid] \u0026lt; target) { left = mid + 1; // Search right half } else { right = mid - 1; // Search left half } } return -1; // Target not found } public static void main(String[] args) { int[] sortedArray = {1, 3, 5, 7, 9, 11}; int target = 7; int result = binarySearch(sortedArray, target); if (result != -1) { System.out.println(\u0026quot;Target found at index: \u0026quot; + result); } else { System.out.println(\u0026quot;Target not found.\u0026quot;); } } } 2. Modify binary search to return the index of the first occurrence of a target element (handling duplicates).\npublic class BinarySearchFirstOccurrence { public static int binarySearchFirstOccurrence(int[] array, int target) { int left = 0; int right = array.length - 1; int result = -1; // Variable to store the index of the first occurrence while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (array[mid] == target) { result = mid; // Update result to current index right = mid - 1; // Continue searching in the left half } else if (array[mid] \u0026lt; target) { left = mid + 1; // Search right half } else { right = mid - 1; // Search left half } } return result; // Return the index of the first occurrence or -1 if not found } public static void main(String[] args) { int[] sortedArray = {1, 2, 2, 2, 3, 4, 5}; int target = 2; int result = binarySearchFirstOccurrence(sortedArray, target); if (result != -1) { System.out.println(\u0026quot;First occurrence of target found at index: \u0026quot; + result); } else { System.out.println(\u0026quot;Target not found.\u0026quot;); } } } 3. Given a rotated sorted array, search for a target value. Modify the binary search algorithm to account for rotation.\npublic class SearchInRotatedSortedArray { public static int search(int[] nums, int target) { int left = 0; int right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; // Check if mid is the target if (nums[mid] == target) { return mid; } // Determine which side is sorted if (nums[left] \u0026lt;= nums[mid]) { // Left half is sorted if (target \u0026gt;= nums[left] \u0026amp;\u0026amp; target \u0026lt; nums[mid]) { right = mid - 1; // Target is in the left half } else { left = mid + 1; // Target is in the right half } } else { // Right half is sorted if (target \u0026gt; nums[mid] \u0026amp;\u0026amp; target \u0026lt;= nums[right]) { left = mid + 1; // Target is in the right half } else { right = mid - 1; // Target is in the left half } } } return -1; // Target not found } public static void main(String[] args) { int[] nums = {4, 5, 6, 7, 0, 1, 2}; int target = 0; int result = search(nums, target); if (result != -1) { System.out.println(\u0026quot;Target found at index: \u0026quot; + result); } else { System.out.println(\u0026quot;Target not found.\u0026quot;); } } } 4. Search in a rotated sorted array with duplicates.\npublic class SearchInRotatedSortedArrayWithDuplicates { public static int search(int[] nums, int target) { int left = 0; int right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; // Check if mid is the target if (nums[mid] == target) { return mid; // Return the index if target is found } // If duplicates are present, we cannot be sure of the sorted part if (nums[left] == nums[mid] \u0026amp;\u0026amp; nums[mid] == nums[right]) { left++; right--; } else if (nums[left] \u0026lt;= nums[mid]) { // Left half is sorted if (target \u0026gt;= nums[left] \u0026amp;\u0026amp; target \u0026lt; nums[mid]) { right = mid - 1; // Target is in the left half } else { left = mid + 1; // Target is in the right half } } else { // Right half is sorted if (target \u0026gt; nums[mid] \u0026amp;\u0026amp; target \u0026lt;= nums[right]) { left = mid + 1; // Target is in the right half } else { right = mid - 1; // Target is in the left half } } } return -1; // Target not found } public static void main(String[] args) { int[] nums = {2, 5, 6, 0, 0, 1, 2}; int target = 0; int result = search(nums, target); if (result != -1) { System.out.println(\u0026quot;Target found at index: \u0026quot; + result); } else { System.out.println(\u0026quot;Target not found.\u0026quot;); } } } 5. Given a rotated sorted array, find the minimum element.\nBy comparing the middle element (nums[mid]) with the rightmost element (nums[right]), we can determine whether the minimum element is to the right or left of mid. If nums[mid] \u0026gt; nums[right], it means the minimum is in the right half. If nums[mid] \u0026lt;= nums[right], it means the minimum is in the left half or could be mid itself.\npublic class FindMinimumInRotatedSortedArrayWithDuplicates { public static int findMin(int[] nums) { int left = 0; int right = nums.length - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026gt; nums[right]) { // Minimum is in the right part left = mid + 1; } else if (nums[mid] \u0026lt; nums[right]) { // Minimum is in the left part including mid right = mid; } else { // nums[mid] == nums[right], we cannot determine the side, reduce the search space (since duplicates at the end do not help in locating the minimum). right--; } } // When left == right, the minimum element is found return nums[left]; } public static void main(String[] args) { int[] nums = {2, 2, 2, 0, 1}; int minElement = findMin(nums); System.out.println(\u0026quot;The minimum element is: \u0026quot; + minElement); } } 6. Given an array where adjacent elements are not equal, find a peak element (an element that is greater than its neighbors).\nIn a peak-finding problem, we are interested in the region where elements increase and then decrease, creating a peak. If nums[mid] \u0026lt; nums[mid - 1], it suggests that we are on a \u0026ldquo;downhill slope\u0026rdquo; from nums[mid - 1] to nums[mid]. Since we\u0026rsquo;re looking for a peak, and since nums[mid - 1] is greater than nums[mid], we know that a peak must exist either at nums[mid - 1] or further to the left. Therefore, we move our search to the left half by setting right = mid - 1.\npublic class FindPeakElement { public static int findPeakElement(int[] nums) { int left = 0; int right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; // Check if mid is a peak element boolean isPeak = (mid == 0 || nums[mid] \u0026gt; nums[mid - 1]) \u0026amp;\u0026amp; (mid == nums.length - 1 || nums[mid] \u0026gt; nums[mid + 1]); if (isPeak) { return mid; // Return the index of the peak element } else if (mid \u0026gt; 0 \u0026amp;\u0026amp; nums[mid] \u0026lt; nums[mid - 1]) { right = mid - 1; // Peak is in the left half } else { left = mid + 1; // Peak is in the right half } } return -1; // This should never be reached if input constraints are met } public static void main(String[] args) { int[] nums = {1, 3, 20, 4, 1}; int peakIndex = findPeakElement(nums); if (peakIndex != -1) { System.out.println(\u0026quot;Peak element found at index: \u0026quot; + peakIndex + \u0026quot; with value: \u0026quot; + nums[peakIndex]); } else { System.out.println(\u0026quot;No peak element found.\u0026quot;); } } } 7. Given a sorted array of integers, find the starting and ending position of a given target value.\nThe idea is to perform two binary searches: one to find the first occurrence of the target and another to find the last occurrence.\npublic class FindFirstAndLastPosition { public static int[] searchRange(int[] nums, int target) { int[] result = new int[2]; result[0] = findFirstPosition(nums, target); result[1] = findLastPosition(nums, target); return result; } private static int findFirstPosition(int[] nums, int target) { int left = 0, right = nums.length - 1; int firstPosition = -1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { firstPosition = mid; right = mid - 1; // Move left to find the first occurrence } else if (nums[mid] \u0026lt; target) { left = mid + 1; } else { right = mid - 1; } } return firstPosition; } private static int findLastPosition(int[] nums, int target) { int left = 0, right = nums.length - 1; int lastPosition = -1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { lastPosition = mid; left = mid + 1; // Move right to find the last occurrence } else if (nums[mid] \u0026lt; target) { left = mid + 1; } else { right = mid - 1; } } return lastPosition; } public static void main(String[] args) { int[] nums = {5, 7, 7, 8, 8, 10}; int target = 8; int[] positions = searchRange(nums, target); System.out.println(\u0026quot;Starting position: \u0026quot; + positions[0] + \u0026quot;, Ending position: \u0026quot; + positions[1]); } } 8. Implement integer square root calculation using binary search.\nThe idea is to find the largest integer x such that x * x is less than or equal to the given number n. Check if mid * mid is less than or equal to n. Since mid * mid could overflow for large mid values, use mid \u0026lt;= n / mid instead of mid * mid \u0026lt;= n. If mid * mid is less than or equal to n, update result to mid and move to the right half (left = mid + 1) to see if there\u0026rsquo;s a larger mid that also satisfies the condition. If mid * mid is greater than n, move to the left half (right = mid - 1).\npublic class IntegerSquareRoot { public static int sqrt(int n) { if (n \u0026lt; 0) { throw new IllegalArgumentException(\u0026quot;Square root of a negative number is not defined.\u0026quot;); } if (n == 0 || n == 1) { return n; } int left = 1, right = n; int result = 0; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; // Check if mid*mid is equal to n if (mid \u0026lt;= n / mid) { // If mid*mid \u0026lt;= n, move to the right half result = mid; // Update the result to mid as a potential answer left = mid + 1; } else { // If mid*mid \u0026gt; n, move to the left half right = mid - 1; } } return result; } public static void main(String[] args) { int number = 16; int sqrtValue = sqrt(number); System.out.println(\u0026quot;The integer square root of \u0026quot; + number + \u0026quot; is: \u0026quot; + sqrtValue); number = 27; sqrtValue = sqrt(number); System.out.println(\u0026quot;The integer square root of \u0026quot; + number + \u0026quot; is: \u0026quot; + sqrtValue); } } 8. Given a sorted array where every element appears exactly twice except for one element, find that single one using binary search.\nBefore the Single Element: If the mid-point falls before the single element, the array behaves normally: pairs start at even indices. If mid is even and nums[mid] == nums[mid + 1], the single element is to the right, so you move low to mid + 2. At or After the Single Element: Once mid passes the single element, the pattern is broken. Now, if mid is even and nums[mid] != nums[mid + 1], it indicates that the single element is either at mid or to the left, so you move high to mid.\npublic class SingleElementInSortedArray { public static int findSingleElement(int[] nums) { int low = 0; int high = nums.length - 1; while (low \u0026lt; high) { int mid = low + (high - low) / 2; // Ensure mid is even, to check pairs correctly if (mid % 2 == 1) { mid--; } // Check if the pair starts at mid if (nums[mid] == nums[mid + 1]) { // Single element is after mid low = mid + 2; } else { // Single element is before mid high = mid; } } // Low should point to the single element return nums[low]; } public static void main(String[] args) { int[] nums = {1, 1, 2, 2, 3, 4, 4, 5, 5}; int singleElement = findSingleElement(nums); System.out.println(\u0026quot;The single element is: \u0026quot; + singleElement); // Output should be 3 } } 9. Given a 2D matrix, search for a target value using a modified binary search.\nWhen performing binary search on a 1D array, the index mid directly points to an element in that array. However, since the matrix is 2D, we need to access elements using row and column indices.Given a mid index in this flattened array, you need to determine which row and column it corresponds to in the original 2D matrix. The first n elements (where n is the number of columns) fill up the first row. The next n elements fill up the second row, and so on. Given that, by dividing mid by the number of columns (n), you\u0026rsquo;re effectively counting how many complete rows fit into the first mid elements, and the remainder gives you the exact position within that row.\npublic class Search2DMatrix { public boolean searchMatrix(int[][] matrix, int target) { if (matrix == null || matrix.length == 0 || matrix[0].length == 0) { return false; } int rows = matrix.length; int cols = matrix[0].length; int low = 0; int high = rows * cols - 1; while (low \u0026lt;= high) { int mid = low + (high - low) / 2; int midElement = matrix[mid / cols][mid % cols]; if (midElement == target) { return true; } else if (midElement \u0026lt; target) { low = mid + 1; } else { high = mid - 1; } } return false; } public static void main(String[] args) { Search2DMatrix solution = new Search2DMatrix(); int[][] matrix = { {1, 3, 5, 7}, {10, 11, 16, 20}, {23, 30, 34, 60} }; int target = 3; System.out.println(solution.searchMatrix(matrix, target)); // Output: true target = 13; System.out.println(solution.searchMatrix(matrix, target)); // Output: false } } 10. Find the k-th smallest element in a sorted matrix (matrix is row-wise and column-wise sorted).\nUse a min-heap (priority queue) to store the smallest elements. Start by adding the first element of each row into the heap. Extract the smallest element from the heap, and add the next element from the same row to the heap. After performing this k-1 times, the root of the heap will be the k-th smallest element.\nclass Solution { public int kthSmallest(int[][] matrix, int k) { int n = matrix.length; PriorityQueue\u0026lt;int[]\u0026gt; minHeap = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); // Initialize the heap with the first element of each row for (int i = 0; i \u0026lt; Math.min(n, k); i++) { minHeap.offer(new int[]{matrix[i][0], i, 0}); } // Extract the min element from the heap k-1 times for (int i = 0; i \u0026lt; k - 1; i++) { int[] entry = minHeap.poll(); int row = entry[1], col = entry[2]; if (col + 1 \u0026lt; n) { minHeap.offer(new int[]{matrix[row][col + 1], row, col + 1}); } } return minHeap.poll()[0]; } } Binary Search :\nPerform binary search on the range of possible values in the matrix, from the smallest element to the largest element. For each middle value, count how many elements are less than or equal to it by traversing the matrix. If the count is less than k, adjust the search range to the higher half; otherwise, adjust to the lower half. When the search range converges, the value is the k-th smallest.\nclass Solution { public int kthSmallest(int[][] matrix, int k) { int n = matrix.length; int low = matrix[0][0]; int high = matrix[n - 1][n - 1]; while (low \u0026lt; high) { int mid = low + (high - low) / 2; int count = countLessEqual(matrix, mid); if (count \u0026lt; k) { low = mid + 1; } else { high = mid; } } return low; } private int countLessEqual(int[][] matrix, int target) { int n = matrix.length; int count = 0; int row = n - 1; int col = 0; while (row \u0026gt;= 0 \u0026amp;\u0026amp; col \u0026lt; n) { if (matrix[row][col] \u0026lt;= target) { count += (row + 1); col++; } else { row--; } } return count; } } 9. Searching in a Sorted Matrix.\nTop-Right Approach : In this approach, you start from the top-right corner of the matrix at position (row = 0, col = n-1) where n is the number of columns. From this position: If the current element is equal to the target, you\u0026rsquo;ve found the target. If the current element is greater than the target, you move left (decrease col). If the current element is smaller than the target, you move down (increase row).\nmatrix = [ [1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17] ] int row = 0; // Start at the first row int col = matrix[0].length - 1; // Start at the last column while (row \u0026lt; matrix.length \u0026amp;\u0026amp; col \u0026gt;= 0) { if (matrix[row][col] == target) { // Target found return true; } else if (matrix[row][col] \u0026gt; target) { // Current element is greater than target, move left col--; } else { // Current element is smaller than target, move down row++; } } // Target not found return false; Bottom-Left Approach : Starting from the bottom-left corner (n-1, 0): If the target is smaller than the current element, move up (decrease row). If the target is larger than the current element, move right (increase col).\nint row = matrix.length - 1; // Start at the last row int col = 0; // Start at the first column while (row \u0026gt;= 0 \u0026amp;\u0026amp; col \u0026lt; matrix[0].length) { if (matrix[row][col] == target) { // Target found return true; } else if (matrix[row][col] \u0026gt; target) { // Target is smaller, move up row--; } else { // Target is larger, move right col++; } } 11. Find the median of two sorted arrays. This problem requires an efficient solution using binary search..\nEnsure nums1 is the smaller array: Since the binary search will be applied on the smaller array, we ensure nums1 has fewer or equal elements compared to nums2. Binary Search on nums1:Define two pointers, low and high, representing the search range within nums1. Perform binary search by selecting a partition index i for nums1 and a corresponding partition index j for nums2 such that i + j = (m + n + 1) / 2. To find the median, we need to know how many elements should be on the left side of the partition. If the total number of elements is m + n, the left half should contain (m + n) / 2 elements if m + n is even, or (m + n + 1) / 2 elements if m + n is odd (we use (m + n + 1) / 2 to handle both cases with a single expression). We are using binary search on nums1, so we choose a partition index i for nums1. The remaining elements that should be in the left half must then come from nums2, which means we want totalLeft - i elements from nums2. Thus, the partition index j in nums2 should be j = totalLeft - i.\npublic double findMedianSortedArrays(int[] nums1, int[] nums2) { if (nums1.length \u0026gt; nums2.length) { return findMedianSortedArrays(nums2, nums1); } int m = nums1.length; int n = nums2.length; int low = 0, high = m; while (low \u0026lt;= high) { int i = (low + high) / 2; int j = (m + n + 1) / 2 - i; int maxLeft1 = (i == 0) ? Integer.MIN_VALUE : nums1[i - 1]; int minRight1 = (i == m) ? Integer.MAX_VALUE : nums1[i]; int maxLeft2 = (j == 0) ? Integer.MIN_VALUE : nums2[j - 1]; int minRight2 = (j == n) ? Integer.MAX_VALUE : nums2[j]; if (maxLeft1 \u0026lt;= minRight2 \u0026amp;\u0026amp; maxLeft2 \u0026lt;= minRight1) { if ((m + n) % 2 == 0) { return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2.0; } else { return Math.max(maxLeft1, maxLeft2); } } else if (maxLeft1 \u0026gt; minRight2) { high = i - 1; } else { low = i + 1; } } throw new IllegalArgumentException(\u0026quot;Input arrays are not sorted\u0026quot;); } ","content_html":"\u003cp\u003eIn this article, we will solve binary search related problems that are commonly encountered in interviews.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. Implement a binary search on a sorted array to find the index of a target element.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class BinarySearchExample {\n    public static int binarySearch(int[] array, int target) {\n        int left = 0;\n        int right = array.length - 1;\n\n        while (left \u0026lt;= right) {\n            int mid = left + (right - left) / 2;\n\n            if (array[mid] == target) {\n                return mid; // Target found\n            } else if (array[mid] \u0026lt; target) {\n                left = mid + 1; // Search right half\n            } else {\n                right = mid - 1; // Search left half\n            }\n        }\n\n        return -1; // Target not found\n    }\n\n    public static void main(String[] args) {\n        int[] sortedArray = {1, 3, 5, 7, 9, 11};\n        int target = 7;\n\n        int result = binarySearch(sortedArray, target);\n\n        if (result != -1) {\n            System.out.println(\u0026quot;Target found at index: \u0026quot; + result);\n        } else {\n            System.out.println(\u0026quot;Target not found.\u0026quot;);\n        }\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e2. Modify binary search to return the index of the first occurrence of a target element (handling duplicates).\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class BinarySearchFirstOccurrence {\n    public static int binarySearchFirstOccurrence(int[] array, int target) {\n        int left = 0;\n        int right = array.length - 1;\n        int result = -1; // Variable to store the index of the first occurrence\n\n        while (left \u0026lt;= right) {\n            int mid = left + (right - left) / 2;\n\n            if (array[mid] == target) {\n                result = mid; // Update result to current index\n                right = mid - 1; // Continue searching in the left half\n            } else if (array[mid] \u0026lt; target) {\n                left = mid + 1; // Search right half\n            } else {\n                right = mid - 1; // Search left half\n            }\n        }\n\n        return result; // Return the index of the first occurrence or -1 if not found\n    }\n\n    public static void main(String[] args) {\n        int[] sortedArray = {1, 2, 2, 2, 3, 4, 5};\n        int target = 2;\n\n        int result = binarySearchFirstOccurrence(sortedArray, target);\n\n        if (result != -1) {\n            System.out.println(\u0026quot;First occurrence of target found at index: \u0026quot; + result);\n        } else {\n            System.out.println(\u0026quot;Target not found.\u0026quot;);\n        }\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e3. Given a rotated sorted array, search for a target value. Modify the binary search algorithm to account for rotation.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SearchInRotatedSortedArray {\n    public static int search(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n\n        while (left \u0026lt;= right) {\n            int mid = left + (right - left) / 2;\n\n            // Check if mid is the target\n            if (nums[mid] == target) {\n                return mid;\n            }\n\n            // Determine which side is sorted\n            if (nums[left] \u0026lt;= nums[mid]) { // Left half is sorted\n                if (target \u0026gt;= nums[left] \u0026amp;\u0026amp; target \u0026lt; nums[mid]) {\n                    right = mid - 1; // Target is in the left half\n                } else {\n                    left = mid + 1; // Target is in the right half\n                }\n            } else { // Right half is sorted\n                if (target \u0026gt; nums[mid] \u0026amp;\u0026amp; target \u0026lt;= nums[right]) {\n                    left = mid + 1; // Target is in the right half\n                } else {\n                    right = mid - 1; // Target is in the left half\n                }\n            }\n        }\n\n        return -1; // Target not found\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {4, 5, 6, 7, 0, 1, 2};\n        int target = 0;\n\n        int result = search(nums, target);\n\n        if (result != -1) {\n            System.out.println(\u0026quot;Target found at index: \u0026quot; + result);\n        } else {\n            System.out.println(\u0026quot;Target not found.\u0026quot;);\n        }\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e4. Search in a rotated sorted array with duplicates.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SearchInRotatedSortedArrayWithDuplicates {\n    public static int search(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n\n        while (left \u0026lt;= right) {\n            int mid = left + (right - left) / 2;\n\n            // Check if mid is the target\n            if (nums[mid] == target) {\n                return mid; // Return the index if target is found\n            }\n\n            // If duplicates are present, we cannot be sure of the sorted part\n            if (nums[left] == nums[mid] \u0026amp;\u0026amp; nums[mid] == nums[right]) {\n                left++;\n                right--;\n            } else if (nums[left] \u0026lt;= nums[mid]) { // Left half is sorted\n                if (target \u0026gt;= nums[left] \u0026amp;\u0026amp; target \u0026lt; nums[mid]) {\n                    right = mid - 1; // Target is in the left half\n                } else {\n                    left = mid + 1; // Target is in the right half\n                }\n            } else { // Right half is sorted\n                if (target \u0026gt; nums[mid] \u0026amp;\u0026amp; target \u0026lt;= nums[right]) {\n                    left = mid + 1; // Target is in the right half\n                } else {\n                    right = mid - 1; // Target is in the left half\n                }\n            }\n        }\n\n        return -1; // Target not found\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {2, 5, 6, 0, 0, 1, 2};\n        int target = 0;\n\n        int result = search(nums, target);\n\n        if (result != -1) {\n            System.out.println(\u0026quot;Target found at index: \u0026quot; + result);\n        } else {\n            System.out.println(\u0026quot;Target not found.\u0026quot;);\n        }\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e5. Given a rotated sorted array, find the minimum element.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eBy comparing the middle element (nums[mid]) with the rightmost element (nums[right]), we can determine whether the minimum element is to the right or left of mid. If nums[mid] \u0026gt; nums[right], it means the minimum is in the right half. If nums[mid] \u0026lt;= nums[right], it means the minimum is in the left half or could be mid itself.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class FindMinimumInRotatedSortedArrayWithDuplicates {\n    public static int findMin(int[] nums) {\n        int left = 0;\n        int right = nums.length - 1;\n\n        while (left \u0026lt; right) {\n            int mid = left + (right - left) / 2;\n\n            if (nums[mid] \u0026gt; nums[right]) {\n                // Minimum is in the right part\n                left = mid + 1;\n            } else if (nums[mid] \u0026lt; nums[right]) {\n                // Minimum is in the left part including mid\n                right = mid;\n            } else {\n                // nums[mid] == nums[right], we cannot determine the side, reduce the search space (since duplicates at the end do not help in locating the minimum).\n                right--;\n            }\n        }\n\n        // When left == right, the minimum element is found\n        return nums[left];\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {2, 2, 2, 0, 1};\n        int minElement = findMin(nums);\n        System.out.println(\u0026quot;The minimum element is: \u0026quot; + minElement);\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e6. Given an array where adjacent elements are not equal, find a peak element (an element that is greater than its neighbors).\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIn a peak-finding problem, we are interested in the region where elements increase and then decrease, creating a peak. If nums[mid] \u0026lt; nums[mid - 1], it suggests that we are on a \u0026ldquo;downhill slope\u0026rdquo; from nums[mid - 1] to nums[mid]. Since we\u0026rsquo;re looking for a peak, and since nums[mid - 1] is greater than nums[mid], we know that a peak must exist either at nums[mid - 1] or further to the left. Therefore, we move our search to the left half by setting right = mid - 1.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class FindPeakElement {\n    public static int findPeakElement(int[] nums) {\n        int left = 0;\n        int right = nums.length - 1;\n\n        while (left \u0026lt;= right) {\n            int mid = left + (right - left) / 2;\n\n            // Check if mid is a peak element\n            boolean isPeak = (mid == 0 || nums[mid] \u0026gt; nums[mid - 1]) \u0026amp;\u0026amp;\n                             (mid == nums.length - 1 || nums[mid] \u0026gt; nums[mid + 1]);\n\n            if (isPeak) {\n                return mid; // Return the index of the peak element\n            } else if (mid \u0026gt; 0 \u0026amp;\u0026amp; nums[mid] \u0026lt; nums[mid - 1]) {\n                right = mid - 1; // Peak is in the left half\n            } else {\n                left = mid + 1; // Peak is in the right half\n            }\n        }\n\n        return -1; // This should never be reached if input constraints are met\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 20, 4, 1};\n        int peakIndex = findPeakElement(nums);\n        if (peakIndex != -1) {\n            System.out.println(\u0026quot;Peak element found at index: \u0026quot; + peakIndex + \u0026quot; with value: \u0026quot; + nums[peakIndex]);\n        } else {\n            System.out.println(\u0026quot;No peak element found.\u0026quot;);\n        }\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e7. Given a sorted array of integers, find the starting and ending position of a given target value.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThe idea is to perform two binary searches: one to find the first occurrence of the target and another to find the last occurrence.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class FindFirstAndLastPosition {\n    public static int[] searchRange(int[] nums, int target) {\n        int[] result = new int[2];\n        result[0] = findFirstPosition(nums, target);\n        result[1] = findLastPosition(nums, target);\n        return result;\n    }\n\n    private static int findFirstPosition(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        int firstPosition = -1;\n\n        while (left \u0026lt;= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                firstPosition = mid;\n                right = mid - 1;  // Move left to find the first occurrence\n            } else if (nums[mid] \u0026lt; target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return firstPosition;\n    }\n\n    private static int findLastPosition(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        int lastPosition = -1;\n\n        while (left \u0026lt;= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                lastPosition = mid;\n                left = mid + 1;  // Move right to find the last occurrence\n            } else if (nums[mid] \u0026lt; target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return lastPosition;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {5, 7, 7, 8, 8, 10};\n        int target = 8;\n        int[] positions = searchRange(nums, target);\n        System.out.println(\u0026quot;Starting position: \u0026quot; + positions[0] + \u0026quot;, Ending position: \u0026quot; + positions[1]);\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e8. Implement integer square root calculation using binary search.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThe idea is to find the largest integer x such that x * x is less than or equal to the given number n. Check if mid * mid is less than or equal to n. Since mid * mid could overflow for large mid values, use mid \u0026lt;= n / mid instead of mid * mid \u0026lt;= n. If mid * mid is less than or equal to n, update result to mid and move to the right half (left = mid + 1) to see if there\u0026rsquo;s a larger mid that also satisfies the condition. If mid * mid is greater than n, move to the left half (right = mid - 1).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class IntegerSquareRoot {\n    public static int sqrt(int n) {\n        if (n \u0026lt; 0) {\n            throw new IllegalArgumentException(\u0026quot;Square root of a negative number is not defined.\u0026quot;);\n        }\n        if (n == 0 || n == 1) {\n            return n;\n        }\n\n        int left = 1, right = n;\n        int result = 0;\n\n        while (left \u0026lt;= right) {\n            int mid = left + (right - left) / 2;\n            // Check if mid*mid is equal to n\n            if (mid \u0026lt;= n / mid) {\n                // If mid*mid \u0026lt;= n, move to the right half\n                result = mid;  // Update the result to mid as a potential answer\n                left = mid + 1;\n            } else {\n                // If mid*mid \u0026gt; n, move to the left half\n                right = mid - 1;\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int number = 16;\n        int sqrtValue = sqrt(number);\n        System.out.println(\u0026quot;The integer square root of \u0026quot; + number + \u0026quot; is: \u0026quot; + sqrtValue);\n\n        number = 27;\n        sqrtValue = sqrt(number);\n        System.out.println(\u0026quot;The integer square root of \u0026quot; + number + \u0026quot; is: \u0026quot; + sqrtValue);\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e8. Given a sorted array where every element appears exactly twice except for one element, find that single one using binary search.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eBefore the Single Element: If the mid-point falls before the single element, the array behaves normally: pairs start at even indices. If mid is even and nums[mid] == nums[mid + 1], the single element is to the right, so you move low to mid + 2. At or After the Single Element: Once mid passes the single element, the pattern is broken. Now, if mid is even and nums[mid] != nums[mid + 1], it indicates that the single element is either at mid or to the left, so you move high to mid.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SingleElementInSortedArray {\n    public static int findSingleElement(int[] nums) {\n        int low = 0;\n        int high = nums.length - 1;\n\n        while (low \u0026lt; high) {\n            int mid = low + (high - low) / 2;\n\n            // Ensure mid is even, to check pairs correctly\n            if (mid % 2 == 1) {\n                mid--;\n            }\n\n            // Check if the pair starts at mid\n            if (nums[mid] == nums[mid + 1]) {\n                // Single element is after mid\n                low = mid + 2;\n            } else {\n                // Single element is before mid\n                high = mid;\n            }\n        }\n\n        // Low should point to the single element\n        return nums[low];\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {1, 1, 2, 2, 3, 4, 4, 5, 5};\n        int singleElement = findSingleElement(nums);\n        System.out.println(\u0026quot;The single element is: \u0026quot; + singleElement); // Output should be 3\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e9. Given a 2D matrix, search for a target value using a modified binary search.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eWhen performing binary search on a 1D array, the index mid directly points to an element in that array. However, since the matrix is 2D, we need to access elements using row and column indices.Given a mid index in this flattened array, you need to determine which row and column it corresponds to in the original 2D matrix. The first n elements (where n is the number of columns) fill up the first row. The next n elements fill up the second row, and so on. Given that, by dividing mid by the number of columns (n), you\u0026rsquo;re effectively counting how many complete rows fit into the first mid elements, and the remainder gives you the exact position within that row.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Search2DMatrix {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return false;\n        }\n\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        int low = 0;\n        int high = rows * cols - 1;\n\n        while (low \u0026lt;= high) {\n            int mid = low + (high - low) / 2;\n            int midElement = matrix[mid / cols][mid % cols];\n\n            if (midElement == target) {\n                return true;\n            } else if (midElement \u0026lt; target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Search2DMatrix solution = new Search2DMatrix();\n        int[][] matrix = {\n            {1, 3, 5, 7},\n            {10, 11, 16, 20},\n            {23, 30, 34, 60}\n        };\n        int target = 3;\n        System.out.println(solution.searchMatrix(matrix, target)); // Output: true\n\n        target = 13;\n        System.out.println(solution.searchMatrix(matrix, target)); // Output: false\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e10. Find the k-th smallest element in a sorted matrix (matrix is row-wise and column-wise sorted).\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eUse a min-heap (priority queue) to store the smallest elements. Start by adding the first element of each row into the heap. Extract the smallest element from the heap, and add the next element from the same row to the heap. After performing this k-1 times, the root of the heap will be the k-th smallest element.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public int kthSmallest(int[][] matrix, int k) {\n        int n = matrix.length;\n        PriorityQueue\u0026lt;int[]\u0026gt; minHeap = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]);\n\n        // Initialize the heap with the first element of each row\n        for (int i = 0; i \u0026lt; Math.min(n, k); i++) {\n            minHeap.offer(new int[]{matrix[i][0], i, 0});\n        }\n\n        // Extract the min element from the heap k-1 times\n        for (int i = 0; i \u0026lt; k - 1; i++) {\n            int[] entry = minHeap.poll();\n            int row = entry[1], col = entry[2];\n            if (col + 1 \u0026lt; n) {\n                minHeap.offer(new int[]{matrix[row][col + 1], row, col + 1});\n            }\n        }\n\n        return minHeap.poll()[0];\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBinary Search :\u003c/p\u003e\n\u003cp\u003ePerform binary search on the range of possible values in the matrix, from the smallest element to the largest element. For each middle value, count how many elements are less than or equal to it by traversing the matrix. If the count is less than k, adjust the search range to the higher half; otherwise, adjust to the lower half. When the search range converges, the value is the k-th smallest.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public int kthSmallest(int[][] matrix, int k) {\n        int n = matrix.length;\n        int low = matrix[0][0];\n        int high = matrix[n - 1][n - 1];\n\n        while (low \u0026lt; high) {\n            int mid = low + (high - low) / 2;\n            int count = countLessEqual(matrix, mid);\n\n            if (count \u0026lt; k) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    private int countLessEqual(int[][] matrix, int target) {\n        int n = matrix.length;\n        int count = 0;\n        int row = n - 1;\n        int col = 0;\n\n        while (row \u0026gt;= 0 \u0026amp;\u0026amp; col \u0026lt; n) {\n            if (matrix[row][col] \u0026lt;= target) {\n                count += (row + 1);\n                col++;\n            } else {\n                row--;\n            }\n        }\n\n        return count;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e9. Searching in a Sorted Matrix.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eTop-Right Approach : In this approach, you start from the top-right corner of the matrix at position (row = 0, col = n-1) where n is the number of columns. From this position: If the current element is equal to the target, you\u0026rsquo;ve found the target. If the current element is greater than the target, you move left (decrease col). If the current element is smaller than the target, you move down (increase row).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ematrix = [\n  [1, 4, 7, 11],\n  [2, 5, 8, 12],\n  [3, 6, 9, 16],\n  [10, 13, 14, 17]\n]\nint row = 0; // Start at the first row\nint col = matrix[0].length - 1; // Start at the last column\n\nwhile (row \u0026lt; matrix.length \u0026amp;\u0026amp; col \u0026gt;= 0) {\n    if (matrix[row][col] == target) {\n        // Target found\n        return true;\n    } else if (matrix[row][col] \u0026gt; target) {\n        // Current element is greater than target, move left\n        col--;\n    } else {\n        // Current element is smaller than target, move down\n        row++;\n    }\n}\n\n// Target not found\nreturn false;\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBottom-Left Approach : Starting from the bottom-left corner (n-1, 0): If the target is smaller than the current element, move up (decrease row). If the target is larger than the current element, move right (increase col).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eint row = matrix.length - 1; // Start at the last row\nint col = 0; // Start at the first column\n\nwhile (row \u0026gt;= 0 \u0026amp;\u0026amp; col \u0026lt; matrix[0].length) {\n    if (matrix[row][col] == target) {\n        // Target found\n        return true;\n    } else if (matrix[row][col] \u0026gt; target) {\n        // Target is smaller, move up\n        row--;\n    } else {\n        // Target is larger, move right\n        col++;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e11. Find the median of two sorted arrays. This problem requires an efficient solution using binary search..\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eEnsure nums1 is the smaller array: Since the binary search will be applied on the smaller array, we ensure nums1 has fewer or equal elements compared to nums2. Binary Search on nums1:Define two pointers, low and high, representing the search range within nums1. Perform binary search by selecting a partition index i for nums1 and a corresponding partition index j for nums2 such that i + j = (m + n + 1) / 2. To find the median, we need to know how many elements should be on the left side of the partition. If the total number of elements is m + n, the left half should contain (m + n) / 2 elements if m + n is even, or (m + n + 1) / 2 elements if m + n is odd (we use (m + n + 1) / 2 to handle both cases with a single expression). We are using binary search on nums1, so we choose a partition index i for nums1. The remaining elements that should be in the left half must then come from nums2, which means we want totalLeft - i elements from nums2. Thus, the partition index j in nums2 should be j = totalLeft - i.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic double findMedianSortedArrays(int[] nums1, int[] nums2) {\n    if (nums1.length \u0026gt; nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n\n    int m = nums1.length;\n    int n = nums2.length;\n    int low = 0, high = m;\n\n    while (low \u0026lt;= high) {\n        int i = (low + high) / 2;\n        int j = (m + n + 1) / 2 - i;\n\n        int maxLeft1 = (i == 0) ? Integer.MIN_VALUE : nums1[i - 1];\n        int minRight1 = (i == m) ? Integer.MAX_VALUE : nums1[i];\n\n        int maxLeft2 = (j == 0) ? Integer.MIN_VALUE : nums2[j - 1];\n        int minRight2 = (j == n) ? Integer.MAX_VALUE : nums2[j];\n\n        if (maxLeft1 \u0026lt;= minRight2 \u0026amp;\u0026amp; maxLeft2 \u0026lt;= minRight1) {\n            if ((m + n) % 2 == 0) {\n                return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2.0;\n            } else {\n                return Math.max(maxLeft1, maxLeft2);\n            }\n        } else if (maxLeft1 \u0026gt; minRight2) {\n            high = i - 1;\n        } else {\n            low = i + 1;\n        }\n    }\n\n    throw new IllegalArgumentException(\u0026quot;Input arrays are not sorted\u0026quot;);\n}\n\u003c/code\u003e\u003c/pre\u003e\n","url":"https://karthikselvam.com/posts/2023/08/08/binary_search/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"8086-08-09T80:88:00+00:00","date_modified":"8086-08-09T80:88:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"0740a2571d74078baae3edf5199e317697e59600","title":"System Design Concepts","summary":"2023","content_text":"1. How to transfer data at large scale ?\nNon blocking I/O Buffering and Batching Network Protocols Message Formats Load Balancing Partitioning Consistent Hashing 2. How to aggregate data efficiently ?\nPush vs Pull Deduplication Checkpointing Data enrichment Embeded database State management Fallback 3. How to store data reliably ?\nReverse Proxy Coordination service Health checking Peer and service discovery Replication Quorum Availability zone 4. How to retrieve data quickly ?\nAggregate on write Eventual consistency Denormalization Data rollup Hot and cold storage Polyglot persistence Distributed cache 4. How to define system requirements ? Functional requirement - Define the qualities of the system. What a system is supposed to do ? Example The system must allow application to exchange messages. Non Function requirement - Define the qualites of a system how a system is supposed to be. Example scalable, highly available and fast.\nHow to go about defining functional requirement ? Start with the customer and work backward. We need to identify who is going to use the system and how ? For well know systems like youtube, twitter, facebook etc its easy. But for systems such has rate limiting, content delivery network, it can be quite challenging. In such systems its better to start with customer/clients/users and work backwards on how they use the system. For example, In youtube the customers are content creators and viewers and how they are going to use the system ? content creators will upload videos, create posts where as viewers search for videos, watch videos, and comment. Similarly in the case of content delivery network the customer are webservices and the system will trottle there request.\nNon functional requirements - High availability Availability - Defines the system uptime, the percentage of time the system has been working and available. Example, 99% availbility, The system was unavialable about 3.65 days a years.\nSuccess ration of request - 1 request out of 100 fails.\nWhat is a highly aviable system ? Its not about a number. Its is about architecture and process.\nDesign principles behind high avilability\nBuild redundancy to eleminate single points of failure. Example : regions, availability zones, fallback, data replication, high availability pair.\nSwitch from one server to another without losing data. Example: DNS,load balancing, reverse proxy,API gateway, peer discovery, service discovery.\nProtect the system from atypical client behavior. Example : load shedding, rate limiting, shuffle sharding, cell- based architecture.\nProtect the system from failures and perfomance degradation of its dependencies Example: timeouts, circuit breaker, bulkhead, retries, idempotency.\nDetect failure as they occure. Example : monitoring\nProcess behind high availability:\nChange management - All code and configration changes are reviewed and approved. QA - regaularly execercise tests to validate that newly introduced changes meet functional and non-functional requirements. Deployment - Deploy changes to a production environment frequently, quickly, safely, automated rollback. Capacity planning : Monitor system utilization and add resources to meet growing demand. Disaster recovery : Recover system quickly in the event of a diaster, regularly test failover to diaster recovery. Root cause analysis : Establish the root cause of the failure and identify preventive measures Operational readiness review : Evaluate system\u0026rsquo;s operational state and identify gaps in operations. Define actions to remediate risks. Game day : simulate a failure or event and test system and team responses. Team culture : Good team culture promotes process discipline. Nonfunctional requirements - Fault tolerance\nFault tolerance - is the property that enables a system to continue operating properly in the even of one or more faults within some of its components. Fault tolerance vs High availability - fault tolerant system has the goal of zero downtime. Where as high availability system the down time is possible and the system trie to minimize it. Fault tolerance can be achieved by using same design principles and processes as of high availability and requires more redundancy. Nonfunctional requirements - Resilience\nReilience - Systems that in the face of faults can provide and maitain an acceptable level of service are called resilient systems. To ensure resiliency we need faults to happen in the system periodically to test resilience also called chaos engineering. Example - Killing instances of a server. ","content_html":"\u003cp\u003e\u003cstrong\u003e1. How to transfer data at large scale ?\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eNon blocking I/O\u003c/li\u003e\n\u003cli\u003eBuffering and Batching\u003c/li\u003e\n\u003cli\u003eNetwork Protocols\u003c/li\u003e\n\u003cli\u003eMessage Formats\u003c/li\u003e\n\u003cli\u003eLoad Balancing\u003c/li\u003e\n\u003cli\u003ePartitioning\u003c/li\u003e\n\u003cli\u003eConsistent Hashing\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e2. How to aggregate data efficiently ?\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ePush vs Pull\u003c/li\u003e\n\u003cli\u003eDeduplication\u003c/li\u003e\n\u003cli\u003eCheckpointing\u003c/li\u003e\n\u003cli\u003eData enrichment\u003c/li\u003e\n\u003cli\u003eEmbeded database\u003c/li\u003e\n\u003cli\u003eState management\u003c/li\u003e\n\u003cli\u003eFallback\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e3. How to store data reliably ?\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eReverse Proxy\u003c/li\u003e\n\u003cli\u003eCoordination service\u003c/li\u003e\n\u003cli\u003eHealth checking\u003c/li\u003e\n\u003cli\u003ePeer and service discovery\u003c/li\u003e\n\u003cli\u003eReplication\u003c/li\u003e\n\u003cli\u003eQuorum\u003c/li\u003e\n\u003cli\u003eAvailability zone\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e4. How to retrieve data quickly ?\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eAggregate on write\u003c/li\u003e\n\u003cli\u003eEventual consistency\u003c/li\u003e\n\u003cli\u003eDenormalization\u003c/li\u003e\n\u003cli\u003eData rollup\u003c/li\u003e\n\u003cli\u003eHot and cold storage\u003c/li\u003e\n\u003cli\u003ePolyglot persistence\u003c/li\u003e\n\u003cli\u003eDistributed cache\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e4. How to define system requirements ?\u003c/strong\u003e\nFunctional requirement - Define the qualities of the system. What a system is supposed to do ? Example The system must allow application to exchange messages.\nNon Function requirement - Define the qualites of a system how a system is supposed to be. Example scalable, highly available and fast.\u003c/p\u003e\n\u003cp\u003eHow to go about defining functional requirement ?\nStart with the customer and work backward.\nWe need to identify who is going to use the system and how ?\nFor well know systems like youtube, twitter, facebook etc its easy. But for systems such has rate limiting, content delivery network, it can be quite challenging. In such systems its better to start with customer/clients/users and work backwards on how they use the system. For example, In youtube the customers are content creators and viewers and how they are going to use the system ? content creators will upload videos, create posts where as viewers search for videos, watch videos, and comment. Similarly in the case of content delivery network the customer are webservices and the system will trottle there request.\u003c/p\u003e\n\u003cp\u003eNon functional requirements - High availability\nAvailability - Defines the system uptime, the percentage of time the system has been working and available. Example, 99% availbility, The system was unavialable about 3.65 days a years.\u003c/p\u003e\n\u003cp\u003eSuccess ration of request - 1 request out of 100 fails.\u003c/p\u003e\n\u003cp\u003eWhat is a highly aviable system ?\nIts not about a number. Its is about architecture and process.\u003c/p\u003e\n\u003cp\u003eDesign principles behind high avilability\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eBuild redundancy to eleminate single points of failure. Example : regions, availability zones, fallback, data replication, high availability pair.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSwitch from one server to another without losing data. Example: DNS,load balancing, reverse proxy,API gateway, peer discovery, service discovery.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eProtect the system from atypical client behavior. Example : load shedding, rate limiting, shuffle sharding, cell- based architecture.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eProtect the system from failures and perfomance degradation of its dependencies Example: timeouts, circuit breaker, bulkhead, retries, idempotency.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDetect failure as they occure. Example : monitoring\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eProcess behind high availability:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eChange management - All code and configration changes are reviewed and approved.\u003c/li\u003e\n\u003cli\u003eQA - regaularly execercise tests to validate that newly introduced changes meet functional and non-functional requirements.\u003c/li\u003e\n\u003cli\u003eDeployment - Deploy changes to a production environment frequently, quickly, safely, automated rollback.\u003c/li\u003e\n\u003cli\u003eCapacity planning : Monitor system utilization and add resources to meet growing demand.\u003c/li\u003e\n\u003cli\u003eDisaster recovery : Recover system quickly in the event of a diaster, regularly test failover to diaster recovery.\u003c/li\u003e\n\u003cli\u003eRoot cause analysis : Establish the root cause of the failure and identify preventive measures\u003c/li\u003e\n\u003cli\u003eOperational readiness review : Evaluate system\u0026rsquo;s operational state and identify gaps in operations. Define actions to remediate risks.\u003c/li\u003e\n\u003cli\u003eGame day : simulate a failure or event and test system and team responses.\u003c/li\u003e\n\u003cli\u003eTeam culture : Good team culture promotes process discipline.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eNonfunctional requirements - Fault tolerance\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eFault tolerance - is the property that enables a system to continue operating properly in the even of one or more faults within some of its components.\u003c/li\u003e\n\u003cli\u003eFault tolerance vs High availability - fault tolerant system has the goal of zero downtime. Where as high availability system the down time is possible and the system trie to minimize it. Fault tolerance can be achieved by using same design principles and processes as of high availability and requires more redundancy.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eNonfunctional requirements - Resilience\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eReilience - Systems that in the face of faults can provide and maitain an acceptable level of service are called resilient systems.\u003c/li\u003e\n\u003cli\u003eTo ensure resiliency we need faults to happen in the system periodically to test resilience also called chaos engineering. Example - Killing instances of a server.\u003c/li\u003e\n\u003c/ol\u003e\n","url":"https://karthikselvam.com/posts/2023/08/05/system_design_meta/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"5086-05-09T80:55:00+00:00","date_modified":"5086-05-09T80:55:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"65ba785fbe8917577df7f706db9e1367f6218e31","title":"Creational Design Patterns","summary":"2023","content_text":"Creational design patterns solve common problems that arise during the creation of objects. Following are some of the commonly used creational design patterns.\n1. Builder pattern : The Builder pattern is a creational design pattern that separates the construction of complex objects from their representation, allowing the same construction process to create different representations. This pattern is especially useful when creating objects that require many steps to initialize, and whose initialization steps are optional or may vary.\npublic class Car { private String make; private String model; private int year; private String color; private String engine; // Private constructor to enforce object creation through builder private Car(Builder builder) { this.make = builder.make; this.model = builder.model; this.year = builder.year; this.color = builder.color; this.engine = builder.engine; } public static class Builder { private String make; private String model; private int year; private String color; private String engine; public Builder make(String make) { this.make = make; return this; } public Builder model(String model) { this.model = model; return this; } public Builder year(int year) { this.year = year; return this; } public Builder color(String color) { this.color = color; return this; } public Builder engine(String engine) { this.engine = engine; return this; } public Car build() { return new Car(this); } } } In this example, the Car class has a private constructor to enforce object creation through the Builder. The Builder class has methods to set the different fields of the Car class, and a build() method to create the Car object.\nHere\u0026rsquo;s an example of how to use the Builder to create a Car object:\nCar car = new Car.Builder() .make(\u0026quot;Toyota\u0026quot;) .model(\u0026quot;Camry\u0026quot;) .year(2022) .color(\u0026quot;Silver\u0026quot;) .engine(\u0026quot;V6\u0026quot;) .build(); 2. Factory pattern : The Factory pattern is a creational design pattern that provides a way to create objects without specifying the exact class of object that will be created. Instead, a factory class is used to create objects based on certain conditions or parameters.\npublic interface Car { public void drive(); } public class Sedan implements Car { @Override public void drive() { System.out.println(\u0026quot;Driving a Sedan\u0026quot;); } } public class SUV implements Car { @Override public void drive() { System.out.println(\u0026quot;Driving an SUV\u0026quot;); } } public class CarFactory { public static Car createCar(String carType) { if(carType.equalsIgnoreCase(\u0026quot;Sedan\u0026quot;)) { return new Sedan(); } else if(carType.equalsIgnoreCase(\u0026quot;SUV\u0026quot;)) { return new SUV(); } else { throw new IllegalArgumentException(\u0026quot;Invalid car type: \u0026quot; + carType); } } } In this example, we have an interface called Car with a method called drive(), and two classes that implement the Car interface: Sedan and SUV. We also have a CarFactory class with a createCar() method that takes a carType parameter and creates a Car object based on the specified car type.\nHere\u0026rsquo;s an example of how to use the CarFactory to create a Car object:\nCar sedan = CarFactory.createCar(\u0026quot;Sedan\u0026quot;); sedan.drive(); // Output: \u0026quot;Driving a Sedan\u0026quot; Car suv = CarFactory.createCar(\u0026quot;SUV\u0026quot;); suv.drive(); // Output: \u0026quot;Driving an SUV\u0026quot; In this example, we create a Sedan and SUV object using the CarFactory.createCar() method, and then call the drive() method on each object to drive the car. The CarFactory class takes care of creating the correct type of Car object based on the input carType.\nAdvantages of using static method in factory method:\nIt makes the method easily accessible: Since the method is static, it can be accessed directly from the class name, without the need to create an instance of the class.\nIt simplifies the code: Since the method is static, it doesn\u0026rsquo;t require an instance of the class to be created, which can simplify the code.\nIt is thread-safe: Static methods are thread-safe by default, which means that multiple threads can call the method simultaneously without causing any issues.\n3. Abstract Factory pattern : The Abstract Factory Pattern is a creational design pattern that provides an interface for creating families of related or dependent objects without specifying their concrete classes. It is useful when you need to create a set of related objects that work together and have the same interface, but the concrete implementation of those objects may vary depending on some condition.\nHere\u0026rsquo;s an example implementation of the Abstract Factory Pattern in Java:\npublic interface Car { public void drive(); } public interface CarFactory { public Car createCar(); } public class Sedan implements Car { @Override public void drive() { System.out.println(\u0026quot;Driving a Sedan\u0026quot;); } } public class SUV implements Car { @Override public void drive() { System.out.println(\u0026quot;Driving an SUV\u0026quot;); } } public class SedanFactory implements CarFactory { @Override public Car createCar() { return new Sedan(); } } public class SUVFactory implements CarFactory { @Override public Car createCar() { return new SUV(); } } In this example, we have an interface called Car with a method called drive(), and an interface called CarFactory with a method called createCar(). We also have two classes that implement the Car interface: Sedan and SUV. Additionally, we have two classes that implement the CarFactory interface: SedanFactory and SUVFactory.\nThe SedanFactory and SUVFactory classes are responsible for creating Sedan and SUV objects, respectively. They implement the createCar() method to return a Car object of the corresponding type.\nHere\u0026rsquo;s an example of how to use the Abstract Factory Pattern to create a set of related objects:\nCarFactory sedanFactory = new SedanFactory(); Car sedan = sedanFactory.createCar(); sedan.drive(); // Output: \u0026quot;Driving a Sedan\u0026quot; CarFactory suvFactory = new SUVFactory(); Car suv = suvFactory.createCar(); suv.drive(); // Output: \u0026quot;Driving an SUV\u0026quot; In this example, we create two instances of CarFactory - SedanFactory and SUVFactory. We then use these factories to create Car objects of the corresponding type - Sedan and SUV. Finally, we call the drive() method on each object to drive the car.\nThe Abstract Factory Pattern makes it easy to create a set of related objects that work together and have the same interface, without specifying their concrete classes. This provides a lot of flexibility and makes it easier to modify the object creation process without affecting the rest of the code.\n4. Difference between factory and abstract factory The main difference between the Factory Pattern and the Abstract Factory Pattern is that the Factory Pattern creates individual objects, whereas the Abstract Factory Pattern creates families of related objects.\nThe Factory Pattern is used to create a single object of a specific type. It provides a single interface that can be used to create an object of a specific class, based on some condition. This pattern is useful when you need to create an object of a specific type and want to decouple the object creation process from the rest of the code.\nOn the other hand, the Abstract Factory Pattern is used to create a family of related objects. It provides an interface for creating families of related or dependent objects, without specifying their concrete classes. This pattern is useful when you need to create a set of related objects that work together and have the same interface, but the concrete implementation of those objects may vary depending on some condition.\nIn general, you would use the Factory Pattern when you need to create a single object of a specific type, and the Abstract Factory Pattern when you need to create a family of related objects that work together.\nFor example, let\u0026rsquo;s say you are building a car dealership application. You might use the Factory Pattern to create instances of individual car models, such as a Sedan or an SUV. However, you would use the Abstract Factory Pattern to create families of related objects, such as a family of Sedans that have the same engine type and features.\nIn summary, the Factory Pattern and the Abstract Factory Pattern are both useful creational design patterns, but they serve different purposes. The Factory Pattern is used to create individual objects of a specific type, whereas the Abstract Factory Pattern is used to create families of related objects that work together.\n5. Singleton pattern :The Singleton pattern is a creational design pattern that ensures that a class has only one instance and provides a global point of access to it. This pattern is useful when we need to ensure that only one instance of a class is created and shared across the application.\nHere\u0026rsquo;s an example implementation of the Singleton pattern in Java using the car concept:\npublic class CarSingleton { // Private static instance of the singleton class private static CarSingleton instance; // Private constructor to prevent direct instantiation of the class private CarSingleton() { } // Public static method to get the singleton instance public static CarSingleton getInstance() { if (instance == null) { instance = new CarSingleton(); } return instance; } public void drive() { System.out.println(\u0026quot;Driving the car...\u0026quot;); } } // Client class public class CarClient { public static void main(String[] args) { CarSingleton car1 = CarSingleton.getInstance(); CarSingleton car2 = CarSingleton.getInstance(); // Both car1 and car2 will reference the same instance System.out.println(car1 == car2); car1.drive(); car2.drive(); } } In this example, we have a CarSingleton class that implements the Singleton pattern. The class has a private static instance of itself and a private constructor to prevent direct instantiation of the class. The public static method getInstance() returns the singleton instance, creating it if it doesn\u0026rsquo;t already exist. Finally, we have a drive() method that simulates driving the car.\nIn the client class, we create two CarSingleton objects using the getInstance() method. Since the getInstance() method returns the same instance each time it is called, both car1 and car2 will reference the same instance of the CarSingleton class. Finally, we call the drive() method on both car1 and car2 to demonstrate that they are referencing the same object.\n5. Singleton pattern : The Prototype pattern is a creational design pattern that allows creating new objects by copying existing ones, without exposing their underlying implementation details. This pattern provides a way to create new objects efficiently by cloning existing instances, rather than creating them from scratch.\nHere\u0026rsquo;s an example implementation of the Prototype pattern in Java using the car concept:\n// Prototype interface public interface CarPrototype extends Cloneable { public CarPrototype clone(); } // Concrete Prototype public class Car implements CarPrototype { private String make; private String model; private int year; public Car(String make, String model, int year) { this.make = make; this.model = model; this.year = year; } public void setMake(String make) { this.make = make; } public void setModel(String model) { this.model = model; } public void setYear(int year) { this.year = year; } @Override public CarPrototype clone() { return new Car(make, model, year); } @Override public String toString() { return \u0026quot;Car{\u0026quot; + \u0026quot;make='\u0026quot; + make + '\\'' + \u0026quot;, model='\u0026quot; + model + '\\'' + \u0026quot;, year=\u0026quot; + year + '}'; } } // Client class public class CarClient { public static void main(String[] args) { CarPrototype carPrototype = new Car(\u0026quot;Toyota\u0026quot;, \u0026quot;Camry\u0026quot;, 2022); CarPrototype clonedCar1 = carPrototype.clone(); CarPrototype clonedCar2 = carPrototype.clone(); // Changing properties of cloned car ((Car) clonedCar1).setYear(2023); ((Car) clonedCar2).setMake(\u0026quot;Honda\u0026quot;); System.out.println(carPrototype.toString()); System.out.println(clonedCar1.toString()); System.out.println(clonedCar2.toString()); } } In this example, we have a CarPrototype interface that defines the clone() method. The Car class implements the CarPrototype interface and provides an implementation of the clone() method. The CarClient class demonstrates how the prototype pattern can be used to create new Car objects efficiently by cloning an existing Car object. In the client class, we create a carPrototype object with some initial values. We then create two clonedCar objects by calling the clone() method on the carPrototype object. Finally, we modify the properties of the clonedCar objects to demonstrate that they are separate instances.\n","content_html":"\u003cp\u003eCreational design patterns solve common problems that arise during the creation of objects. Following are some of the commonly used creational design patterns.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. Builder pattern\u003c/strong\u003e : The Builder pattern is a creational design pattern that separates the construction of complex objects from their representation, allowing the same construction process to create different representations. This pattern is especially useful when creating objects that require many steps to initialize, and whose initialization steps are optional or may vary.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Car {\n    private String make;\n    private String model;\n    private int year;\n    private String color;\n    private String engine;\n \n    // Private constructor to enforce object creation through builder\n    private Car(Builder builder) {\n        this.make = builder.make;\n        this.model = builder.model;\n        this.year = builder.year;\n        this.color = builder.color;\n        this.engine = builder.engine;\n    }\n \n    public static class Builder {\n        private String make;\n        private String model;\n        private int year;\n        private String color;\n        private String engine;\n \n        public Builder make(String make) {\n            this.make = make;\n            return this;\n        }\n \n        public Builder model(String model) {\n            this.model = model;\n            return this;\n        }\n \n        public Builder year(int year) {\n            this.year = year;\n            return this;\n        }\n \n        public Builder color(String color) {\n            this.color = color;\n            return this;\n        }\n \n        public Builder engine(String engine) {\n            this.engine = engine;\n            return this;\n        }\n \n        public Car build() {\n            return new Car(this);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, the Car class has a private constructor to enforce object creation through the Builder. The Builder class has methods to set the different fields of the Car class, and a build() method to create the Car object.\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s an example of how to use the Builder to create a Car object:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eCar car = new Car.Builder()\n                .make(\u0026quot;Toyota\u0026quot;)\n                .model(\u0026quot;Camry\u0026quot;)\n                .year(2022)\n                .color(\u0026quot;Silver\u0026quot;)\n                .engine(\u0026quot;V6\u0026quot;)\n                .build();\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e2. Factory pattern\u003c/strong\u003e : The Factory pattern is a creational design pattern that provides a way to create objects without specifying the exact class of object that will be created. Instead, a factory class is used to create objects based on certain conditions or parameters.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface Car {\n    public void drive();\n}\n\npublic class Sedan implements Car {\n    @Override\n    public void drive() {\n        System.out.println(\u0026quot;Driving a Sedan\u0026quot;);\n    }\n}\n\npublic class SUV implements Car {\n    @Override\n    public void drive() {\n        System.out.println(\u0026quot;Driving an SUV\u0026quot;);\n    }\n}\n\npublic class CarFactory {\n    public static Car createCar(String carType) {\n        if(carType.equalsIgnoreCase(\u0026quot;Sedan\u0026quot;)) {\n            return new Sedan();\n        } else if(carType.equalsIgnoreCase(\u0026quot;SUV\u0026quot;)) {\n            return new SUV();\n        } else {\n            throw new IllegalArgumentException(\u0026quot;Invalid car type: \u0026quot; + carType);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, we have an interface called Car with a method called drive(), and two classes that implement the Car interface: Sedan and SUV. We also have a CarFactory class with a createCar() method that takes a carType parameter and creates a Car object based on the specified car type.\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s an example of how to use the CarFactory to create a Car object:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eCar sedan = CarFactory.createCar(\u0026quot;Sedan\u0026quot;);\nsedan.drive(); // Output: \u0026quot;Driving a Sedan\u0026quot;\n\nCar suv = CarFactory.createCar(\u0026quot;SUV\u0026quot;);\nsuv.drive(); // Output: \u0026quot;Driving an SUV\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, we create a Sedan and SUV object using the CarFactory.createCar() method, and then call the drive() method on each object to drive the car. The CarFactory class takes care of creating the correct type of Car object based on the input carType.\u003c/p\u003e\n\u003cp\u003eAdvantages of using static method in factory method:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eIt makes the method easily accessible: Since the method is static, it can be accessed directly from the class name, without the need to create an instance of the class.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIt simplifies the code: Since the method is static, it doesn\u0026rsquo;t require an instance of the class to be created, which can simplify the code.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIt is thread-safe: Static methods are thread-safe by default, which means that multiple threads can call the method simultaneously without causing any issues.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e3. Abstract Factory pattern\u003c/strong\u003e : The Abstract Factory Pattern is a creational design pattern that provides an interface for creating families of related or dependent objects without specifying their concrete classes. It is useful when you need to create a set of related objects that work together and have the same interface, but the concrete implementation of those objects may vary depending on some condition.\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s an example implementation of the Abstract Factory Pattern in Java:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface Car {\n    public void drive();\n}\n\npublic interface CarFactory {\n    public Car createCar();\n}\n\npublic class Sedan implements Car {\n    @Override\n    public void drive() {\n        System.out.println(\u0026quot;Driving a Sedan\u0026quot;);\n    }\n}\n\npublic class SUV implements Car {\n    @Override\n    public void drive() {\n        System.out.println(\u0026quot;Driving an SUV\u0026quot;);\n    }\n}\n\npublic class SedanFactory implements CarFactory {\n    @Override\n    public Car createCar() {\n        return new Sedan();\n    }\n}\n\npublic class SUVFactory implements CarFactory {\n    @Override\n    public Car createCar() {\n        return new SUV();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, we have an interface called Car with a method called drive(), and an interface called CarFactory with a method called createCar(). We also have two classes that implement the Car interface: Sedan and SUV. Additionally, we have two classes that implement the CarFactory interface: SedanFactory and SUVFactory.\u003c/p\u003e\n\u003cp\u003eThe SedanFactory and SUVFactory classes are responsible for creating Sedan and SUV objects, respectively. They implement the createCar() method to return a Car object of the corresponding type.\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s an example of how to use the Abstract Factory Pattern to create a set of related objects:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eCarFactory sedanFactory = new SedanFactory();\nCar sedan = sedanFactory.createCar();\nsedan.drive(); // Output: \u0026quot;Driving a Sedan\u0026quot;\n\nCarFactory suvFactory = new SUVFactory();\nCar suv = suvFactory.createCar();\nsuv.drive(); // Output: \u0026quot;Driving an SUV\u0026quot;\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, we create two instances of CarFactory - SedanFactory and SUVFactory. We then use these factories to create Car objects of the corresponding type - Sedan and SUV. Finally, we call the drive() method on each object to drive the car.\u003c/p\u003e\n\u003cp\u003eThe Abstract Factory Pattern makes it easy to create a set of related objects that work together and have the same interface, without specifying their concrete classes. This provides a lot of flexibility and makes it easier to modify the object creation process without affecting the rest of the code.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e4. Difference between factory and abstract factory\u003c/strong\u003e\nThe main difference between the Factory Pattern and the Abstract Factory Pattern is that the Factory Pattern creates individual objects, whereas the Abstract Factory Pattern creates families of related objects.\u003c/p\u003e\n\u003cp\u003eThe Factory Pattern is used to create a single object of a specific type. It provides a single interface that can be used to create an object of a specific class, based on some condition. This pattern is useful when you need to create an object of a specific type and want to decouple the object creation process from the rest of the code.\u003c/p\u003e\n\u003cp\u003eOn the other hand, the Abstract Factory Pattern is used to create a family of related objects. It provides an interface for creating families of related or dependent objects, without specifying their concrete classes. This pattern is useful when you need to create a set of related objects that work together and have the same interface, but the concrete implementation of those objects may vary depending on some condition.\u003c/p\u003e\n\u003cp\u003eIn general, you would use the Factory Pattern when you need to create a single object of a specific type, and the Abstract Factory Pattern when you need to create a family of related objects that work together.\u003c/p\u003e\n\u003cp\u003eFor example, let\u0026rsquo;s say you are building a car dealership application. You might use the Factory Pattern to create instances of individual car models, such as a Sedan or an SUV. However, you would use the Abstract Factory Pattern to create families of related objects, such as a family of Sedans that have the same engine type and features.\u003c/p\u003e\n\u003cp\u003eIn summary, the Factory Pattern and the Abstract Factory Pattern are both useful creational design patterns, but they serve different purposes. The Factory Pattern is used to create individual objects of a specific type, whereas the Abstract Factory Pattern is used to create families of related objects that work together.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e5. Singleton pattern\u003c/strong\u003e :The Singleton pattern is a creational design pattern that ensures that a class has only one instance and provides a global point of access to it. This pattern is useful when we need to ensure that only one instance of a class is created and shared across the application.\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s an example implementation of the Singleton pattern in Java using the car concept:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class CarSingleton {\n    // Private static instance of the singleton class\n    private static CarSingleton instance;\n\n    // Private constructor to prevent direct instantiation of the class\n    private CarSingleton() {\n    }\n\n    // Public static method to get the singleton instance\n    public static CarSingleton getInstance() {\n        if (instance == null) {\n            instance = new CarSingleton();\n        }\n        return instance;\n    }\n\n    public void drive() {\n        System.out.println(\u0026quot;Driving the car...\u0026quot;);\n    }\n}\n\n// Client class\npublic class CarClient {\n    public static void main(String[] args) {\n        CarSingleton car1 = CarSingleton.getInstance();\n        CarSingleton car2 = CarSingleton.getInstance();\n\n        // Both car1 and car2 will reference the same instance\n        System.out.println(car1 == car2);\n\n        car1.drive();\n        car2.drive();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, we have a CarSingleton class that implements the Singleton pattern. The class has a private static instance of itself and a private constructor to prevent direct instantiation of the class. The public static method getInstance() returns the singleton instance, creating it if it doesn\u0026rsquo;t already exist. Finally, we have a drive() method that simulates driving the car.\u003c/p\u003e\n\u003cp\u003eIn the client class, we create two CarSingleton objects using the getInstance() method. Since the getInstance() method returns the same instance each time it is called, both car1 and car2 will reference the same instance of the CarSingleton class. Finally, we call the drive() method on both car1 and car2 to demonstrate that they are referencing the same object.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e5. Singleton pattern\u003c/strong\u003e : The Prototype pattern is a creational design pattern that allows creating new objects by copying existing ones, without exposing their underlying implementation details. This pattern provides a way to create new objects efficiently by cloning existing instances, rather than creating them from scratch.\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s an example implementation of the Prototype pattern in Java using the car concept:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Prototype interface\npublic interface CarPrototype extends Cloneable {\n    public CarPrototype clone();\n}\n\n// Concrete Prototype\npublic class Car implements CarPrototype {\n    private String make;\n    private String model;\n    private int year;\n\n    public Car(String make, String model, int year) {\n        this.make = make;\n        this.model = model;\n        this.year = year;\n    }\n\n    public void setMake(String make) {\n        this.make = make;\n    }\n\n    public void setModel(String model) {\n        this.model = model;\n    }\n\n    public void setYear(int year) {\n        this.year = year;\n    }\n\n    @Override\n    public CarPrototype clone() {\n        return new Car(make, model, year);\n    }\n\n    @Override\n    public String toString() {\n        return \u0026quot;Car{\u0026quot; +\n                \u0026quot;make='\u0026quot; + make + '\\'' +\n                \u0026quot;, model='\u0026quot; + model + '\\'' +\n                \u0026quot;, year=\u0026quot; + year +\n                '}';\n    }\n}\n\n// Client class\npublic class CarClient {\n    public static void main(String[] args) {\n        CarPrototype carPrototype = new Car(\u0026quot;Toyota\u0026quot;, \u0026quot;Camry\u0026quot;, 2022);\n        CarPrototype clonedCar1 = carPrototype.clone();\n        CarPrototype clonedCar2 = carPrototype.clone();\n        \n        // Changing properties of cloned car\n        ((Car) clonedCar1).setYear(2023);\n        ((Car) clonedCar2).setMake(\u0026quot;Honda\u0026quot;);\n\n        System.out.println(carPrototype.toString());\n        System.out.println(clonedCar1.toString());\n        System.out.println(clonedCar2.toString());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, we have a CarPrototype interface that defines the clone() method. The Car class implements the CarPrototype interface and provides an implementation of the clone() method. The CarClient class demonstrates how the prototype pattern can be used to create new Car objects efficiently by cloning an existing Car object. In the client class, we create a carPrototype object with some initial values. We then create two clonedCar objects by calling the clone() method on the carPrototype object. Finally, we modify the properties of the clonedCar objects to demonstrate that they are separate instances.\u003c/p\u003e\n","url":"https://karthikselvam.com/posts/2023/03/23/creational_patterns/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"23036-23-09T30:2323:00+00:00","date_modified":"23036-23-09T30:2323:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"2bb0ecdfd217ff1a1b46a4b8205d6b01d48f02e4","title":"Awesome Stuff","summary":"2023","content_text":"1. Engineering Blogs\n2. Java Packages with UML Diagrams\n3. Java Resources\n4. The Architecture of Open Source Applications\n5. System Design\n","content_html":"\u003cp\u003e\u003cstrong\u003e1. \u003ca href=\"https://github.com/kilimchoi/engineering-blogs\"\u003eEngineering Blogs\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2. \u003ca href=\"https://www.falkhausen.de/index.html\"\u003eJava Packages with UML Diagrams\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e3. \u003ca href=\"https://github.com/hadign20/student-career-handbook/blob/master/domain-specific/a-deeper-understanding-of-java.md\"\u003eJava Resources\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e4. \u003ca href=\"https://aosabook.org/en/\"\u003eThe Architecture of Open Source Applications\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e5. \u003ca href=\"https://books.dwf.dev/docs/system-design/c0\"\u003eSystem Design\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n","url":"https://karthikselvam.com/posts/2023/02/25/awesome_stuff/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"25026-25-09T20:2525:00+00:00","date_modified":"25026-25-09T20:2525:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"76596ef151e06fe5326aaf77133f42ad5803562a","title":"Using Collections the right way","summary":"2023","content_text":"Iterating through a List # Iterating through a List using Index. Iterating through a list is a basic operation on a collection, but over the years it’s gone through a few significant changes. We’ll begin with the old and evolve an example—enumerating a list of names—to the elegant style.\nfinal List\u0026lt;String\u0026gt; friends = Arrays.asList(\u0026quot;Brian\u0026quot;, \u0026quot;Nate\u0026quot;, \u0026quot;Neal\u0026quot;, \u0026quot;Raju\u0026quot;, \u0026quot;Sara\u0026quot;, \u0026quot;Scott\u0026quot;); Here’s the habitual, but not so desirable, way to iterate and print each of the elements\nfor(int i = 0; i \u0026lt; friends.size(); i++) { System.out.println(friends.get(i)); } Iterating through a List using Iterator. for(String name : friends) { System.out.println(name); } Under the hood this form of iteration uses the Iterator interface and calls into its hasNext() and next() methods.Both these versions are external iterators, which mix how we do it with what we’d like to achieve. We explicitly control the iteration with them, indicating where to start and where to end; the second version does that under the hood using the Iterator methods. With explicit control, the break and continue statements can also help manage the iteration’s flow of control.\nUsing forEach friends.forEach(new Consumer\u0026lt;String\u0026gt;() { public void accept(final String name) { System.out.println(name); } }); we traded in the old for loop for the new internal iterator forEach(). As for the benefit, we went from specifying how to iterate to focusing on what we want to do for each element.\nUsing lambda expressions friends.forEach((final String name) -\u0026gt; System.out.println(name)); The underlying library takes control of how the lambda expressions are evaluated. It can decide to perform them lazily, in any order, and exploit parallelism as it sees fit.\nThe Java compiler also offers some lenience and can infer the types. Leaving out the type is convenient, requires less effort, and is less noisy. Here’s the previous code without the type information.\nfriends.forEach((name) -\u0026gt; System.out.println(name)); Transforming a List # Java’s String is immutable, so instances can’t be changed. We could create new strings in all caps and replace the appropriate elements in the collection. However, the original collection would be lost; also, if the original list is immutable, like it is when created with Arrays.asList(), then the list can’t change. Another downside is it would be hard to parallelize the computations.Creating a new list that has the elements in all caps is a better option.\nfinal List\u0026lt;String\u0026gt; uppercaseNames = new ArrayList\u0026lt;String\u0026gt;(); for(String name : friends) { uppercaseNames.add(name.toUpperCase()); } As a first step to move toward a functional style, we could use the internal iterator forEach() method.\nfinal List\u0026lt;String\u0026gt; uppercaseNames = new ArrayList\u0026lt;String\u0026gt;(); friends.forEach(name -\u0026gt; uppercaseNames.add(name.toUpperCase())); System.out.println(uppercaseNames); We used the internal iterator, but that still required the empty list and the effort to add elements to it.\nUsing Lambda Expressions : The map() method of a new Stream interface can help us avoid mutability and make the code concise\nfriends.stream() .map(name -\u0026gt; name.toUpperCase()) .forEach(name -\u0026gt; System.out.print(name + \u0026quot; \u0026quot;)); The map() method is quite useful to map or transform an input collection into a new output collection. This method will ensure that the same number of elements exists in the input and the output sequence. However, element types in the input don’t have to match the element types in the output collection.\nFinding Elements # The now-familiar elegant methods to traverse and transform collections will not directly help pick elements from a collection. The filter() method is designed for that purpose.\nFrom a list of names, let’s pick the ones that start with the letter N. Since there may be zero matching names in the list, the result may be an empty list. Let’s first code it using the old approach.\nfinal List\u0026lt;String\u0026gt; startsWithN = new ArrayList\u0026lt;String\u0026gt;(); for(String name : friends) { if(name.startsWith(\u0026quot;N\u0026quot;)) { startsWithN.add(name); } } Let’s refactor this code to use the filter() method.\nfinal List\u0026lt;String\u0026gt; startsWithN = friends.stream() .filter(name -\u0026gt; name.startsWith(\u0026quot;N\u0026quot;)) .collect(Collectors.toList()); The filter() method expects a lambda expression that returns a boolean result. If the lambda expression returns a true, the element in context while executing that lambda expression is added to a result collection; it’s skipped otherwise. Finally the method returns a Stream with only elements for which the lambda expression yielded a true.\nThe filter() method returns an iterator just like the map() method does, but the similarity ends there. Whereas the map() method returns a collection of the same size as the input collection, the filter() method may not. It may yield a result collection with a number of elements ranging from zero to the maximum number of elements in the input collection. However, unlike map(), the elements in the result collection that filter() returned are a subset of the elements in the input collection.\n","content_html":"\u003ch3 id=\"iterating-through-a-list\"\u003eIterating through a List \u003ca href=\"#iterating-through-a-list\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eIterating through a List using Index.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIterating through a list is a basic operation on a collection, but over the years it’s gone through a few significant changes. We’ll begin with the old and evolve an example—enumerating a list of names—to the elegant style.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003efinal List\u0026lt;String\u0026gt; friends = Arrays.asList(\u0026quot;Brian\u0026quot;, \u0026quot;Nate\u0026quot;, \u0026quot;Neal\u0026quot;, \u0026quot;Raju\u0026quot;, \u0026quot;Sara\u0026quot;, \u0026quot;Scott\u0026quot;);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere’s the habitual, but not so desirable, way to iterate and print each of the elements\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003efor(int i = 0; i \u0026lt; friends.size(); i++) {\n    System.out.println(friends.get(i));\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eIterating through a List using Iterator.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003efor(String name : friends) {\n    System.out.println(name);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUnder the hood this form of iteration uses the Iterator interface and calls into its hasNext() and next() methods.Both these versions are external iterators, which mix how we do it with what we’d like to achieve. We explicitly control the iteration with them, indicating where to start and where to end; the second version does that under the hood using the Iterator methods. With explicit control, the break and continue statements can also help manage the iteration’s flow of control.\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eUsing forEach\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003efriends.forEach(new Consumer\u0026lt;String\u0026gt;() {\n    public void accept(final String name) {\n         System.out.println(name);\n}\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewe traded in the old for loop for the new internal iterator forEach(). As for the benefit, we went from specifying how to iterate to focusing on what we want to do for each element.\u003c/p\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003eUsing lambda expressions\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003efriends.forEach((final String name) -\u0026gt; System.out.println(name));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe underlying library takes control of how the lambda expressions are evaluated. It can decide to perform them lazily, in any order, and exploit parallelism as it sees fit.\u003c/p\u003e\n\u003cp\u003eThe Java compiler also offers some lenience and can infer the types. Leaving out the type is convenient, requires less effort, and is less noisy. Here’s the previous code without the type information.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003efriends.forEach((name) -\u0026gt; System.out.println(name));\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"transforming-a-list\"\u003eTransforming a List \u003ca href=\"#transforming-a-list\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eJava’s String is immutable, so instances can’t be changed. We could create new strings in all caps and replace the appropriate elements in the collection. However, the original collection would be lost; also, if the original list is immutable, like it is when created with Arrays.asList(), then the list can’t change. Another downside is it would be hard to parallelize the computations.Creating a new list that has the elements in all caps is a better option.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003efinal List\u0026lt;String\u0026gt; uppercaseNames = new ArrayList\u0026lt;String\u0026gt;();\n    for(String name : friends) {\n        uppercaseNames.add(name.toUpperCase());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs a first step to move toward a functional style, we could use the internal iterator forEach() method.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003efinal List\u0026lt;String\u0026gt; uppercaseNames = new ArrayList\u0026lt;String\u0026gt;();\nfriends.forEach(name -\u0026gt; uppercaseNames.add(name.toUpperCase()));\nSystem.out.println(uppercaseNames);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe used the internal iterator, but that still required the empty list and the effort to add elements to it.\u003c/p\u003e\n\u003cp\u003eUsing Lambda Expressions : The map() method of a new Stream interface can help us avoid mutability and make the code concise\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003efriends.stream()\n.map(name -\u0026gt; name.toUpperCase())\n.forEach(name -\u0026gt; System.out.print(name + \u0026quot; \u0026quot;));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe map() method is quite useful to map or transform an input collection into a new output collection. This method will ensure that the same number of elements exists in the input and the output sequence. However, element types in the input don’t have to match the element types in the output collection.\u003c/p\u003e\n\u003ch3 id=\"finding-elements\"\u003eFinding Elements \u003ca href=\"#finding-elements\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe now-familiar elegant methods to traverse and transform collections will not directly help pick elements from a collection. The filter() method is designed for that purpose.\u003c/p\u003e\n\u003cp\u003eFrom a list of names, let’s pick the ones that start with the letter N. Since there may be zero matching names in the list, the result may be an empty list. Let’s first code it using the old approach.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003efinal List\u0026lt;String\u0026gt; startsWithN = new ArrayList\u0026lt;String\u0026gt;();\nfor(String name : friends) {\n    if(name.startsWith(\u0026quot;N\u0026quot;)) {\n        startsWithN.add(name);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet’s refactor this code to use the filter() method.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003efinal List\u0026lt;String\u0026gt; startsWithN = friends.stream()\n                                .filter(name -\u0026gt; name.startsWith(\u0026quot;N\u0026quot;))\n                                .collect(Collectors.toList());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe filter() method expects a lambda expression that returns a boolean result. If the lambda expression returns a true, the element in context while executing that lambda expression is added to a result collection; it’s skipped otherwise. Finally the method returns a Stream with only elements for which the lambda expression yielded a true.\u003c/p\u003e\n\u003cp\u003eThe filter() method returns an iterator just like the map() method does, but the similarity ends there. Whereas the map() method returns a collection of the same size as the input collection, the filter() method may not. It may yield a result collection with a number of elements ranging from zero to the maximum number of elements in the input collection. However, unlike map(), the elements in the result collection that filter() returned are a subset of the elements in the input collection.\u003c/p\u003e\n","url":"https://karthikselvam.com/posts/2023/02/23/collections/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"23026-23-09T20:2323:00+00:00","date_modified":"23026-23-09T20:2323:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"40d39a0995749b3f3ffb105708c1860d6fc6d5f7","title":"Note on Large Scale Deployment","summary":"2023","content_text":"Challenges in Large scale deployment # Application Deployment - problems at the application level Infrastructure Deployment - problems faced by hosting the application on the infrastructure Operations - problem that arise during the maintainence of deployment Application Deployment # Typical components of large scale systems:\nWeb Apps and replicas Microservices and replicas Databases RDBMS and NoSQL Replication and Sharding Message Queues Replication and partitioning Caches Content Storage Log file storage Search \u0026amp; Analytics Directory / LDAP servers Infrastructure Deployment # Things we need to take into considersation for deploying the application at infrastructure level\nCompute Infrastructure : CPU, RAM, Disks Network Secure Access : Firewalls, Certificates Routing Load Balancers Hard loadbalancers Software loadbalancers DNS and Discovery Services Storage for Application : Content, VM/Container Images, Backups, Logs Mail Servers CDN We must consider infrastructure support for Dev, Test, Stagging, and Prod enviroment as well.\nOperations # Development Team :Develop - Build - Test - Package - Image Operations Team : Deployment - Logging - Monitoring - Scale - Failover - Hotbackups / Coldbackups Deployment Solutions\nApplication Deploypment : Containers(Docker) Infrastructure Deployment: Cloud(Aws/Azure/Gcp) Operations : Kubernetes Automations : Devops Tools(Vagrant/Ansible/Chef) ","content_html":"\u003ch3 id=\"challenges-in-large-scale-deployment\"\u003eChallenges in Large scale deployment \u003ca href=\"#challenges-in-large-scale-deployment\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eApplication Deployment - problems at the application level\u003c/li\u003e\n\u003cli\u003eInfrastructure Deployment - problems faced by hosting the application on the infrastructure\u003c/li\u003e\n\u003cli\u003eOperations - problem that arise during the maintainence of deployment\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"application-deployment\"\u003eApplication Deployment \u003ca href=\"#application-deployment\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eTypical components of large scale systems:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWeb Apps and replicas\u003c/li\u003e\n\u003cli\u003eMicroservices and replicas\u003c/li\u003e\n\u003cli\u003eDatabases\n\u003cul\u003e\n\u003cli\u003eRDBMS and NoSQL\u003c/li\u003e\n\u003cli\u003eReplication and Sharding\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eMessage Queues\n\u003cul\u003e\n\u003cli\u003eReplication and partitioning\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCaches\u003c/li\u003e\n\u003cli\u003eContent Storage\u003c/li\u003e\n\u003cli\u003eLog file storage\u003c/li\u003e\n\u003cli\u003eSearch \u0026amp; Analytics\u003c/li\u003e\n\u003cli\u003eDirectory / LDAP servers\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"infrastructure-deployment\"\u003eInfrastructure Deployment \u003ca href=\"#infrastructure-deployment\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThings we need to take into considersation for deploying the application at infrastructure level\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCompute Infrastructure : CPU, RAM, Disks\u003c/li\u003e\n\u003cli\u003eNetwork\n\u003cul\u003e\n\u003cli\u003eSecure Access : Firewalls, Certificates\u003c/li\u003e\n\u003cli\u003eRouting\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eLoad Balancers\n\u003cul\u003e\n\u003cli\u003eHard loadbalancers\u003c/li\u003e\n\u003cli\u003eSoftware loadbalancers\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eDNS and Discovery Services\u003c/li\u003e\n\u003cli\u003eStorage for Application  : Content, VM/Container Images, Backups, Logs\u003c/li\u003e\n\u003cli\u003eMail Servers\u003c/li\u003e\n\u003cli\u003eCDN\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe must consider infrastructure support for Dev, Test, Stagging, and Prod enviroment as well.\u003c/p\u003e\n\u003ch3 id=\"operations\"\u003eOperations \u003ca href=\"#operations\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDevelopment Team :Develop - Build - Test - Package - Image\u003c/li\u003e\n\u003cli\u003eOperations Team : Deployment - Logging - Monitoring - Scale - Failover - Hotbackups / Coldbackups\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003eDeployment Solutions\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApplication Deploypment : Containers(Docker)\u003c/li\u003e\n\u003cli\u003eInfrastructure Deployment: Cloud(Aws/Azure/Gcp)\u003c/li\u003e\n\u003cli\u003eOperations : Kubernetes\u003c/li\u003e\n\u003cli\u003eAutomations : Devops Tools(Vagrant/Ansible/Chef)\u003c/li\u003e\n\u003c/ul\u003e\n","url":"https://karthikselvam.com/posts/2023/01/27/deployment/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"27016-27-09T10:2727:00+00:00","date_modified":"27016-27-09T10:2727:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"2d1b0260e6caf8990096645ae1b50eb64423e0b0","title":"System Performance","summary":"2023","content_text":"Performance # Measure of how fast or responsive a system is under\nA given workload A given hardware setup Performance Goals - As we increase workload the performance be stable or should not severely degrade the performance. If we increase hardware capacity the performance should ideally increase.\nHow to spot performance problems ? Every performance problems is result of some queue building somewhere. Ex: Network socket queue, DB IO queue, OS run queue etc.\nReasons for queue build up ?\nInefficient slow processing Serial resource access Limited resource capacity So while designing systems identify where queues build up can happen and avoid it.\nPerformance Principles # Efficiency :\nEfficient resource utilization IO - memory, network, disk CPU Efficient logic Aglorithms DB queries Efficient data storage Data Structures DB schema Caching Concurrency\nHardware Software Quequeing Coherence Capacity : Identifying a performance problem whether it is a concurrency/efficiency or capacity problem is a hard task.\nSystem Peformance Objectives # Minimize request-response latency\nLatency is measured in time units Depends on wait/idle time and processing time Maximize throughput\nThroughtput is measured as Rate of request processing and depends on latency and capacity. Performance Measurement Metrics # Latency\nAffects : user experience Desired : As low as possible Throughtput\nAffects : number of users that can be supported Desired : greater than the request rate Errors\nAffects : functional correctness Desired : None Resource saturation\nAffects : hardware capacity required Desired : Efficient utilization of all system resources Tail latency : Indication of quequing of requets and gets worse with higher workloads\nMeasure 99 percentile latency because average latency hides effects of tail latency\nSerial Request Latency # Network Latency\nData Transfer(Global/Regional/Local Network) TCP connection - Three way handshake SSL/TLS connection - On top of TCP Minimizing Network Latency\nOn Database side:\nConnection pool : We can create connection and reuse the connection and reduce connection creation latency. Data transfer Overhead : Reduce the size of data or don\u0026rsquo;t transfer the data at all(use cache). On client side:\nUse Persistent connections Static data caching Data format and compression SSL Session caching : reduce the repeated new connection creation between client and server Memory Latency\nFinite Heap memory : Increase garbage collection frequency GC Alogrithm : Use proper alogrithm Finite Buffer memory on Database Minimizing memory latency\nAvoid memory bloat : process should accupy as little memory as possible Weak/Soft References : allows GC to destroy the objects when running out of memory Multiple smaller processes are better than single process Garbage collection algorithm : Different flavors available(live process vs batch process) Allocate Finite buffer memory on database to improve database performance Normalization : reduce redundancy Compute Over Storage Disk Latency\nDisk access latency - Web server need to access files like html and javascript files which need to loaded from disk and can cause huge latency Disk Latency Approaches\nSequential IO and Random IO Asynchronous logging Static data can handled by reverse proxy(Page cache and Zero copy) Query optimization and Indexing Data caching Hardware Level - SSD Disk, RAID(Parallel Access), Higer Input Output per seconds IOPS. CPU Latency\nInefficient Algorithms Context Switching CPU Latency Approaches\nBatch / Async IO Single Threaded Model Thread Pool Size Multiprocess in Virtual Env Concurrent Request Latency # Concurrent Processing Amdhal\u0026rsquo;s Law : Have minimum serial request processing. Univsersal Scalability Law : Queueing + Coherence( caching of variables and there synchronization across threads) ","content_html":"\u003ch3 id=\"performance\"\u003ePerformance \u003ca href=\"#performance\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eMeasure of how fast or responsive a system is under\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA given workload\u003c/li\u003e\n\u003cli\u003eA given hardware setup\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePerformance Goals  - As we increase workload the performance be stable or should not severely degrade the performance. If we increase hardware capacity the performance should ideally increase.\u003c/p\u003e\n\u003cp\u003eHow to spot performance problems ?\nEvery performance problems is result of some queue building somewhere. Ex: Network socket queue, DB IO queue, OS run queue etc.\u003c/p\u003e\n\u003cp\u003eReasons for queue build up ?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eInefficient slow processing\u003c/li\u003e\n\u003cli\u003eSerial resource access\u003c/li\u003e\n\u003cli\u003eLimited resource capacity\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo while designing systems identify where queues build up can happen and avoid it.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"performance-principles\"\u003ePerformance Principles \u003ca href=\"#performance-principles\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eEfficiency :\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eEfficient resource utilization\n\u003cul\u003e\n\u003cli\u003eIO - memory, network, disk\u003c/li\u003e\n\u003cli\u003eCPU\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eEfficient logic\n\u003cul\u003e\n\u003cli\u003eAglorithms\u003c/li\u003e\n\u003cli\u003eDB queries\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eEfficient data storage\n\u003cul\u003e\n\u003cli\u003eData Structures\u003c/li\u003e\n\u003cli\u003eDB schema\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCaching\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eConcurrency\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHardware\u003c/li\u003e\n\u003cli\u003eSoftware\n\u003cul\u003e\n\u003cli\u003eQuequeing\u003c/li\u003e\n\u003cli\u003eCoherence\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCapacity : Identifying a performance problem whether it is a concurrency/efficiency or capacity problem is a hard task.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"system-peformance-objectives\"\u003eSystem Peformance Objectives \u003ca href=\"#system-peformance-objectives\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMinimize request-response latency\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLatency is measured in time units\u003c/li\u003e\n\u003cli\u003eDepends on wait/idle time and processing time\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMaximize throughput\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThroughtput is measured as Rate of request processing and depends on latency and capacity.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"performance-measurement-metrics\"\u003ePerformance Measurement Metrics \u003ca href=\"#performance-measurement-metrics\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eLatency\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAffects : user experience\u003c/li\u003e\n\u003cli\u003eDesired : As low as possible\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThroughtput\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAffects : number of users that can be supported\u003c/li\u003e\n\u003cli\u003eDesired : greater than the request rate\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eErrors\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAffects : functional correctness\u003c/li\u003e\n\u003cli\u003eDesired : None\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eResource saturation\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAffects : hardware capacity required\u003c/li\u003e\n\u003cli\u003eDesired : Efficient utilization of all system resources\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTail latency : Indication of quequing of requets and gets worse with higher workloads\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMeasure 99 percentile latency because average latency hides effects of tail latency\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"serial-request-latency\"\u003eSerial Request Latency \u003ca href=\"#serial-request-latency\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eNetwork Latency\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eData Transfer(Global/Regional/Local Network)\u003c/li\u003e\n\u003cli\u003eTCP connection - Three way handshake\u003c/li\u003e\n\u003cli\u003eSSL/TLS connection - On top of TCP\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMinimizing Network Latency\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eOn Database side:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eConnection pool : We can create connection and reuse the connection and reduce connection creation latency.\u003c/li\u003e\n\u003cli\u003eData transfer Overhead : Reduce the size of data or don\u0026rsquo;t transfer the data at all(use cache).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eOn client side:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUse Persistent connections\u003c/li\u003e\n\u003cli\u003eStatic data caching\u003c/li\u003e\n\u003cli\u003eData format and compression\u003c/li\u003e\n\u003cli\u003eSSL Session caching : reduce the repeated new connection creation between client and server\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMemory Latency\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFinite Heap memory : Increase garbage collection frequency\u003c/li\u003e\n\u003cli\u003eGC Alogrithm : Use proper alogrithm\u003c/li\u003e\n\u003cli\u003eFinite Buffer memory on Database\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMinimizing memory latency\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAvoid memory bloat : process should accupy as little memory as possible\u003c/li\u003e\n\u003cli\u003eWeak/Soft References : allows GC to destroy the objects when running out of memory\u003c/li\u003e\n\u003cli\u003eMultiple smaller processes are better than single process\u003c/li\u003e\n\u003cli\u003eGarbage collection algorithm : Different flavors available(live process vs batch process)\u003c/li\u003e\n\u003cli\u003eAllocate Finite buffer memory on database to improve database performance\n\u003cul\u003e\n\u003cli\u003eNormalization : reduce redundancy\u003c/li\u003e\n\u003cli\u003eCompute Over Storage\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDisk Latency\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDisk access latency - Web server need to access files like html and javascript files which need to loaded from disk and can cause huge latency\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDisk Latency Approaches\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSequential IO and Random IO\u003c/li\u003e\n\u003cli\u003eAsynchronous logging\u003c/li\u003e\n\u003cli\u003eStatic data can handled by reverse proxy(Page cache and Zero copy)\u003c/li\u003e\n\u003cli\u003eQuery optimization and Indexing\u003c/li\u003e\n\u003cli\u003eData caching\u003c/li\u003e\n\u003cli\u003eHardware Level - SSD Disk, RAID(Parallel Access), Higer Input Output per seconds IOPS.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCPU Latency\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eInefficient Algorithms\u003c/li\u003e\n\u003cli\u003eContext Switching\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCPU Latency Approaches\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBatch / Async IO\u003c/li\u003e\n\u003cli\u003eSingle Threaded Model\u003c/li\u003e\n\u003cli\u003eThread Pool Size\u003c/li\u003e\n\u003cli\u003eMultiprocess in Virtual Env\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"concurrent-request-latency\"\u003eConcurrent Request Latency \u003ca href=\"#concurrent-request-latency\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eConcurrent Processing\n\u003cul\u003e\n\u003cli\u003eAmdhal\u0026rsquo;s Law : Have minimum serial request processing.\u003c/li\u003e\n\u003cli\u003eUnivsersal Scalability Law : Queueing + Coherence( caching of variables and there synchronization across threads)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","url":"https://karthikselvam.com/posts/2023/01/27/performance/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"27016-27-09T10:2727:00+00:00","date_modified":"27016-27-09T10:2727:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"aa12e75e9a11a37e43706c436c44cb47b0c9c00d","title":"JVM Profiling","summary":"2023","content_text":"1. Introduction to JDK Flight Recorder\n2. JVM Profiling in Kubernetes with Java Flight Recorder\n","content_html":"\u003cp\u003e\u003cstrong\u003e1. \u003ca href=\"https://www.youtube.com/watch?v=7z_R2Aq-Fl8\"\u003eIntroduction to JDK Flight Recorder\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2. \u003ca href=\"https://tech.olx.com/jvm-profiling-in-kubernetes-with-java-flight-recorder-b39a6181a99c\"\u003eJVM Profiling in Kubernetes with Java Flight Recorder\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n","url":"https://karthikselvam.com/posts/2023/01/25/profiling/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"25016-25-09T10:2525:00+00:00","date_modified":"25016-25-09T10:2525:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"74985da267c6803b262f117de72af2d02e48029f","title":"Streams","summary":"2023","content_text":"In this article, we will solve intervals-related problems that are commonly encountered in interviews.\n1. Given a list of integers, find the sum of all even numbers.\nList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); int sumOfEvens = numbers.stream() .filter(n -\u0026gt; n % 2 == 0) .mapToInt(Integer::intValue) .sum(); System.out.println(sumOfEvens); 2. Given a list of strings, return a list of strings that start with a given letter.\nList\u0026lt;String\u0026gt; myList = new ArrayList\u0026lt;\u0026gt;(); myList.add(\u0026quot;pqr\u0026quot;); myList.add(\u0026quot;stu\u0026quot;); myList.add(\u0026quot;vwx\u0026quot;); myList.add(\u0026quot;yza\u0026quot;); myList.add(\u0026quot;bcd\u0026quot;); myList.add(\u0026quot;efg\u0026quot;); myList.add(\u0026quot;vwxy\u0026quot;); List\u0026lt;String\u0026gt; result = myList.stream() .filter(x -\u0026gt; x.startsWith(\u0026quot;v\u0026quot;)) .collect(Collectors.toList()); System.out.println(result); 3. Given a list of integers, return a list of their squares.\nList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); List\u0026lt;Integer\u0026gt; result = numbers.stream().map(x -\u0026gt; x * x).collect(Collectors.toList()); System.out.print(result); 4. Given a list of strings, return a list of the lengths of those strings.\nList\u0026lt;String\u0026gt; myList = new ArrayList\u0026lt;\u0026gt;(); myList.add(\u0026quot;p\u0026quot;); myList.add(\u0026quot;st\u0026quot;); myList.add(\u0026quot;vwx\u0026quot;); myList.add(\u0026quot;ayza\u0026quot;); myList.add(\u0026quot;bcead\u0026quot;); myList.add(\u0026quot;efgass\u0026quot;); myList.add(\u0026quot;vwxyaefw\u0026quot;); List\u0026lt;Integer\u0026gt; result = myList.stream().map(x -\u0026gt; x.length()).collect(Collectors.toList()); System.out.print(result); 5. Given a list of integers, find the maximum value.\nList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 10, 88, 101, 3, 7, 999); Integer result = numbers.stream().max(Integer::compare).get(); System.out.println(result); ","content_html":"\u003cp\u003eIn this article, we will solve intervals-related problems that are commonly encountered in interviews.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. Given a list of integers, find the sum of all even numbers.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\nint sumOfEvens = numbers.stream()\n                        .filter(n -\u0026gt; n % 2 == 0)\n                        .mapToInt(Integer::intValue)\n                        .sum();\n\nSystem.out.println(sumOfEvens); \n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e2. Given a list of strings, return a list of strings that start with a given letter.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eList\u0026lt;String\u0026gt; myList = new ArrayList\u0026lt;\u0026gt;();\n\t      myList.add(\u0026quot;pqr\u0026quot;);\n\t      myList.add(\u0026quot;stu\u0026quot;);\n\t      myList.add(\u0026quot;vwx\u0026quot;);\n\t      myList.add(\u0026quot;yza\u0026quot;);\n\t      myList.add(\u0026quot;bcd\u0026quot;);\n\t      myList.add(\u0026quot;efg\u0026quot;);\n\t      myList.add(\u0026quot;vwxy\u0026quot;);\nList\u0026lt;String\u0026gt; result = myList.stream()\n\t    \t\t  \t\t\t.filter(x -\u0026gt; x.startsWith(\u0026quot;v\u0026quot;))\n\t    \t\t  \t\t\t.collect(Collectors.toList());\nSystem.out.println(result);\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e3. Given a list of integers, return a list of their squares.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\nList\u0026lt;Integer\u0026gt; result = numbers.stream().map(x -\u0026gt; x * x).collect(Collectors.toList());\nSystem.out.print(result);\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e4. Given a list of strings, return a list of the lengths of those strings.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eList\u0026lt;String\u0026gt; myList = new ArrayList\u0026lt;\u0026gt;();\n\t\tmyList.add(\u0026quot;p\u0026quot;);\n\t\tmyList.add(\u0026quot;st\u0026quot;);\n\t\tmyList.add(\u0026quot;vwx\u0026quot;);\n\t\tmyList.add(\u0026quot;ayza\u0026quot;);\n\t\tmyList.add(\u0026quot;bcead\u0026quot;);\n\t\tmyList.add(\u0026quot;efgass\u0026quot;);\n\t\tmyList.add(\u0026quot;vwxyaefw\u0026quot;);\n\nList\u0026lt;Integer\u0026gt; result = myList.stream().map(x -\u0026gt; x.length()).collect(Collectors.toList());\nSystem.out.print(result);\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e5. Given a list of integers, find the maximum value.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 10, 88, 101, 3, 7, 999);\nInteger result = numbers.stream().max(Integer::compare).get();\nSystem.out.println(result);\n\u003c/code\u003e\u003c/pre\u003e\n","url":"https://karthikselvam.com/posts/2023/01/25/streams/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"25016-25-09T10:2525:00+00:00","date_modified":"25016-25-09T10:2525:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"94c9e75c50f087901721094867a286834fb42616","title":"Understanding OOP concepts","summary":"2023","content_text":"1. What is an Object?\nAn object is an entity in the real world that possesses state (fields) and behaviors (methods). It represents an instance of a class, occupies space in memory, and can communicate with other objects\n2. What is a Class?\nA class is a programming construct that serves as a template or blueprint for creating objects. Unlike objects, classes do not consume memory. Instead, they define the properties and behaviors of objects that can be instantiated multiple times.\n3. What is a Abstraction?\nAbstraction is the concept of exposing to the user only the relevant information while hiding the unnecessary details. This enables the user to focus on what the application does, rather than how it does it.\nLet\u0026rsquo;s consider a real-life example: a man driving a car. The man knows what each pedal does and what the steering wheel does, but he doesn\u0026rsquo;t know how these things are done internally by the car. He doesn\u0026rsquo;t know about the inner mechanisms that empower these things. This is what abstraction is. In Java, abstraction can be achieved via abstract classes and interfaces.\npublic interface Car { public void speedUp(); public void slowDown(); public void turnRight(); public void turnLeft(); public String getCarType(); } Next, each type of car should implement the Car interface and override these methods to provide the implementation of these actions. This implementation is hidden from the user (the man driving the car). For example, the ElectricCar class appears as follows:\npublic class ElectricCar implements Car { private final String carType; public ElectricCar(String carType) { this.carType = carType; } @Override public void speedUp() { System.out.println(\u0026quot;Speed up the electric car\u0026quot;); } @Override public void slowDown() { System.out.println(\u0026quot;Slow down the electric car\u0026quot;); } @Override public void turnRight() { System.out.println(\u0026quot;Turn right the electric car\u0026quot;); } @Override public void turnLeft() { System.out.println(\u0026quot;Turn left the electric car\u0026quot;); } @Override public String getCarType() { return this.carType; } } The user of this class has access to these public methods without being aware of the implementation:\npublic class Main { public static void main(String[] args) { Car electricCar = new ElectricCar(\u0026quot;BMW\u0026quot;); System.out.println(\u0026quot;Driving the electric car: \u0026quot; + electricCar.getCarType() + \u0026quot;\\n\u0026quot;); electricCar.speedUp(); electricCar.turnLeft(); electricCar.slowDown(); } } The output is listed as follows:\nDriving the electric car: BMW Speed up the electric car Turn left the electric car Slow down the electric car 4. What is a Encapsulation?\nEncapsulation is a technique whereby the state of an object is hidden from the outside world, and a set of public methods are exposed for accessing this state. Encapsulation is achieved when each object keeps its state private inside a class. It is known as a data-hiding mechanism, and has several important advantages associated with it, such as enabling loosely coupled, reusable, secure, and easy-to-test code.\nIn Java, encapsulation is implemented through the use of access modifiers such as public, private, and protected.\npublic class Person { private String name; private int age; // Getter method for name public String getName() { return name; } // Setter method for name public void setName(String name) { this.name = name; } // Getter method for age public int getAge() { return age; } // Setter method for age public void setAge(int age) { this.age = age; } } In this example, we have a Person class that encapsulates the state (name and age) of a person object. The state is hidden from the outside world through the use of private access modifiers on the name and age variables. However, public getter and setter methods (getName(), setName(), getAge(), setAge()) are provided for accessing and modifying the state of the object. This allows us to maintain control over the state of the object, ensuring that it remains valid and consistent at all times, while also providing a well-defined interface for other parts of the program to interact with the object.\n5. What is a Inheritance ?\nInheritance is a fundamental concept in object-oriented programming, which allows one class (the child or subclass) to inherit properties and methods from another class (the parent or superclass). This helps to promote code reuse, reduce duplication, and make the code more modular and easier to maintain.\nIn Java, inheritance is achieved through the use of the extends keyword. The child class inherits all the visible properties and methods of the parent class, which can be overridden or extended as needed.\nHere\u0026rsquo;s an example of inheritance in Java:\npublic class Animal { private String name; private int age; public Animal(String name, int age) { this.name = name; this.age = age; } public void eat() { System.out.println(name + \u0026quot; is eating.\u0026quot;); } public void sleep() { System.out.println(name + \u0026quot; is sleeping.\u0026quot;); } } public class Cat extends Animal { public Cat(String name, int age) { super(name, age); } public void meow() { System.out.println(\u0026quot;Meow!\u0026quot;); } @Override public void sleep() { System.out.println(getName() + \u0026quot; is curling up and sleeping.\u0026quot;); } } In this example, we have an Animal class that defines common properties and methods for all animals, such as name and age, and eat() and sleep() methods. The Cat class extends the Animal class, inheriting all its properties and methods, and also adds a new meow() method.\nWe can now create a Cat object and call its methods like this:\nCat cat = new Cat(\u0026quot;Kitty\u0026quot;, 2); cat.eat(); // Output: Kitty is eating. cat.sleep(); // Output: Kitty is curling up and sleeping. cat.meow(); // Output: Meow! In this example, the Cat class has overridden the sleep() method inherited from the Animal class, to provide a more specific implementation for cats. This demonstrates the flexibility and extensibility of inheritance, which allows us to modify the behavior of a class to better fit our needs.\n6. What is a Polymorphism ?\nPolymorphism is a concept in object-oriented programming that enables an object to exhibit different behaviors in certain scenarios. This can be achieved through method overloading, which is a form of compile-time polymorphism, or through method overriding, which is a form of runtime polymorphism and is applicable in the case of an IS-A relationship.\nPolymorphism via method overloading(compile time)\npublic class Calculator { public int add(int a, int b) { return a + b; } public double add(double a, double b) { return a + b; } } Polymorphism via method overriding(runtime)\npublic class Animal { public void makeSound() { System.out.println(\u0026quot;Animal makes a sound\u0026quot;); } } public class Dog extends Animal { @Override public void makeSound() { System.out.println(\u0026quot;Dog barks\u0026quot;); } } public class Cat extends Animal { @Override public void makeSound() { System.out.println(\u0026quot;Cat meows\u0026quot;); } } public class Main { public static void main(String[] args) { Animal animal1 = new Dog(); Animal animal2 = new Cat(); animal1.makeSound(); // Output: Dog barks animal2.makeSound(); // Output: Cat meows } } In the example above, we have an Animal class and two subclasses, Dog and Cat, that extend it. The makeSound method is overridden in each subclass to produce a different sound. In the Main class, we create an instance of Dog and Cat but assign them to variables of type Animal. When the makeSound method is called on each of these objects, the appropriate overridden version of the method is executed, producing \u0026ldquo;Dog barks\u0026rdquo; and \u0026ldquo;Cat meows\u0026rdquo; as output, respectively. This is an example of polymorphism as the same method is called on objects of different types, but the behavior is different depending on the actual type of the object at runtime.\n7. What is a Association ?\nAssociation is a concept in object-oriented programming that describes the relationship between two classes that are independent of each other. An association does not have an owner, and it can take different forms, including one-to-one, one-to-many, many-to-one, and many-to-many, depending on the cardinality and multiplicity of the relationship between the two classes.\nHere is an example of association in Java using a one-to-many relationship:\npublic class Library { private List\u0026lt;Book\u0026gt; books; public Library() { books = new ArrayList\u0026lt;\u0026gt;(); } public void addBook(Book book) { books.add(book); } } public class Book { private String title; private String author; public Book(String title, String author) { this.title = title; this.author = author; } // getters and setters } In this example, the Library class has an association with the Book class. The Library class has a list of Book objects, and it provides a method addBook() to add a book to the list. This is an example of a one-to-many association because a Library can have many Book objects in its list.\nThe Book class, on the other hand, has no knowledge of the Library class. It simply defines the properties of a book such as its title and author. This is an example of unidirectional association.\n8. What is a Aggregation ?\nAggregation is one of the core concepts of OOP. Mainly, aggregation is a special case of unidirectional association. While an association defines the relationship between two classes independent of one another, aggregation represents a HAS-A relationship between these two classes. In other words, two aggregated objects have their own life cycle, but one of the objects is the owner of the HAS-A relationship. Having their own life cycle means that ending one object will not affect the other object. For example, a TennisPlayer has a Racket. This is a unidirectional association since a Racket cannot have a TennisPlayer. Even if the TennisPlayer dies, the Racket is not affected.\nFor example, a TennisPlayer has a Racket. This is a unidirectional association since a Racket cannot have a TennisPlayer. Even if the TennisPlayer dies, the Racket is not affected.\npublic class Racket { private String type; private int size; private int weight; public Racket(String type, int size, int weight) { this.type = type; this.size = size; this.weight = weight; } // getters and setters omitted for brevity } A TennisPlayer HAS-A Racket. Therefore, the TennisPlayer class must be capable of receiving a Racket as follows:\npublic class TennisPlayer { private String name; private Racket racket; public TennisPlayer(String name, Racket racket) { this.name = name; this.racket = racket } // getters and setters omitted for brevity } Next, we create a Racket and a TennisPlayer that uses this Racket:\npublic static void main(String[] args) { Racket racket = new Racket(\u0026quot;Babolat Pure Aero\u0026quot;, 100, 300); TennisPlayer player = new TennisPlayer(\u0026quot;Rafael Nadal\u0026quot;, racket); System.out.println(\u0026quot;Player \u0026quot; + player.getName() + \u0026quot; plays with \u0026quot; + player.getRacket().getType()); } The output is as follows:\nPlayer Rafael Nadal plays with Babolat Pure Aero 9. What is a Composition ?\nComposition is one of the core concepts of OOP. Primarily, composition is a more restrictive case of aggregation. While aggregation represents a HAS-A relationship between two objects having their own life cycle, composition represents a HAS-A relationship that contains an object that cannot exist on its own. In order to highlight this coupling, the HAS-A relationship can be named PART-OF as well. For example, a Car has an Engine. In other words, the engine is PART-OF the car. If the car is destroyed, then the engine is destroyed as well. Composition is said to be better than inheritance because it sustains code reuse and the visibility control of objects.\npublic class Engine { private String type; private int horsepower; public Engine(String type, int horsepower) { this.type = type; this.horsepower = horsepower; } // getters and setters omitted for brevity } Next, we have the Car class. Check out the constructor of this class. Since Engine is part of Car, we create it with the Car.\npublic class Car { private final String name; private final Engine engine; public Car(String name) { this.name = name; Engine engine = new Engine(\u0026quot;petrol\u0026quot;, 300); this.engine=engine; } public int getHorsepower() { return engine.getHorsepower(); } public String getName() { return name; } } we can test composition from the main() method as follows:\npublic static void main(String[] args) { Car car = new Car(\u0026quot;MyCar\u0026quot;); System.out.println(\u0026quot;Horsepower: \u0026quot; + car.getHorsepower()); } output is as follows:\nHorsepower: 300 That\u0026rsquo;s it for OOPS.\n","content_html":"\u003cp\u003e\u003cstrong\u003e1. What is an Object?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAn object is an entity in the real world that possesses state (fields) and behaviors (methods). It represents an instance of a class, occupies space in memory, and can communicate with other objects\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2. What is a Class?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eA class is a programming construct that serves as a template or blueprint for creating objects. Unlike objects, classes do not consume memory. Instead, they define the properties and behaviors of objects that can be instantiated multiple times.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e3. What is a Abstraction?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAbstraction is the concept of exposing to the user only the relevant information while hiding the unnecessary details. This enables the user to focus on what the application does, rather than how it does it.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s consider a real-life example: a man driving a car. The man knows what each pedal does and what the steering wheel does, but he doesn\u0026rsquo;t know how these things are done internally by the car. He doesn\u0026rsquo;t know about the inner mechanisms that empower these things. This is what abstraction is. In Java, abstraction can be achieved via abstract classes and interfaces.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface Car {\n    public void speedUp();\n    public void slowDown();\n    public void turnRight();\n    public void turnLeft();\n    public String getCarType();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, each type of car should implement the Car interface and override these methods to provide the implementation of these actions. This implementation is hidden from the user (the man driving the car). For example, the ElectricCar class appears as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class ElectricCar implements Car {\n    private final String carType;\n\n    public ElectricCar(String carType) {\n        this.carType = carType;\n    } \n\n    @Override\n    public void speedUp() {\n        System.out.println(\u0026quot;Speed up the electric car\u0026quot;);\n    }\n    @Override\n    public void slowDown() {\n        System.out.println(\u0026quot;Slow down the electric car\u0026quot;);\n    }\n\n    @Override\n    public void turnRight() {\n        System.out.println(\u0026quot;Turn right the electric car\u0026quot;);\n    }\n\n    @Override\n    public void turnLeft() {\n        System.out.println(\u0026quot;Turn left the electric car\u0026quot;);\n    }\n    \n    @Override\n    public String getCarType() {\n         return this.carType;\n    } \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe user of this class has access to these public methods without being aware of the implementation:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epublic class Main {\n    public static void main(String[] args) {\n        Car electricCar = new ElectricCar(\u0026quot;BMW\u0026quot;);\n        System.out.println(\u0026quot;Driving the electric car: \u0026quot; + electricCar.getCarType() + \u0026quot;\\n\u0026quot;);\n        electricCar.speedUp();\n        electricCar.turnLeft();\n        electricCar.slowDown();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output is listed as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDriving the electric car: BMW\nSpeed up the electric car\nTurn left the electric car\nSlow down the electric car\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e4. What is a Encapsulation?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eEncapsulation is a technique whereby the state of an object is hidden from the outside world, and a set of public methods are exposed for accessing this state. Encapsulation is achieved when each object keeps its state private inside a class. It is known as a data-hiding mechanism, and has several important advantages associated with it, such as enabling loosely coupled, reusable, secure, and easy-to-test code.\u003c/p\u003e\n\u003cp\u003eIn Java, encapsulation is implemented through the use of access modifiers such as public, private, and protected.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Person {\n  private String name;\n  private int age;\n\n  // Getter method for name\n  public String getName() {\n    return name;\n  }\n\n  // Setter method for name\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  // Getter method for age\n  public int getAge() {\n    return age;\n  }\n\n  // Setter method for age\n  public void setAge(int age) {\n    this.age = age;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, we have a Person class that encapsulates the state (name and age) of a person object. The state is hidden from the outside world through the use of private access modifiers on the name and age variables. However, public getter and setter methods (getName(), setName(), getAge(), setAge()) are provided for accessing and modifying the state of the object. This allows us to maintain control over the state of the object, ensuring that it remains valid and consistent at all times, while also providing a well-defined interface for other parts of the program to interact with the object.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e5. What is a Inheritance ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eInheritance is a fundamental concept in object-oriented programming, which allows one class (the child or subclass) to inherit properties and methods from another class (the parent or superclass). This helps to promote code reuse, reduce duplication, and make the code more modular and easier to maintain.\u003c/p\u003e\n\u003cp\u003eIn Java, inheritance is achieved through the use of the \u003cstrong\u003eextends\u003c/strong\u003e keyword. The child class inherits all the visible properties and methods of the parent class, which can be overridden or extended as needed.\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s an example of inheritance in Java:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Animal {\n  private String name;\n  private int age;\n\n  public Animal(String name, int age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  public void eat() {\n    System.out.println(name + \u0026quot; is eating.\u0026quot;);\n  }\n\n  public void sleep() {\n    System.out.println(name + \u0026quot; is sleeping.\u0026quot;);\n  }\n}\n\npublic class Cat extends Animal {\n  public Cat(String name, int age) {\n    super(name, age);\n  }\n\n  public void meow() {\n    System.out.println(\u0026quot;Meow!\u0026quot;);\n  }\n\n  @Override\n  public void sleep() {\n    System.out.println(getName() + \u0026quot; is curling up and sleeping.\u0026quot;);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, we have an Animal class that defines common properties and methods for all animals, such as name and age, and eat() and sleep() methods. The Cat class extends the Animal class, inheriting all its properties and methods, and also adds a new meow() method.\u003c/p\u003e\n\u003cp\u003eWe can now create a Cat object and call its methods like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCat cat = new Cat(\u0026quot;Kitty\u0026quot;, 2);\ncat.eat(); // Output: Kitty is eating.\ncat.sleep(); // Output: Kitty is curling up and sleeping.\ncat.meow(); // Output: Meow!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, the Cat class has overridden the sleep() method inherited from the Animal class, to provide a more specific implementation for cats. This demonstrates the flexibility and extensibility of inheritance, which allows us to modify the behavior of a class to better fit our needs.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e6. What is a Polymorphism ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003ePolymorphism is a concept in object-oriented programming that enables an object to exhibit different behaviors in certain scenarios. This can be achieved through method overloading, which is a form of compile-time polymorphism, or through method overriding, which is a form of runtime polymorphism and is applicable in the case of an IS-A relationship.\u003c/p\u003e\n\u003cp\u003ePolymorphism via method overloading(compile time)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n    \n    public double add(double a, double b) {\n        return a + b;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePolymorphism via method overriding(runtime)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Animal {\n    public void makeSound() {\n        System.out.println(\u0026quot;Animal makes a sound\u0026quot;);\n    }\n}\n\npublic class Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\u0026quot;Dog barks\u0026quot;);\n    }\n}\n\npublic class Cat extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\u0026quot;Cat meows\u0026quot;);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal animal1 = new Dog();\n        Animal animal2 = new Cat();\n        \n        animal1.makeSound(); // Output: Dog barks\n        animal2.makeSound(); // Output: Cat meows\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn the example above, we have an Animal class and two subclasses, Dog and Cat, that extend it. The makeSound method is overridden in each subclass to produce a different sound. In the Main class, we create an instance of Dog and Cat but assign them to variables of type Animal. When the makeSound method is called on each of these objects, the appropriate overridden version of the method is executed, producing \u0026ldquo;Dog barks\u0026rdquo; and \u0026ldquo;Cat meows\u0026rdquo; as output, respectively. This is an example of polymorphism as the same method is called on objects of different types, but the behavior is different depending on the actual type of the object at runtime.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e7. What is a Association ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAssociation is a concept in object-oriented programming that describes the relationship between two classes that are independent of each other. An association does not have an owner, and it can take different forms, including one-to-one, one-to-many, many-to-one, and many-to-many, depending on the cardinality and multiplicity of the relationship between the two classes.\u003c/p\u003e\n\u003cp\u003eHere is an example of association in Java using a one-to-many relationship:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Library {\n   private List\u0026lt;Book\u0026gt; books;\n\n   public Library() {\n      books = new ArrayList\u0026lt;\u0026gt;();\n   }\n\n   public void addBook(Book book) {\n      books.add(book);\n   }\n}\n\npublic class Book {\n   private String title;\n   private String author;\n\n   public Book(String title, String author) {\n      this.title = title;\n      this.author = author;\n   }\n\n   // getters and setters\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, the Library class has an association with the Book class. The Library class has a list of Book objects, and it provides a method addBook() to add a book to the list. This is an example of a one-to-many association because a Library can have many Book objects in its list.\u003c/p\u003e\n\u003cp\u003eThe Book class, on the other hand, has no knowledge of the Library class. It simply defines the properties of a book such as its title and author. This is an example of unidirectional association.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e8. What is a Aggregation ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAggregation is one of the core concepts of OOP. Mainly, aggregation is a special case of unidirectional association. While an association defines the relationship between two classes independent of one another, aggregation represents a HAS-A relationship between these two classes. In other words, two aggregated objects have their own life cycle, but one of the objects is the owner of the HAS-A relationship. Having their own life cycle means that ending one object will not affect the other object. For example, a TennisPlayer has a Racket. This is a unidirectional association since a Racket cannot have a TennisPlayer. Even if the TennisPlayer dies, the Racket is not affected.\u003c/p\u003e\n\u003cp\u003eFor example, a TennisPlayer has a Racket. This is a unidirectional association since a Racket cannot have a TennisPlayer. Even if the TennisPlayer dies, the Racket is not affected.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Racket {\n    private String type;\n    private int size;\n    private int weight;\n\n    public Racket(String type, int size, int weight) {\n        this.type = type;\n        this.size = size;\n        this.weight = weight;\n    }\n // getters and setters omitted for brevity\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA TennisPlayer HAS-A Racket. Therefore, the TennisPlayer class must be capable of receiving a Racket as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class TennisPlayer {\n    private String name;\n    private Racket racket;\n    \n    public TennisPlayer(String name, Racket racket) {\n        this.name = name;\n        this.racket = racket\n }\n // getters and setters omitted for brevity\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, we create a Racket and a TennisPlayer that uses this Racket:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static void main(String[] args) {\n    Racket racket = new Racket(\u0026quot;Babolat Pure Aero\u0026quot;, 100, 300);\n    TennisPlayer player = new TennisPlayer(\u0026quot;Rafael Nadal\u0026quot;,  racket);\n    System.out.println(\u0026quot;Player \u0026quot; + player.getName() + \u0026quot; plays with \u0026quot; + player.getRacket().getType());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output is as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePlayer Rafael Nadal plays with Babolat Pure Aero\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e9. What is a Composition ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eComposition is one of the core concepts of OOP. Primarily, composition is a more restrictive case of aggregation. While aggregation represents a HAS-A relationship between two objects having their own life cycle, composition represents a HAS-A relationship that contains an object that cannot exist on its own. In order to highlight this coupling, the HAS-A relationship can be named PART-OF as well. For example, a Car has an Engine. In other words, the engine is PART-OF the car. If the car is destroyed, then the engine is destroyed as well. Composition is said to be better than inheritance because it sustains code reuse and the visibility control of objects.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Engine {\n    private String type;\n    private int horsepower;\n    public Engine(String type, int horsepower) {\n        this.type = type;\n        this.horsepower = horsepower;\n    }\n // getters and setters omitted for brevity\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, we have the Car class. Check out the constructor of this class. Since Engine is part of Car, we create it with the Car.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Car {\n    private final String name;\n    private final Engine engine;\n    \n    public Car(String name) {\n        this.name = name;\n        Engine engine = new Engine(\u0026quot;petrol\u0026quot;, 300);\n        this.engine=engine;\n    }\n\n    public int getHorsepower() {\n        return engine.getHorsepower();\n    }\n\n    public String getName() {\n        return name;\n    } \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewe can test composition from the main() method as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static void main(String[] args) {\n    Car car = new Car(\u0026quot;MyCar\u0026quot;);\n    System.out.println(\u0026quot;Horsepower: \u0026quot; + car.getHorsepower());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eoutput is as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eHorsepower: 300\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat\u0026rsquo;s it for OOPS.\u003c/p\u003e\n","url":"https://karthikselvam.com/posts/2023/01/25/oops_concepts/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"25016-25-09T10:2525:00+00:00","date_modified":"25016-25-09T10:2525:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"e6f6a613933a7c246b5ddb2c8d9fa5b114ca460a","title":"Understanding SOLID Principles","summary":"2023","content_text":"SOLID is an acronym of the following:\nS: Single Responsibility Principle O: Open Closed Principle L: Liskov\u0026rsquo;s Substitution Principle I: Interface Segregation Principle D: Dependency Inversion Principle 1. What is Single Responsibility Principle ?\nS stands for One class should have one, and only one, responsibility. S tells us to write a class for only one goal. As long as we write a class for only one goal, we will sustain high maintainability and visibility control across the application modules. In other words, by sustaining high maintainability, this principle has a significant business impact, and by providing visibility control across the application modules, this principle sustains encapsulation.\nFor example, the following class computes the area and converts it to inches:\npublic class RectangleAreaCalculator { private static final double INCH_TERM = 0.0254d; private final int width; private final int height; public RectangleAreaCalculator(int width, int height) { this.width = width; this.height = height; } public int area() { return width * height; } // this method breaks SRP public double metersToInches(int area) { return area / INCH_TERM; } } The situation can be remedied by removing the metersToInches() method from RectangleAreaCalculator, as follows:\npublic class RectangleAreaCalculator { private final int width; private final int height; public RectangleAreaCalculator(int width, int height) { this.width = width; this.height = height; } public int area() { return width * height; } } Now, RectangleAreaCalculator does only one thing (it computes the rectangle area), thereby observing the SRP.\nNext, metersToInches() can be extracted in a separate class.\npublic class AreaConverter { private static final double INCH_TERM = 0.0254d; private static final double FEET_TERM = 0.3048d; public double metersToInches(int area) { return area / INCH_TERM; } public double metersToFeet(int area) { return area / FEET_TERM; } } 2. What is Open Closed Principle ?\nO stands for Software components should be open for extension, but closed for modification. O sustains the fact that our classes should not contain constraints that will require other developers to modify our classes in order to accomplish their job – other developers should only extend our classes to accomplish their job.\nEach shape will implement the Shape interface. Therefore, the code is pretty straightforward:\npublic interface Shape { } public class Rectangle implements Shape { private final int width; rivate final int height; // constructor and getters omitted for brevity } public class Circle implements Shape { private final int radius; // constructor and getter omitted for brevity } At this point, we can easily use the constructors of these classes to create rectangles and circles of different sizes. Once we have several shapes, we want to sum their areas. For this, we can define an AreaCalculator class as follows:\npublic class AreaCalculator { private final List\u0026lt;Shape\u0026gt; shapes; public AreaCalculator(List\u0026lt;Shape\u0026gt; shapes) { this.shapes = shapes; } // adding more shapes requires us to modify this class // this code is not OCP compliant public double sum() { int sum = 0; for (Shape shape : shapes) { if (shape.getClass().equals(Circle.class)) { sum += Math.PI * Math.pow(((Circle) shape).getRadius(), 2); } else if(shape.getClass().equals(Rectangle.class)) { sum += ((Rectangle) shape).getHeight() * ((Rectangle) shape).getWidth(); } } return sum; } } Since each shape has its own formula for area, we require an if-else (or switch) structure to determine the type of shape. Furthermore, if we want to add a new shape (for example, a triangle), we have to modify the AreaCalculator class to add a new if case. This means that the preceding code breaks the OCP.\nThe main idea is to extract from AreaCalculator the area formula of each shape in the corresponding Shape class. Hence, the rectangle will compute its area, the circle as well, and so on. To enforce the fact that each shape must calculate its area, we add the area() method to the Shape contract:\npublic interface Shape { public double area(); } Next, Rectangle and Circle implements Shape as follows:\npublic class Rectangle implements Shape { private final int width; private final int height; public Rectangle(int width, int height) { this.width = width; this.height = height; } public double area() { return width * height; } } public class Circle implements Shape { private final int radius; public Circle(int radius) { this.radius = radius; } @Override public double area() { return Math.PI * Math.pow(radius, 2); } } Now, the AreaCalculator can loop the list of shapes and sum the areas by calling the proper area() method.\npublic class AreaCalculator { private final List\u0026lt;Shape\u0026gt; shapes; public AreaCalculator(List\u0026lt;Shape\u0026gt; shapes) { this.shapes = shapes; } public double sum() { int sum = 0; for (Shape shape : shapes) { sum += shape.area(); } return sum; } } 3. What is Liskov\u0026rsquo;s Substitution Principle ?\nL stands for Derived types must be completely substitutable for their base types. L sustains the fact that objects of subclasses must behave in the same way as the objects of superclasses, so every subclass (or derived class) should be capable of substituting their superclass without any issues. Most of the time, this is useful for runtime-type identification followed by the cast. For example, consider foo(p), where p is of the type T. Then, foo(q) should work fine if q is of the type S and S is a subtype of T.\nSuppose we have a class hierarchy for different shapes, with a base class Shape and two derived classes Circle and Rectangle. Each class has a method area() to calculate the area of the shape.\npublic abstract class Shape { public abstract double area(); } public class Circle extends Shape { private double radius; public Circle(double radius) { this.radius = radius; } @Override public double area() { return 3.14 * radius * radius; } } public class Rectangle extends Shape { private double length; private double width; public Rectangle(double length, double width) { this.length = length; this.width = width; } @Override public double area() { return length * width; } } Now suppose we have a method calculateTotalArea that takes an array of shapes and returns the total area of all the shapes in the array:\npublic static double calculateTotalArea(Shape[] shapes) { double totalArea = 0.0; for (Shape shape : shapes) { totalArea += shape.area(); } return totalArea; } According to Liskov\u0026rsquo;s Substitution Principle, we should be able to pass an array of Circle or Rectangle objects to this method without any problems, since both classes inherit from the Shape base class and implement the area() method.\nCircle circle = new Circle(5); Rectangle rectangle = new Rectangle(3, 4); Shape[] shapes = {circle, rectangle}; double totalArea = calculateTotalArea(shapes); // returns 83.5 This demonstrates that the Circle and Rectangle classes can be used interchangeably with the Shape class, without causing any errors or unexpected behavior in the program.\n4. What is Interface Segregation Principle ?\nI stands for the Interface Segregation Principle (ISP). I stands for Clients should not be forced to implement unnecessary methods that they will not use.\nThis principle stands for Clients should not be forced to implement unnecessary methods that they will not use. In other words, we should split an interface into two or more interfaces until clients are not forced to implement methods that they will not use. For example, consider the Connection interface, which has three methods: connect(), socket(), and http().\npublic interface Connection { public void socket(); public void http(); public void connect(); } WwwPingConnection is a class that pings different websites via HTTP; hence, it requires the http() method, but doesn\u0026rsquo;t need the socket() method. Notice the dummy socket() implementation – since WwwPingConnection implements Connection, it is forced to provide an implementation to the socket() method as well:\npublic class WwwPingConnection implements Connection { private final String www; public WwwPingConnection(String www) { this.www = www; } @Override public void http() { System.out.println(\u0026quot;Setup an HTTP connection to \u0026quot; + www); } @Override public void connect() { System.out.println(\u0026quot;Connect to \u0026quot; + www); } // this method breaks Interface Segregation Principle @Override public void socket() { } } Having an empty implementation or throwing a meaningful exception from methods that are not needed, such as socket(), is a really ugly solution. Check the following code:\nWwwPingConnection www = new WwwPingConnection 'www.yahoo.com'); www.socket(); // we can call this method! www.connect(); What do we expect to obtain from this code? A working code that does nothing, or an exception caused by the connect() method because there is no HTTP endpoint? Or, we can throw an exception from socket() of the type: Socket is not supported!. Then, why is it here?! Hence, it is now time to refactor the code to follow the ISP. In order to comply with the ISP, we need to segregate the Connection interface. Since the connect() method is required by any client, we leave it in this interface.\npublic interface Connection { public void connect(); } The http() and socket() methods are distributed in to separate interfaces that extend the Connection interface as follows:\npublic interface HttpConnection extends Connection { public void http(); } public interface SocketConnection extends Connection { public void socket(); } This time, the WwwPingConnection class can implement only the HttpConnection interface and use the http() method:\npublic class WwwPingConnection implements HttpConnection { private final String www; public WwwPingConnection(String www) { this.www = www; } @Override public void http() { System.out.println(\u0026quot;Setup an HTTP connection to \u0026quot; + www); } @Override public void connect() { System.out.println(\u0026quot;Connect to \u0026quot; + www); } } 5. What is Dependency Inversion Principle ?\nD stands for the Dependency Inversion Principle. This principle stands for Depend on abstractions, not on concretions. This means that we should rely on abstract layers to bind concrete modules together instead of having concrete modules that depend on other concrete modules. To accomplish this, all concrete modules should expose abstractions only.\nA database JDBC URL, PostgreSQLJdbcUrl, can be a low-level module, while a class that connects to the database may represent a high-level module, such as ConnectToDatabase#connect().\npublic class PostgreSQLJdbcUrl { private final String dbName; public PostgreSQLJdbcUrl(String dbName) { this.dbName = dbName; } public String get() { return \u0026quot;jdbc:// ... \u0026quot; + this.dbName; } } public class ConnectToDatabase { public void connect(PostgreSQLJdbcUrl postgresql) { System.out.println(\u0026quot;Connecting to \u0026quot; + postgresql.get()); } } If we create another type of JDBC URL (for example, MySQLJdbcUrl), then we cannot use the preceding connect(PostgreSQLJdbcUrl postgreSQL) method. So, we have to drop this dependency on concrete and create a dependency on abstraction.\nThe abstraction can be represented by an interface that should be implemented by each type of JDBC URL\npublic interface JdbcUrl { public String get(); } Next, PostgreSQLJdbcUrl implements JdbcUrl to return a JDBC URL specific to PostgreSQL databases:\npublic class PostgreSQLJdbcUrl implements JdbcUrl { private final String dbName; public PostgreSQLJdbcUrl(String dbName) { this.dbName = dbName; } @Override public String get() { return \u0026quot;jdbc:// ... \u0026quot; + this.dbName; } } In precisely the same manner, we can write MySQLJdbcUrl, OracleJdbcUrl, and so on. Finally, the ConnectToDatabase#connect() method is dependent on the JdbcUrl abstraction, so it can connect to any JDBC URL that implements this abstraction.\npublic class ConnectToDatabase { public void connect(JdbcUrl jdbcUrl) { System.out.println(\u0026quot;Connecting to \u0026quot; + jdbcUrl.get()); } } That\u0026rsquo;s it, now you have solid understanding of SOLID principles.\n","content_html":"\u003cp\u003eSOLID is an acronym of the following:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eS: Single Responsibility Principle\u003c/li\u003e\n\u003cli\u003eO: Open Closed Principle\u003c/li\u003e\n\u003cli\u003eL: Liskov\u0026rsquo;s Substitution Principle\u003c/li\u003e\n\u003cli\u003eI: Interface Segregation Principle\u003c/li\u003e\n\u003cli\u003eD: Dependency Inversion Principle\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e1. What is Single Responsibility Principle ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eS stands for One class should have one, and only one, responsibility. S tells us to write a class for only one goal. As long as we write a class for only one goal, we will sustain high maintainability and visibility control across the application modules. In other words, by sustaining high maintainability, this principle has a significant business impact, and by providing visibility control across the application modules, this principle sustains encapsulation.\u003c/p\u003e\n\u003cp\u003eFor example, the following class computes the area and converts it to inches:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class RectangleAreaCalculator {\n    private static final double INCH_TERM = 0.0254d;\n    private final int width;\n    private final int height;\n    \n    public RectangleAreaCalculator(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n    \n    public int area() {\n        return width * height;\n    }\n    \n    // this method breaks SRP\n    public double metersToInches(int area) {\n        return area / INCH_TERM;\n    } \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe situation can be remedied by removing the metersToInches() method from RectangleAreaCalculator, as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class RectangleAreaCalculator {\n    private final int width;\n    private final int height;\n    \n    public RectangleAreaCalculator(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n \n    public int area() {\n        return width * height;\n    } \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, RectangleAreaCalculator does only one thing (it computes the rectangle area), thereby observing the SRP.\u003c/p\u003e\n\u003cp\u003eNext, metersToInches() can be extracted in a separate class.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class AreaConverter {\n    private static final double INCH_TERM = 0.0254d;\n    private static final double FEET_TERM = 0.3048d;\n    \n    public double metersToInches(int area) {\n        return area / INCH_TERM;\n    }\n    \n    public double metersToFeet(int area) {\n        return area / FEET_TERM;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e2. What is Open Closed Principle ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eO stands for Software components should be open for extension, but closed for modification. O sustains the fact that our classes should not contain constraints that will require other developers to modify our classes in order to accomplish their job – other developers should only extend our classes to accomplish their job.\u003c/p\u003e\n\u003cp\u003eEach shape will implement the Shape interface. Therefore, the code is pretty straightforward:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public interface Shape { \n    }\n    \n    public class Rectangle implements Shape {\n        private final int width;\n        rivate final int height;\n        // constructor and getters omitted for brevity\n    }\n    \n    public class Circle implements Shape {\n        private final int radius;\n        // constructor and getter omitted for brevity\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAt this point, we can easily use the constructors of these classes to create rectangles and circles of different sizes. Once we have several shapes, we want to sum their areas. For this, we can define an AreaCalculator class as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public class AreaCalculator {\n        private final List\u0026lt;Shape\u0026gt; shapes;\n        public AreaCalculator(List\u0026lt;Shape\u0026gt; shapes) {\n            this.shapes = shapes;\n    }\n \n    // adding more shapes requires us to modify this class\n    // this code is not OCP compliant\n    public double sum() {\n        int sum = 0;\n        for (Shape shape : shapes) {\n            if (shape.getClass().equals(Circle.class)) {\n                sum += Math.PI * Math.pow(((Circle) shape).getRadius(), 2);\n            } else \n            if(shape.getClass().equals(Rectangle.class)) {\n                sum += ((Rectangle) shape).getHeight() * ((Rectangle) shape).getWidth();\n            }\n        }\n        return sum;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSince each shape has its own formula for area, we require an if-else (or switch) structure to determine the type of shape. Furthermore, if we want to add a new shape (for example, a triangle), we have to modify the AreaCalculator class to add a new if case. This means that the preceding code breaks the OCP.\u003c/p\u003e\n\u003cp\u003eThe main idea is to extract from AreaCalculator the area formula of each shape in the corresponding Shape class. Hence, the rectangle will compute its area, the circle as well, and so on. To enforce the fact that each shape must calculate its area, we add the area() method to the Shape contract:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface Shape { \n    public double area();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, Rectangle and Circle implements Shape as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e public class Rectangle implements Shape {\n    private final int width;\n    private final int height;\n\n public Rectangle(int width, int height) {\n    this.width = width;\n    this.height = height;\n }\n\n  public double area() {\n    return width * height;\n }\n}\n\npublic class Circle implements Shape {\n    private final int radius;\n    public Circle(int radius) {\n        this.radius = radius;\n    }\n \n    @Override\n    public double area() {\n        return Math.PI * Math.pow(radius, 2);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, the AreaCalculator can loop the list of shapes and sum the areas by calling the  proper area() method.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class AreaCalculator {\n    private final List\u0026lt;Shape\u0026gt; shapes;\n    public AreaCalculator(List\u0026lt;Shape\u0026gt; shapes) {\n        this.shapes = shapes;\n    }\n\n     public double sum() {\n        int sum = 0;\n        for (Shape shape : shapes) {\n            sum += shape.area();\n        }\n        return sum;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e3. What is Liskov\u0026rsquo;s Substitution Principle ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eL stands for Derived types must be completely substitutable for their base types. L sustains the fact that objects of subclasses must behave in the same way as the objects of superclasses, so every subclass (or derived class) should be capable of substituting their superclass without any issues. Most of the time, this is useful for runtime-type identification followed by the cast. For example, consider foo(p), where p is of the type T. Then, foo(q) should work fine if q is of the type S and S is a subtype of T.\u003c/p\u003e\n\u003cp\u003eSuppose we have a class hierarchy for different shapes, with a base class Shape and two derived classes Circle and Rectangle. Each class has a method area() to calculate the area of the shape.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic abstract class Shape {\n    public abstract double area();\n}\n\npublic class Circle extends Shape {\n    private double radius;\n\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n\n    @Override\n    public double area() {\n        return 3.14 * radius * radius;\n    }\n}\n\npublic class Rectangle extends Shape {\n    private double length;\n    private double width;\n\n    public Rectangle(double length, double width) {\n        this.length = length;\n        this.width = width;\n    }\n\n    @Override\n    public double area() {\n        return length * width;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow suppose we have a method calculateTotalArea that takes an array of shapes and returns the total area of all the shapes in the array:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epublic static double calculateTotalArea(Shape[] shapes) {\n    double totalArea = 0.0;\n    for (Shape shape : shapes) {\n        totalArea += shape.area();\n    }\n    return totalArea;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAccording to Liskov\u0026rsquo;s Substitution Principle, we should be able to pass an array of Circle or Rectangle objects to this method without any problems, since both classes inherit from the Shape base class and implement the area() method.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCircle circle = new Circle(5);\nRectangle rectangle = new Rectangle(3, 4);\nShape[] shapes = {circle, rectangle};\ndouble totalArea = calculateTotalArea(shapes); // returns 83.5\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis demonstrates that the Circle and Rectangle classes can be used interchangeably with the Shape class, without causing any errors or unexpected behavior in the program.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e4. What is Interface Segregation Principle ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI stands for the Interface Segregation Principle (ISP). I stands for Clients should not be forced to implement unnecessary methods that they will not use.\u003c/p\u003e\n\u003cp\u003eThis principle stands for Clients should not be forced to implement unnecessary methods that they will not use. In other words, we should split an interface into two or more interfaces until clients are not forced to implement methods that they will not use. For example, consider the Connection interface, which has three methods: connect(), socket(), and http().\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface Connection {\n    public void socket();\n    public void http();\n    public void connect();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWwwPingConnection is a class that pings different websites via HTTP; hence, it requires the http() method, but doesn\u0026rsquo;t need the socket() method. Notice the dummy socket() implementation – since WwwPingConnection implements Connection, it is forced to provide an implementation to the socket() method as well:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class WwwPingConnection implements Connection {\n    private final String www;\n\n    public WwwPingConnection(String www) {\n        this.www = www;\n    }\n\n    @Override\n    public void http() {\n        System.out.println(\u0026quot;Setup an HTTP connection to \u0026quot; + www);\n    }\n\n    @Override\n    public void connect() {\n    System.out.println(\u0026quot;Connect to \u0026quot; + www);\n    }\n\n    // this method breaks Interface Segregation Principle\n    @Override\n    public void socket() {\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHaving an empty implementation or throwing a meaningful exception from methods that are not needed, such as socket(), is a really ugly solution. Check the following code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eWwwPingConnection www = new WwwPingConnection 'www.yahoo.com');\nwww.socket(); // we can call this method!\nwww.connect();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhat do we expect to obtain from this code? A working code that does nothing, or an  exception caused by the connect() method because there is no HTTP endpoint? Or, we  can throw an exception from socket() of the type: Socket is not supported!. Then, why is  it here?! Hence, it is now time to refactor the code to follow the ISP. In order to comply with the ISP, we need to segregate the Connection interface. Since the connect() method is required by any client, we leave it in this interface.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface Connection {\n    public void connect();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe http() and socket() methods are distributed in to separate interfaces that extend the Connection interface as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface HttpConnection extends Connection {\n    public void http();\n    }\npublic interface SocketConnection extends Connection {\n    public void socket();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis time, the WwwPingConnection class can implement only the HttpConnection interface and use the http() method:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class WwwPingConnection implements HttpConnection {\n    private final String www;\n    \n    public WwwPingConnection(String www) {\n        this.www = www;\n    }\n\n    @Override\n    public void http() {\n        System.out.println(\u0026quot;Setup an HTTP connection to \u0026quot; + www);\n    }\n \n    @Override\n    public void connect() {\n        System.out.println(\u0026quot;Connect to \u0026quot; + www);\n    } \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e5. What is Dependency Inversion Principle ?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eD stands for the Dependency Inversion Principle. This principle stands for Depend on abstractions, not on concretions. This means that we should rely on abstract layers to bind concrete modules together instead of having concrete modules that depend on other concrete modules. To accomplish this, all concrete modules should expose abstractions only.\u003c/p\u003e\n\u003cp\u003eA database JDBC URL, PostgreSQLJdbcUrl, can be a low-level module, while a class that connects to the database may represent a high-level module, such as ConnectToDatabase#connect().\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class PostgreSQLJdbcUrl {\n    private final String dbName;\n    public PostgreSQLJdbcUrl(String dbName) {\n        this.dbName = dbName;\n    }\n    public String get() {\n        return \u0026quot;jdbc:// ... \u0026quot; + this.dbName;\n    }\n}\n\npublic class ConnectToDatabase {\n    public void connect(PostgreSQLJdbcUrl postgresql) {\n        System.out.println(\u0026quot;Connecting to \u0026quot; + postgresql.get());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf we create another type of JDBC URL (for example, MySQLJdbcUrl), then we cannot use the preceding connect(PostgreSQLJdbcUrl postgreSQL) method. So, we have to drop this dependency on concrete and create a dependency on abstraction.\u003c/p\u003e\n\u003cp\u003eThe abstraction can be represented by an interface that should be implemented by each type of JDBC URL\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epublic interface JdbcUrl {\n    public String get();\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, PostgreSQLJdbcUrl implements JdbcUrl to return a JDBC URL specific to PostgreSQL databases:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class PostgreSQLJdbcUrl implements JdbcUrl {\n    private final String dbName;\n\n    public PostgreSQLJdbcUrl(String dbName) {\n        this.dbName = dbName;\n    }\n\n    @Override\n    public String get() {\n        return \u0026quot;jdbc:// ... \u0026quot; + this.dbName;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn precisely the same manner, we can write MySQLJdbcUrl, OracleJdbcUrl, and so on. Finally, the ConnectToDatabase#connect() method is dependent on the JdbcUrl abstraction, so it can connect to any JDBC URL that implements this abstraction.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class ConnectToDatabase {\n    public void connect(JdbcUrl jdbcUrl) {\n        System.out.println(\u0026quot;Connecting to \u0026quot; + jdbcUrl.get());\n }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat\u0026rsquo;s it, now you have solid understanding of SOLID principles.\u003c/p\u003e\n","url":"https://karthikselvam.com/posts/2023/01/24/solid_principles/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"24016-24-09T10:2424:00+00:00","date_modified":"24016-24-09T10:2424:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"f93c2630ca6d4f877c59381b8194f7b149817da2","title":"Builder Design Pattern Practice Qestions","summary":"2023","content_text":"Exercise 1: Basic Builder Implementation Objective: Implement a basic builder. Steps: Create a House class with attributes walls, roof, and windows. Create a HouseBuilder class with methods to set the attributes of House. Implement a build() method in HouseBuilder that returns a House instance. Demonstrate building a House object using HouseBuilder.\nExercise 2: Fluent Builder Interface Objective: Implement a builder with a fluent interface. Steps: Create a Car class with attributes engine, wheels, and color. Create a CarBuilder class with methods to set the attributes of Car. Implement the methods in CarBuilder to return the builder itself for method chaining. Demonstrate building a Car object using the fluent interface.\nExercise 3: Director in Builder Pattern Objective: Use a director to manage the construction process. Steps: Create a Computer class with attributes CPU, RAM, storage, and graphicsCard. Create a ComputerBuilder class with methods to set the attributes of Computer. Create a Director class with methods to construct different types of computers (e.g., gaming computer, office computer). Demonstrate building different types of computers using the Director.\nExercise 4: Immutable Objects with Builder Pattern Objective: Implement the builder pattern for creating immutable objects. Steps: Create an immutable Person class with attributes firstName, lastName, age, and address. Create a PersonBuilder class to set the attributes of Person. Ensure the Person class has private final fields and no setters. Demonstrate creating a Person object using PersonBuilder.\nExercise 5: Nested Builders Objective: Implement nested builders for complex objects. Steps: Create a House class with an inner class Garden and attributes walls, roof, and garden. Create a HouseBuilder class with methods to set the attributes of House. Create a nested GardenBuilder class inside HouseBuilder to build the Garden object. Demonstrate building a House object with a nested Garden using the builders.\nExercise 6: Copy Builder Objective: Implement a builder that can copy attributes from an existing object. Steps: Create a Book class with attributes title, author, pages, and publisher. Create a BookBuilder class with methods to set the attributes of Book. Implement a method from(Book book) in BookBuilder that copies the attributes from an existing Book object. Demonstrate creating a new Book object by copying attributes from an existing Book using BookBuilder.\nExercise 7: Builder Pattern with Inheritance Objective: Implement the builder pattern with inheritance. Steps: Create a base class Employee with attributes name and employeeId. Create a derived class Manager with an additional attribute department. Create a builder EmployeeBuilder to build Employee objects. Create a builder ManagerBuilder that extends EmployeeBuilder to build Manager objects. Demonstrate building Employee and Manager objects using their respective builders.\n","content_html":"\u003cp\u003eExercise 1: Basic Builder Implementation\nObjective: Implement a basic builder.\nSteps:\nCreate a House class with attributes walls, roof, and windows.\nCreate a HouseBuilder class with methods to set the attributes of House.\nImplement a build() method in HouseBuilder that returns a House instance.\nDemonstrate building a House object using HouseBuilder.\u003c/p\u003e\n\u003cp\u003eExercise 2: Fluent Builder Interface\nObjective: Implement a builder with a fluent interface.\nSteps:\nCreate a Car class with attributes engine, wheels, and color.\nCreate a CarBuilder class with methods to set the attributes of Car.\nImplement the methods in CarBuilder to return the builder itself for method chaining.\nDemonstrate building a Car object using the fluent interface.\u003c/p\u003e\n\u003cp\u003eExercise 3: Director in Builder Pattern\nObjective: Use a director to manage the construction process.\nSteps:\nCreate a Computer class with attributes CPU, RAM, storage, and graphicsCard.\nCreate a ComputerBuilder class with methods to set the attributes of Computer.\nCreate a Director class with methods to construct different types of computers (e.g., gaming computer, office computer).\nDemonstrate building different types of computers using the Director.\u003c/p\u003e\n\u003cp\u003eExercise 4: Immutable Objects with Builder Pattern\nObjective: Implement the builder pattern for creating immutable objects.\nSteps:\nCreate an immutable Person class with attributes firstName, lastName, age, and address.\nCreate a PersonBuilder class to set the attributes of Person.\nEnsure the Person class has private final fields and no setters.\nDemonstrate creating a Person object using PersonBuilder.\u003c/p\u003e\n\u003cp\u003eExercise 5: Nested Builders\nObjective: Implement nested builders for complex objects.\nSteps:\nCreate a House class with an inner class Garden and attributes walls, roof, and garden.\nCreate a HouseBuilder class with methods to set the attributes of House.\nCreate a nested GardenBuilder class inside HouseBuilder to build the Garden object.\nDemonstrate building a House object with a nested Garden using the builders.\u003c/p\u003e\n\u003cp\u003eExercise 6: Copy Builder\nObjective: Implement a builder that can copy attributes from an existing object.\nSteps:\nCreate a Book class with attributes title, author, pages, and publisher.\nCreate a BookBuilder class with methods to set the attributes of Book.\nImplement a method from(Book book) in BookBuilder that copies the attributes from an existing Book object.\nDemonstrate creating a new Book object by copying attributes from an existing Book using BookBuilder.\u003c/p\u003e\n\u003cp\u003eExercise 7: Builder Pattern with Inheritance\nObjective: Implement the builder pattern with inheritance.\nSteps:\nCreate a base class Employee with attributes name and employeeId.\nCreate a derived class Manager with an additional attribute department.\nCreate a builder EmployeeBuilder to build Employee objects.\nCreate a builder ManagerBuilder that extends EmployeeBuilder to build Manager objects.\nDemonstrate building Employee and Manager objects using their respective builders.\u003c/p\u003e\n","url":"https://karthikselvam.com/posts/2023/01/23/builder_pattern/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"23016-23-09T10:2323:00+00:00","date_modified":"23016-23-09T10:2323:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"cd31544a69cbb5c629dff9b7ba853f94a9fcbd76","title":"Capacity Estimation on the fly","summary":"2023","content_text":"Capacity estimation is a crucial component of system design interviews, and it can be quite challenging if one is not adequately prepared. However, with the right approach, it is possible to accurately estimate the storage, bandwidth, and memory/cache requirements needed for a particular system. This article provides a comprehensive framework for capacity estimation, which will enable you to confidently tackle capacity-related questions during system design interviews.\nTypically following estimates are required :\nStorage Bandwidth Memory/Cache Assumptions:\n1. Storage Estimates\nSingle character requires 2 bytes, while long and double require 8 bytes of space. An average photo takes up 200 KB of space, while a high-quality photo takes up 2 MB of space. For videos, we assume 50 MB of space per minute of video. Examples:\nSocial media: tweet can be assumed 140 char then 140*2 bytes = 280 bytes tweet. Tiny URL: Average URL length \u0026lt;100 char. Longer URLs needing tiny URL will generally be more than 150 char, lets say 200 char. then each URL assume as 200*2 = 400 bytes Database id or price etc field can be double or long so 8 bytes per field. 2. Traffic estimates\nFor social media applications like Facebook, Instagram, Twitter we can assume 1 billion total users, with 500 million daily active users. A chat application like WhatsApp, and Facebook Messenger, has 500 million total users, with 100 million daily active users. For video streaming applications like YouTube, Netflix, and Hulu, we can assume 1 billion total users, with 800 million daily active users. For cloud or file storage applications like Google Drive, Dropbox, and Microsoft OneDrive, we can assume 1 billion total users, with 500 million daily active users. 3. Time Assumptions\nA year has 365 days, so 5 years have 1825 days, which we round up to 2000 days. A day has 24 hours, which is 86400 seconds, which we round up to 100,000 seconds. Capacity Estimation for Social Media application\nAssuming each post or tweet has 140 characters, and each character requires 2 bytes, each tweet or post has a size of approximately 300 bytes. Let’s assume 1 billion total users and 500 million daily active users, we can assume that 10 million users post photos daily, with an average size of 200 KB. Using these assumptions, we can calculate the following:\nStorage: Text data storage: 300 bytes x 500,000,000 = 150,000,000,000 = 150 GB of tweet/post data per day Photo storage: 200 KB x 10,000,000 = 2,000 GB = 2 TB per day.\nTotal storage for 5 years: 150 GB x 2000 days = 300,000 GB = 300 TB for tweet/post data, and 2 TB x 2000 days = 4,000 TB for photos.\nBandwidth: Text data bandwidth: 150 GB per day / 100,000 seconds = 1.5 MB per second Photo bandwidth: 2 TB per day / 100,000 seconds = 200 MB per second\nMemory/Cache: Assuming we want to cache 20 posts/tweets per user, 300 bytes * 500,000,000 daily users * 20 = 150 GB * 20 = 3000 GB = 3 TB of cache. If one machine/server can keep 150 GB of cache, we need 20 machines/servers for caching.\nCapacity Estimation for TinyURL\nAssuming the average length of a URL is 100 characters, and each character requires 2 bytes, each URL has a size of approximately 200 bytes. Let’s assume 1 billion total users, 100 million daily active users. So 100 million urls are generated per day. Using these assumptions, we can calculate the following:\nStorage: URL data storage: 200 bytes x 100,000,000 = 20,000,000,000 = 20 GB per day\nTotal storage for 5 years: 20 GB per day x 2000 days = 40,000 GB = 40 TB\nBandwidth: URL bandwidth: 20 GB per day / 100,000 seconds = 0.2 MB per second.\nMemory/Cache: Assuming we want to cache 20 urls per user, 200 bytes * 100,000,000 daily users * 20 = 20 GB * 20 = 400 GB of cache. If one machine/server can keep 150 GB of cache, we need 3 machines/servers for caching.\nThe framework outlined above provides a clear approach to tackle capacity estimation problems during interviews.\n","content_html":"\u003cp\u003eCapacity estimation is a crucial component of system design interviews, and it can be quite challenging if one is not adequately prepared. However, with the right approach, it is possible to accurately estimate the storage, bandwidth, and memory/cache requirements needed for a particular system. This article provides a comprehensive framework for capacity estimation, which will enable you to confidently tackle capacity-related questions during system design interviews.\u003c/p\u003e\n\u003cp\u003eTypically following estimates are required :\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eStorage\u003c/li\u003e\n\u003cli\u003eBandwidth\u003c/li\u003e\n\u003cli\u003eMemory/Cache\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003cp\u003eAssumptions:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. Storage Estimates\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSingle character requires 2 bytes, while long and double require 8 bytes of space.\u003c/li\u003e\n\u003cli\u003eAn average photo takes up 200 KB of space, while a high-quality photo takes up 2 MB of space.\u003c/li\u003e\n\u003cli\u003eFor videos, we assume 50 MB of space per minute of video.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eExamples:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSocial media: tweet can be assumed 140 char then 140*2 bytes = 280 bytes tweet.\u003c/li\u003e\n\u003cli\u003eTiny URL: Average URL length \u0026lt;100 char. Longer URLs needing tiny URL will generally be more than 150 char, lets say 200 char. then each URL assume as 200*2 = 400 bytes\u003c/li\u003e\n\u003cli\u003eDatabase id or price etc field can be double or long so 8 bytes per field.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e2. Traffic estimates\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFor social media applications like Facebook, Instagram, Twitter we can assume 1 billion total users, with 500 million daily active users.\u003c/li\u003e\n\u003cli\u003eA chat application like WhatsApp, and Facebook Messenger, has 500 million total users, with 100 million daily active users.\u003c/li\u003e\n\u003cli\u003eFor video streaming applications like YouTube, Netflix, and Hulu, we can assume 1 billion total users, with 800 million daily active users.\u003c/li\u003e\n\u003cli\u003eFor cloud or file storage applications like Google Drive, Dropbox, and Microsoft OneDrive, we can assume 1 billion total users, with 500 million daily active users.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e3. Time Assumptions\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA year has 365 days, so 5 years have 1825 days, which we round up to 2000 days.\u003c/li\u003e\n\u003cli\u003eA day has 24 hours, which is 86400 seconds, which we round up to 100,000 seconds.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003eCapacity Estimation for Social Media application\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAssuming each post or tweet has 140 characters, and each character requires 2 bytes, each tweet or post has a size of approximately 300 bytes. Let’s assume 1 billion total users and 500 million daily active users, we can assume that 10 million users post photos daily, with an average size of 200 KB. Using these assumptions, we can calculate the following:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eStorage\u003c/strong\u003e:\nText data storage: 300 bytes x 500,000,000 = 150,000,000,000 = 150 GB of tweet/post data per day\nPhoto storage: 200 KB x 10,000,000 = 2,000 GB = 2 TB per day.\u003c/p\u003e\n\u003cp\u003eTotal storage for 5 years: 150 GB x 2000 days = 300,000 GB = 300 TB for tweet/post data, and 2 TB x 2000 days = 4,000 TB for photos.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBandwidth\u003c/strong\u003e:\nText data bandwidth: 150 GB per day / 100,000 seconds = 1.5 MB per second\nPhoto bandwidth: 2 TB per day / 100,000 seconds = 200 MB per second\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eMemory/Cache\u003c/strong\u003e:\nAssuming we want to cache 20 posts/tweets per user, 300 bytes * 500,000,000 daily users * 20 = 150 GB * 20 = 3000 GB = 3 TB of cache. If one machine/server can keep 150 GB of cache, we need 20 machines/servers for caching.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003eCapacity Estimation for TinyURL\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAssuming the average length of a URL is 100 characters, and each character requires 2 bytes, each URL has a size of approximately 200 bytes. Let’s assume 1 billion total users, 100 million daily active users. So 100 million urls are generated per day. Using these assumptions, we can calculate the following:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eStorage\u003c/strong\u003e:\nURL data storage: 200 bytes x 100,000,000 = 20,000,000,000 = 20 GB per day\u003c/p\u003e\n\u003cp\u003eTotal storage for 5 years: 20 GB per day x 2000 days = 40,000 GB = 40 TB\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBandwidth\u003c/strong\u003e:\nURL bandwidth: 20 GB per day / 100,000 seconds = 0.2 MB per second.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eMemory/Cache\u003c/strong\u003e:\nAssuming we want to cache 20 urls per user, 200 bytes * 100,000,000 daily users * 20 = 20 GB * 20 = 400 GB of cache. If one machine/server can keep 150 GB of cache, we need 3 machines/servers for caching.\u003c/p\u003e\n\u003cp\u003eThe framework outlined above provides a clear approach to tackle capacity estimation problems during interviews.\u003c/p\u003e\n","url":"https://karthikselvam.com/posts/2023/01/23/capacity_estimation/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"23016-23-09T10:2323:00+00:00","date_modified":"23016-23-09T10:2323:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"1b4453e98a41d912704e53a5808c4527c918f004","title":"Factory Design Pattern Practice Qestions","summary":"2023","content_text":"Exercise 1: Simple Factory Objective: Implement a simple factory. Steps: Create a Shape interface with a method draw(). Implement concrete classes Circle, Square, and Rectangle that implement Shape. Create a ShapeFactory class with a method getShape(String shapeType) that returns an instance of a specific shape. Demonstrate using ShapeFactory to create and use different shapes.\nExercise 2: Factory Method Objective: Implement the Factory Method pattern. Steps: Create a Product interface with a method use(). Implement concrete classes ConcreteProductA and ConcreteProductB that implement Product. Create an abstract class Creator with an abstract method createProduct(). Implement concrete creators ConcreteCreatorA and ConcreteCreatorB that extend Creator and implement the createProduct() method. Demonstrate using different creators to create and use products.\nExercise 3: Abstract Factory Objective: Implement the Abstract Factory pattern. Steps: Create an interface GUIFactory with methods createButton() and createCheckbox(). Implement concrete factories WindowsFactory and MacFactory that implement GUIFactory. Create interfaces Button and Checkbox with a method render(). Implement concrete classes WindowsButton, MacButton, WindowsCheckbox, and MacCheckbox that implement Button and Checkbox. Demonstrate creating different GUIs using the abstract factory.\nExercise 4: Parameterized Factory Objective: Implement a factory with parameterized creation. Steps: Create a Vehicle interface with a method drive(). Implement concrete classes Car, Bike, and Truck that implement Vehicle. Create a VehicleFactory class with a method getVehicle(String vehicleType, String color, int horsepower) that returns an instance of a specific vehicle with given parameters. Demonstrate creating and using vehicles with different parameters.\nExercise 5: Factory with Registry Objective: Implement a factory with a registry for product creation. Steps: Create an Animal interface with a method speak(). Implement concrete classes Dog, Cat, and Bird that implement Animal. Create an AnimalFactory class with a registry to map string types to animal constructors. Add methods to AnimalFactory to register and create animals based on string types. Demonstrate registering and creating different animals using the factory.\nExercise 6: Singleton Factory Objective: Combine Singleton and Factory patterns. Steps: Create a Connection interface with a method connect(). Implement concrete classes MySQLConnection and PostgreSQLConnection that implement Connection. Create a singleton ConnectionFactory with a method getConnection(String type) that returns a specific connection instance. Demonstrate using the singleton factory to create and use different connections.\nExercise 7: Reflection-Based Factory Objective: Use reflection to create objects in a factory. Steps: Create an Appliance interface with a method operate(). Implement concrete classes Washer and Dryer that implement Appliance. Create an ApplianceFactory class with a method getAppliance(Class\u0026lt;? extends Appliance\u0026gt; applianceClass) that uses reflection to create instances. Demonstrate creating and using appliances with the reflection-based factory.\n","content_html":"\u003cp\u003eExercise 1: Simple Factory\nObjective: Implement a simple factory.\nSteps:\nCreate a Shape interface with a method draw().\nImplement concrete classes Circle, Square, and Rectangle that implement Shape.\nCreate a ShapeFactory class with a method getShape(String shapeType) that returns an instance of a specific shape.\nDemonstrate using ShapeFactory to create and use different shapes.\u003c/p\u003e\n\u003cp\u003eExercise 2: Factory Method\nObjective: Implement the Factory Method pattern.\nSteps:\nCreate a Product interface with a method use().\nImplement concrete classes ConcreteProductA and ConcreteProductB that implement Product.\nCreate an abstract class Creator with an abstract method createProduct().\nImplement concrete creators ConcreteCreatorA and ConcreteCreatorB that extend Creator and implement the createProduct() method.\nDemonstrate using different creators to create and use products.\u003c/p\u003e\n\u003cp\u003eExercise 3: Abstract Factory\nObjective: Implement the Abstract Factory pattern.\nSteps:\nCreate an interface GUIFactory with methods createButton() and createCheckbox().\nImplement concrete factories WindowsFactory and MacFactory that implement GUIFactory.\nCreate interfaces Button and Checkbox with a method render().\nImplement concrete classes WindowsButton, MacButton, WindowsCheckbox, and MacCheckbox that implement Button and Checkbox.\nDemonstrate creating different GUIs using the abstract factory.\u003c/p\u003e\n\u003cp\u003eExercise 4: Parameterized Factory\nObjective: Implement a factory with parameterized creation.\nSteps:\nCreate a Vehicle interface with a method drive().\nImplement concrete classes Car, Bike, and Truck that implement Vehicle.\nCreate a VehicleFactory class with a method getVehicle(String vehicleType, String color, int horsepower) that returns an instance of a specific vehicle with given parameters.\nDemonstrate creating and using vehicles with different parameters.\u003c/p\u003e\n\u003cp\u003eExercise 5: Factory with Registry\nObjective: Implement a factory with a registry for product creation.\nSteps:\nCreate an Animal interface with a method speak().\nImplement concrete classes Dog, Cat, and Bird that implement Animal.\nCreate an AnimalFactory class with a registry to map string types to animal constructors.\nAdd methods to AnimalFactory to register and create animals based on string types.\nDemonstrate registering and creating different animals using the factory.\u003c/p\u003e\n\u003cp\u003eExercise 6: Singleton Factory\nObjective: Combine Singleton and Factory patterns.\nSteps:\nCreate a Connection interface with a method connect().\nImplement concrete classes MySQLConnection and PostgreSQLConnection that implement Connection.\nCreate a singleton ConnectionFactory with a method getConnection(String type) that returns a specific connection instance.\nDemonstrate using the singleton factory to create and use different connections.\u003c/p\u003e\n\u003cp\u003eExercise 7: Reflection-Based Factory\nObjective: Use reflection to create objects in a factory.\nSteps:\nCreate an Appliance interface with a method operate().\nImplement concrete classes Washer and Dryer that implement Appliance.\nCreate an ApplianceFactory class with a method getAppliance(Class\u0026lt;? extends Appliance\u0026gt; applianceClass) that uses reflection to create instances.\nDemonstrate creating and using appliances with the reflection-based factory.\u003c/p\u003e\n","url":"https://karthikselvam.com/posts/2023/01/23/factory_pattern/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"23016-23-09T10:2323:00+00:00","date_modified":"23016-23-09T10:2323:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"0d76f1d072960250b22ed281f11c16b9618e7027","title":"Fundamentals of Multithreading","summary":"2023","content_text":"1. Thread creation : In Java, you can create a thread by either extending the Thread class or implementing the Runnable interface. Here\u0026rsquo;s how you can do it:\nExtending the Thread class: public class MyThread extends Thread { public void run() { // code to be executed in this thread } } You can create an instance of the MyThread class and start the thread using the start() method:\nMyThread myThread = new MyThread(); myThread.start(); Implementing the Runnable interface: public class MyRunnable implements Runnable { public void run() { // code to be executed in this thread } } You can create an instance of the MyRunnable class and pass it to a Thread object\u0026rsquo;s constructor:\nMyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); thread.start(); In both cases, the run() method contains the code that will be executed when the thread is started. You should not call the run() method directly, but rather use the start() method to start the thread.\n2. Thread Termination : Following are reasons to terminate a thread:\nThreads in a computer consume various resources, such as memory, kernel resources, CPU cycles, and cache memory.\nIf a thread finished its work, but the application is still running we want to clean up the thread\u0026rsquo;s resources.\nIf a thread is misbehaving, we want to stop it.\nThe application will not stop as long as at least one thread is still running.\nIn Java, you can terminate a thread by calling the interrupt() method on the thread object. This method sets a flag on the thread to indicate that it should stop executing. However, it is up to the thread\u0026rsquo;s code to check for the interrupt flag and terminate gracefully.\npublic class MyThread extends Thread { @Override public void run() { while (!Thread.currentThread().isInterrupted()) { // do some work } System.out.println(\u0026quot;Thread is terminating.\u0026quot;); } } public class Main { public static void main(String[] args) { MyThread thread = new MyThread(); thread.start(); // Interrupt the thread thread.interrupt(); } } In this example, the MyThread class extends the Thread class and overrides the run() method to do some work in a loop. Inside the loop, the thread checks if it has been interrupted using the isInterrupted() method.\nIn the Main class, we create an instance of MyThread and start it. When the interrupt() method is called, the isInterrupted() method in the MyThread class will return true, causing the thread to exit the loop and terminate gracefully.\n3. Daemon Threads : In Java, a daemon thread is a type of thread that runs in the background and does not prevent the Java Virtual Machine (JVM) from exiting when the program finishes execution.\nDaemon threads are typically used for tasks that need to run continuously in the background, such as garbage collection or other system-level tasks. They are also commonly used in server applications to perform tasks like cleaning up old connections or handling periodic maintenance tasks.\nTo create a daemon thread in Java, you can use the setDaemon() method on a Thread object. For example, the following code creates a new thread and sets it as a daemon thread:\nThread myThread = new Thread(new Runnable() { public void run() { // Do some background task here } }); myThread.setDaemon(true); myThread.start(); Once a thread is set as a daemon thread, you cannot change it back to a non-daemon thread.\n4. Joining Threads :\nJoining threads in Java is done using the join() method, which allows one thread to wait for another thread to complete before continuing. Here\u0026rsquo;s a simple example of how to use the join() method to join two threads:\npublic class JoinExample { public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u0026gt; { System.out.println(\u0026quot;Thread 1 is running\u0026quot;); try { Thread.sleep(2000); // simulate some work being done } catch (InterruptedException e) { System.out.println(\u0026quot;Thread 1 was interrupted\u0026quot;); } System.out.println(\u0026quot;Thread 1 is finished\u0026quot;); }); Thread t2 = new Thread(() -\u0026gt; { System.out.println(\u0026quot;Thread 2 is running\u0026quot;); try { Thread.sleep(1000); // simulate some work being done } catch (InterruptedException e) { System.out.println(\u0026quot;Thread 2 was interrupted\u0026quot;); } System.out.println(\u0026quot;Thread 2 is finished\u0026quot;); }); t1.start(); t2.start(); // wait for both threads to finish t1.join(); t2.join(); System.out.println(\u0026quot;Both threads have finished\u0026quot;); } } In this example, we create two threads t1 and t2 and start them. We then use the join() method to wait for both threads to finish before printing out a message indicating that both threads have finished.\nWhen t1.join() and t2.join() are called, the main thread will block and wait until both t1 and t2 have finished executing. Once both threads have completed, the main thread will continue executing and print out the final message.\n5. Resource Sharing in Threads\nIn Java, resource sharing can be achieved using the concept of synchronized monitors. A synchronized monitor is a mechanism that allows only one thread to access a shared resource at a time.\nTo use synchronized monitors in Java, you can use the synchronized keyword to define a block of code that needs to be executed by only one thread at a time. The synchronized keyword can be applied to a method or a block of code.\nHere\u0026rsquo;s an example of using synchronized monitors to share a resource in Java:\npublic class SharedResource { private int value; public synchronized void increment() { value++; } public synchronized int getValue() { return value; } } public class ResourceSharingExample { public static void main(String[] args) { SharedResource sharedResource = new SharedResource(); // create multiple threads to access the shared resource Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { sharedResource.increment(); } }); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { sharedResource.increment(); } }); // start the threads t1.start(); t2.start(); // wait for the threads to finish try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } // print the final value of the shared resource System.out.println(\u0026quot;Value: \u0026quot; + sharedResource.getValue()); } } In this example, the SharedResource class represents a shared resource that contains a single integer value. The increment() method and getValue() method are both marked as synchronized, which means that only one thread can access them at a time.\nThe ResourceSharingExample class creates two threads that access the shared resource using the increment() method. The threads run concurrently, but because of the synchronized monitors, only one thread can execute the increment() method at a time. The final value of the shared resource is printed at the end of the program, which should be 2000 in this case.\nWe also achieve some result using Object lock instead of synchronized monitors in Java.\npublic class SharedResource { private int value; private final Object lock = new Object(); public void increment() { synchronized (lock) { value++; } } public int getValue() { synchronized (lock) { return value; } } } public class ResourceSharingExample { public static void main(String[] args) { SharedResource sharedResource = new SharedResource(); // create multiple threads to access the shared resource Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { sharedResource.increment(); } }); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { sharedResource.increment(); } }); // start the threads t1.start(); t2.start(); // wait for the threads to finish try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } // print the final value of the shared resource System.out.println(\u0026quot;Value: \u0026quot; + sharedResource.getValue()); } } Using mutiple object locks threads can access the shared resources concurrently without interfering with each other.\npublic class SharedResource { private int value1; private int value2; private final Object lock1 = new Object(); private final Object lock2 = new Object(); public void incrementValue1() { synchronized (lock1) { value1++; } } public int getValue1() { synchronized (lock1) { return value1; } } public void incrementValue2() { synchronized (lock2) { value2++; } } public int getValue2() { synchronized (lock2) { return value2; } } } public class ResourceSharingExample { public static void main(String[] args) { SharedResource sharedResource = new SharedResource(); // create multiple threads to access the shared resource Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { sharedResource.incrementValue1(); } }); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { sharedResource.incrementValue2(); } }); // start the threads t1.start(); t2.start(); // wait for the threads to finish try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } // print the final values of the shared resources System.out.println(\u0026quot;Value1: \u0026quot; + sharedResource.getValue1()); System.out.println(\u0026quot;Value2: \u0026quot; + sharedResource.getValue2()); } } In this example, the SharedResource class contains two object locks, lock1 and lock2, and two methods for each value, incrementValue1(), getValue1(), incrementValue2(), and getValue2(). The incrementValue1() method and getValue1() method use lock1 to synchronize access to value1, while the incrementValue2() method and getValue2() method use lock2 to synchronize access to value2.\nThe ResourceSharingExample class creates two threads that access the shared resources using incrementValue1() and incrementValue2() methods. Because two different object locks are used to synchronize access to two different values, the threads can access the shared resources concurrently without interfering with each other. The final values of the shared resources are printed at the end of the program.\n6. Reentrant lock\nA ReentrantLock is a synchronization mechanism in Java that provides a way to protect shared resources from simultaneous access by multiple threads. It is called \u0026ldquo;reentrant\u0026rdquo; because a thread that already holds the lock can acquire it again without blocking, unlike traditional synchronization using the synchronized keyword.\nimport java.util.concurrent.locks.ReentrantLock; public class SharedResource { private int value; private ReentrantLock lock = new ReentrantLock(); public void incrementValue() { lock.lock(); try { value++; } finally { lock.unlock(); } } public int getValue() { lock.lock(); try { return value; } finally { lock.unlock(); } } } public class ResourceSharingExample { public static void main(String[] args) { SharedResource sharedResource = new SharedResource(); // create multiple threads to access the shared resource Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { sharedResource.incrementValue(); } }); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { sharedResource.incrementValue(); } }); // start the threads t1.start(); t2.start(); // wait for the threads to finish try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } // print the final value of the shared resource System.out.println(\u0026quot;Value: \u0026quot; + sharedResource.getValue()); } } In this example, the SharedResource class contains a single ReentrantLock and two methods for incrementing and retrieving the value variable. The lock object is used to synchronize access to the value variable.\nThe ResourceSharingExample class creates two threads that access the shared resource using the incrementValue() method. Because a ReentrantLock is used to synchronize access to the shared resource, the threads can access the shared resource concurrently without interfering with each other.\nReentrantLock is like a special key that allows threads to take turns accessing a shared resource. And if a thread already has the key, it can use it again without waiting in line. It provides query methods for testing lock\u0026rsquo;s internal state.\nExample of using ReentrantLock and tryLock() method in Java:\nimport java.util.concurrent.locks.ReentrantLock; public class Example { public static void main(String[] args) { ReentrantLock lock = new ReentrantLock(); // acquire the lock using tryLock() method boolean isLockAcquired = lock.tryLock(); if (isLockAcquired) { try { // perform critical section operations here System.out.println(\u0026quot;Lock acquired and critical section entered.\u0026quot;); } finally { // release the lock lock.unlock(); System.out.println(\u0026quot;Lock released.\u0026quot;); } } else { System.out.println(\u0026quot;Could not acquire lock. Another thread is holding the lock.\u0026quot;); } } } Example of using ReentrantReadWriteLock and tryLock() method in Java:\nimport java.util.HashMap; import java.util.Map; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class Example { private Map\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); private ReadWriteLock lock = new ReentrantReadWriteLock(); public void put(String key, String value) { lock.writeLock().lock(); // acquire write lock try { map.put(key, value); // perform write operation } finally { lock.writeLock().unlock(); // release write lock } } public String get(String key) { lock.readLock().lock(); // acquire read lock try { return map.get(key); // perform read operation } finally { lock.readLock().unlock(); // release read lock } } } In this example, we have a Map object that is accessed by multiple threads. To ensure thread safety and prevent race conditions, we use a ReadWriteLock to control access to the map.\nThe put() method acquires a write lock using the writeLock() method, performs a write operation on the map, and then releases the write lock using the unlock() method.\nThe get() method acquires a read lock using the readLock() method, performs a read operation on the map, and then releases the read lock using the unlock() method.\nWith this approach, multiple threads can simultaneously read from the map, but only one thread can write to the map at a time. This can significantly improve performance in scenarios where reads are much more frequent than writes.\n7. Volatile Keyword\nIn Java, the volatile keyword is used as a modifier to indicate that a variable\u0026rsquo;s value may be modified by multiple threads at the same time.\nWhen a variable is marked as volatile, the JVM ensures that any write to that variable is immediately visible to other threads that may access it. This means that changes made to the variable by one thread will be immediately reflected in the value seen by other threads. Without the volatile keyword, there is no guarantee that changes made by one thread will be immediately visible to another thread, which can lead to hard-to-detect bugs.\nThe volatile keyword can be used with any primitive type, as well as with references to objects. However, it\u0026rsquo;s important to note that using volatile does not provide atomicity, which means that if multiple threads try to modify the same variable at the same time, race conditions and inconsistencies can still occur.\nIn general, the volatile keyword should only be used when there is a specific need for multiple threads to access the same variable, and the programmer is sure that the volatile variable will be accessed in a safe and consistent way.\nHere\u0026rsquo;s an example to illustrate the use of volatile keyword in Java:\npublic class Counter { private volatile int count; public synchronized void increment() { count++; } public int getCount() { return count; } } In this example, we have a Counter class with a private volatile integer field called count. The increment() method is used to increment the value of count by one, and the getCount() method returns the current value of count.\nWithout the volatile keyword, there is no guarantee that changes made to count by one thread will be immediately visible to another thread. However, since count is marked as volatile, the JVM ensures that any write to count is immediately visible to other threads that may access it.\nConsider the following example usage of the Counter class by multiple threads:\npublic class Main { public static void main(String[] args) { Counter counter = new Counter(); Thread thread1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 10000; i++) { counter.increment(); } }); Thread thread2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 10000; i++) { counter.increment(); } }); thread1.start(); thread2.start(); try { thread1.join(); thread2.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026quot;Final count: \u0026quot; + counter.getCount()); } } In this example, we create two threads, thread1 and thread2, which both increment the Counter object\u0026rsquo;s count field 10,000 times. We then wait for both threads to complete using the join() method, and output the final value of count.\nWithout the volatile keyword on the count field in the Counter class, there is no guarantee that the final value of count will be 20,000. However, with count marked as volatile, we can be sure that changes made by one thread will be immediately visible to the other thread, and the final value of count will be 20,000.\n8. Deadlocks In Java, a deadlock occurs when two or more threads are blocked, waiting for each other to release the locks they hold. As a result, none of the threads can make progress and the program hangs.\nHere\u0026rsquo;s an example to illustrate how a deadlock can occur in Java:\npublic class DeadlockExample { private Object lock1 = new Object(); private Object lock2 = new Object(); public void method1() { synchronized (lock1) { System.out.println(\u0026quot;Acquired lock1 in method1\u0026quot;); try { Thread.sleep(1000); } catch (InterruptedException e) {} synchronized (lock2) { System.out.println(\u0026quot;Acquired lock2 in method1\u0026quot;); } } } public void method2() { synchronized (lock2) { System.out.println(\u0026quot;Acquired lock2 in method2\u0026quot;); try { Thread.sleep(1000); } catch (InterruptedException e) {} synchronized (lock1) { System.out.println(\u0026quot;Acquired lock1 in method2\u0026quot;); } } } public static void main(String[] args) { final DeadlockExample example = new DeadlockExample(); Thread thread1 = new Thread(new Runnable() { public void run() { example.method1(); } }); Thread thread2 = new Thread(new Runnable() { public void run() { example.method2(); } }); thread1.start(); thread2.start(); } } In this example, there are two methods, method1() and method2(), which each synchronize on a different lock. The main() method creates two threads that each call one of these methods.\nNow, suppose that thread1 acquires lock1 and then calls method2(), which tries to acquire lock2. At the same time, thread2 has already acquired lock2 and is trying to acquire lock1. Both threads are blocked waiting for the other thread to release its lock, causing a deadlock.\nDeadlock can occur in a concurrent system when the following conditions are met:\nMutual Exclusion: At least one resource is held in a mutually exclusive mode, meaning only one thread can use it at a time.\nHold and Wait: A thread is holding at least one resource and is waiting to acquire additional resources that are currently held by other threads.\nNo Preemption: Resources cannot be preempted or taken away from threads that are holding them. The only way to release a resource is for the thread to voluntarily release it.\nCircular Wait: A circular chain of threads exists, where each thread is waiting for a resource that is held by the next thread in the chain. In other words, there is a cycle in the resource allocation graph.\nTo avoid deadlocks, you can use some techniques like:\nAcquire locks in a fixed order.\nUse timeouts when acquiring locks to avoid indefinitely waiting for a lock.\nUse tryLock() instead of synchronized blocks to acquire locks in a non-blocking way.\nUse higher-level concurrency utilities like java.util.concurrent classes, which handle synchronization and - locking automatically.\n","content_html":"\u003cp\u003e\u003cstrong\u003e1. Thread creation\u003c/strong\u003e : In Java, you can create a thread by either extending the Thread class or implementing the Runnable interface. Here\u0026rsquo;s how you can do it:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eExtending the Thread class:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class MyThread extends Thread {\n    public void run() {\n        // code to be executed in this thread\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can create an instance of the MyThread class and start the thread using the start() method:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eMyThread myThread = new MyThread();\nmyThread.start();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eImplementing the Runnable interface:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class MyRunnable implements Runnable {\n    public void run() {\n        // code to be executed in this thread\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can create an instance of the MyRunnable class and pass it to a Thread object\u0026rsquo;s constructor:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eMyRunnable myRunnable = new MyRunnable();\nThread thread = new Thread(myRunnable);\nthread.start();\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn both cases, the run() method contains the code that will be executed when the thread is started. You should not call the run() method directly, but rather use the start() method to start the thread.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e2. Thread Termination\u003c/strong\u003e :\nFollowing are reasons to terminate a thread:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThreads in a computer consume various resources, such as memory, kernel resources, CPU cycles, and cache memory.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIf a thread finished its work, but the application is still running we want to clean up the thread\u0026rsquo;s resources.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIf a thread is misbehaving, we want to stop it.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe application will not stop as long as at least one thread is still running.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn Java, you can terminate a thread by calling the interrupt() method on the thread object. This method sets a flag on the thread to indicate that it should stop executing. However, it is up to the thread\u0026rsquo;s code to check for the interrupt flag and terminate gracefully.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class MyThread extends Thread {\n    @Override\n    public void run() {\n        while (!Thread.currentThread().isInterrupted()) {\n            // do some work\n        }\n        System.out.println(\u0026quot;Thread is terminating.\u0026quot;);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        MyThread thread = new MyThread();\n        thread.start();\n\n        // Interrupt the thread\n        thread.interrupt();\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, the MyThread class extends the Thread class and overrides the run() method to do some work in a loop. Inside the loop, the thread checks if it has been interrupted using the isInterrupted() method.\u003c/p\u003e\n\u003cp\u003eIn the Main class, we create an instance of MyThread and start it. When the interrupt() method is called, the isInterrupted() method in the MyThread class will return true, causing the thread to exit the loop and terminate gracefully.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e3. Daemon Threads\u003c/strong\u003e :\nIn Java, a daemon thread is a type of thread that runs in the background and does not prevent the Java Virtual Machine (JVM) from exiting when the program finishes execution.\u003c/p\u003e\n\u003cp\u003eDaemon threads are typically used for tasks that need to run continuously in the background, such as garbage collection or other system-level tasks. They are also commonly used in server applications to perform tasks like cleaning up old connections or handling periodic maintenance tasks.\u003c/p\u003e\n\u003cp\u003eTo create a daemon thread in Java, you can use the setDaemon() method on a Thread object. For example, the following code creates a new thread and sets it as a daemon thread:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eThread myThread = new Thread(new Runnable() {\n    public void run() {\n        // Do some background task here\n    }\n});\nmyThread.setDaemon(true);\nmyThread.start();\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOnce a thread is set as a daemon thread, you cannot change it back to a non-daemon thread.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e4. Joining Threads\u003c/strong\u003e :\u003c/p\u003e\n\u003cp\u003eJoining threads in Java is done using the join() method, which allows one thread to wait for another thread to complete before continuing. Here\u0026rsquo;s a simple example of how to use the join() method to join two threads:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class JoinExample {\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread t1 = new Thread(() -\u0026gt; {\n            System.out.println(\u0026quot;Thread 1 is running\u0026quot;);\n            try {\n                Thread.sleep(2000); // simulate some work being done\n            } catch (InterruptedException e) {\n                System.out.println(\u0026quot;Thread 1 was interrupted\u0026quot;);\n            }\n            System.out.println(\u0026quot;Thread 1 is finished\u0026quot;);\n        });\n\n        Thread t2 = new Thread(() -\u0026gt; {\n            System.out.println(\u0026quot;Thread 2 is running\u0026quot;);\n            try {\n                Thread.sleep(1000); // simulate some work being done\n            } catch (InterruptedException e) {\n                System.out.println(\u0026quot;Thread 2 was interrupted\u0026quot;);\n            }\n            System.out.println(\u0026quot;Thread 2 is finished\u0026quot;);\n        });\n\n        t1.start();\n        t2.start();\n\n        // wait for both threads to finish\n        t1.join();\n        t2.join();\n\n        System.out.println(\u0026quot;Both threads have finished\u0026quot;);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, we create two threads t1 and t2 and start them. We then use the join() method to wait for both threads to finish before printing out a message indicating that both threads have finished.\u003c/p\u003e\n\u003cp\u003eWhen t1.join() and t2.join() are called, the main thread will block and wait until both t1 and t2 have finished executing. Once both threads have completed, the main thread will continue executing and print out the final message.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e5. Resource Sharing in Threads\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIn Java, resource sharing can be achieved using the concept of synchronized monitors. A synchronized monitor is a mechanism that allows only one thread to access a shared resource at a time.\u003c/p\u003e\n\u003cp\u003eTo use synchronized monitors in Java, you can use the synchronized keyword to define a block of code that needs to be executed by only one thread at a time. The synchronized keyword can be applied to a method or a block of code.\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s an example of using synchronized monitors to share a resource in Java:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SharedResource {\n    private int value;\n\n    public synchronized void increment() {\n        value++;\n    }\n\n    public synchronized int getValue() {\n        return value;\n    }\n}\n\npublic class ResourceSharingExample {\n    public static void main(String[] args) {\n        SharedResource sharedResource = new SharedResource();\n\n        // create multiple threads to access the shared resource\n        Thread t1 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 1000; i++) {\n                sharedResource.increment();\n            }\n        });\n\n        Thread t2 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 1000; i++) {\n                sharedResource.increment();\n            }\n        });\n\n        // start the threads\n        t1.start();\n        t2.start();\n\n        // wait for the threads to finish\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // print the final value of the shared resource\n        System.out.println(\u0026quot;Value: \u0026quot; + sharedResource.getValue());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, the SharedResource class represents a shared resource that contains a single integer value. The increment() method and getValue() method are both marked as synchronized, which means that only one thread can access them at a time.\u003c/p\u003e\n\u003cp\u003eThe ResourceSharingExample class creates two threads that access the shared resource using the increment() method. The threads run concurrently, but because of the synchronized monitors, only one thread can execute the increment() method at a time. The final value of the shared resource is printed at the end of the program, which should be 2000 in this case.\u003c/p\u003e\n\u003cp\u003eWe also achieve some result using Object lock instead of synchronized monitors in Java.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SharedResource {\n    private int value;\n    private final Object lock = new Object();\n\n    public void increment() {\n        synchronized (lock) {\n            value++;\n        }\n    }\n\n    public int getValue() {\n        synchronized (lock) {\n            return value;\n        }\n    }\n}\n\npublic class ResourceSharingExample {\n    public static void main(String[] args) {\n        SharedResource sharedResource = new SharedResource();\n\n        // create multiple threads to access the shared resource\n        Thread t1 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 1000; i++) {\n                sharedResource.increment();\n            }\n        });\n\n        Thread t2 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 1000; i++) {\n                sharedResource.increment();\n            }\n        });\n\n        // start the threads\n        t1.start();\n        t2.start();\n\n        // wait for the threads to finish\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // print the final value of the shared resource\n        System.out.println(\u0026quot;Value: \u0026quot; + sharedResource.getValue());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUsing mutiple object locks threads can access the shared resources concurrently without interfering with each other.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SharedResource {\n    private int value1;\n    private int value2;\n    private final Object lock1 = new Object();\n    private final Object lock2 = new Object();\n\n    public void incrementValue1() {\n        synchronized (lock1) {\n            value1++;\n        }\n    }\n\n    public int getValue1() {\n        synchronized (lock1) {\n            return value1;\n        }\n    }\n\n    public void incrementValue2() {\n        synchronized (lock2) {\n            value2++;\n        }\n    }\n\n    public int getValue2() {\n        synchronized (lock2) {\n            return value2;\n        }\n    }\n}\n\npublic class ResourceSharingExample {\n    public static void main(String[] args) {\n        SharedResource sharedResource = new SharedResource();\n\n        // create multiple threads to access the shared resource\n        Thread t1 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 1000; i++) {\n                sharedResource.incrementValue1();\n            }\n        });\n\n        Thread t2 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 1000; i++) {\n                sharedResource.incrementValue2();\n            }\n        });\n\n        // start the threads\n        t1.start();\n        t2.start();\n\n        // wait for the threads to finish\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // print the final values of the shared resources\n        System.out.println(\u0026quot;Value1: \u0026quot; + sharedResource.getValue1());\n        System.out.println(\u0026quot;Value2: \u0026quot; + sharedResource.getValue2());\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, the SharedResource class contains two object locks, lock1 and lock2, and two methods for each value, incrementValue1(), getValue1(), incrementValue2(), and getValue2(). The incrementValue1() method and getValue1() method use lock1 to synchronize access to value1, while the incrementValue2() method and getValue2() method use lock2 to synchronize access to value2.\u003c/p\u003e\n\u003cp\u003eThe ResourceSharingExample class creates two threads that access the shared resources using incrementValue1() and incrementValue2() methods. Because two different object locks are used to synchronize access to two different values, the \u003cstrong\u003ethreads can access the shared resources concurrently without interfering with each other\u003c/strong\u003e. The final values of the shared resources are printed at the end of the program.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e6. Reentrant lock\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eA ReentrantLock is a synchronization mechanism in Java that provides a way to protect shared resources from simultaneous access by multiple threads. It is called \u0026ldquo;reentrant\u0026rdquo; because a thread that already holds the lock can acquire it again without blocking, unlike traditional synchronization using the synchronized keyword.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eimport java.util.concurrent.locks.ReentrantLock;\n\npublic class SharedResource {\n    private int value;\n    private ReentrantLock lock = new ReentrantLock();\n\n    public void incrementValue() {\n        lock.lock();\n        try {\n            value++;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public int getValue() {\n        lock.lock();\n        try {\n            return value;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic class ResourceSharingExample {\n    public static void main(String[] args) {\n        SharedResource sharedResource = new SharedResource();\n\n        // create multiple threads to access the shared resource\n        Thread t1 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 1000; i++) {\n                sharedResource.incrementValue();\n            }\n        });\n\n        Thread t2 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 1000; i++) {\n                sharedResource.incrementValue();\n            }\n        });\n\n        // start the threads\n        t1.start();\n        t2.start();\n\n        // wait for the threads to finish\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // print the final value of the shared resource\n        System.out.println(\u0026quot;Value: \u0026quot; + sharedResource.getValue());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, the SharedResource class contains a single ReentrantLock and two methods for incrementing and retrieving the value variable. The lock object is used to synchronize access to the value variable.\u003c/p\u003e\n\u003cp\u003eThe ResourceSharingExample class creates two threads that access the shared resource using the incrementValue() method. Because a ReentrantLock is used to synchronize access to the shared resource, the threads can access the shared resource concurrently without interfering with each other.\u003c/p\u003e\n\u003cp\u003eReentrantLock is like a special key that allows threads to take turns accessing a shared resource. And if a thread already has the key, it can use it again without waiting in line. It provides query methods for testing lock\u0026rsquo;s internal state.\u003c/p\u003e\n\u003cp\u003eExample of using ReentrantLock and tryLock() method in Java:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Example {\n    public static void main(String[] args) {\n        ReentrantLock lock = new ReentrantLock();\n\n        // acquire the lock using tryLock() method\n        boolean isLockAcquired = lock.tryLock();\n\n        if (isLockAcquired) {\n            try {\n                // perform critical section operations here\n                System.out.println(\u0026quot;Lock acquired and critical section entered.\u0026quot;);\n            } finally {\n                // release the lock\n                lock.unlock();\n                System.out.println(\u0026quot;Lock released.\u0026quot;);\n            }\n        } else {\n            System.out.println(\u0026quot;Could not acquire lock. Another thread is holding the lock.\u0026quot;);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eExample of using ReentrantReadWriteLock and tryLock() method in Java:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\npublic class Example {\n    private Map\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;();\n    private ReadWriteLock lock = new ReentrantReadWriteLock();\n\n    public void put(String key, String value) {\n        lock.writeLock().lock(); // acquire write lock\n        try {\n            map.put(key, value); // perform write operation\n        } finally {\n            lock.writeLock().unlock(); // release write lock\n        }\n    }\n\n    public String get(String key) {\n        lock.readLock().lock(); // acquire read lock\n        try {\n            return map.get(key); // perform read operation\n        } finally {\n            lock.readLock().unlock(); // release read lock\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, we have a Map object that is accessed by multiple threads. To ensure thread safety and prevent race conditions, we use a ReadWriteLock to control access to the map.\u003c/p\u003e\n\u003cp\u003eThe put() method acquires a write lock using the writeLock() method, performs a write operation on the map, and then releases the write lock using the unlock() method.\u003c/p\u003e\n\u003cp\u003eThe get() method acquires a read lock using the readLock() method, performs a read operation on the map, and then releases the read lock using the unlock() method.\u003c/p\u003e\n\u003cp\u003eWith this approach, multiple threads can simultaneously read from the map, but only one thread can write to the map at a time. This can significantly improve performance in scenarios where reads are much more frequent than writes.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e7. Volatile Keyword\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIn Java, the volatile keyword is used as a modifier to indicate that a variable\u0026rsquo;s value may be modified by multiple threads at the same time.\u003c/p\u003e\n\u003cp\u003eWhen a variable is marked as volatile, the JVM ensures that any write to that variable is immediately visible to other threads that may access it. This means that changes made to the variable by one thread will be immediately reflected in the value seen by other threads. Without the volatile keyword, there is no guarantee that changes made by one thread will be immediately visible to another thread, which can lead to hard-to-detect bugs.\u003c/p\u003e\n\u003cp\u003eThe volatile keyword can be used with any primitive type, as well as with references to objects. However, it\u0026rsquo;s important to note that using volatile does not provide atomicity, which means that if multiple threads try to modify the same variable at the same time, race conditions and inconsistencies can still occur.\u003c/p\u003e\n\u003cp\u003eIn general, the volatile keyword should only be used when there is a specific need for multiple threads to access the same variable, and the programmer is sure that the volatile variable will be accessed in a safe and consistent way.\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s an example to illustrate the use of volatile keyword in Java:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Counter {\n    private volatile int count;\n\n    public synchronized void increment() {\n        count++;\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, we have a Counter class with a private volatile integer field called count. The increment() method is used to increment the value of count by one, and the getCount() method returns the current value of count.\u003c/p\u003e\n\u003cp\u003eWithout the volatile keyword, there is no guarantee that changes made to count by one thread will be immediately visible to another thread. However, since count is marked as volatile, the JVM ensures that any write to count is immediately visible to other threads that may access it.\u003c/p\u003e\n\u003cp\u003eConsider the following example usage of the Counter class by multiple threads:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Main {\n    public static void main(String[] args) {\n        Counter counter = new Counter();\n\n        Thread thread1 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 10000; i++) {\n                counter.increment();\n            }\n        });\n\n        Thread thread2 = new Thread(() -\u0026gt; {\n            for (int i = 0; i \u0026lt; 10000; i++) {\n                counter.increment();\n            }\n        });\n\n        thread1.start();\n        thread2.start();\n\n        try {\n            thread1.join();\n            thread2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(\u0026quot;Final count: \u0026quot; + counter.getCount());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, we create two threads, thread1 and thread2, which both increment the Counter object\u0026rsquo;s count field 10,000 times. We then wait for both threads to complete using the join() method, and output the final value of count.\u003c/p\u003e\n\u003cp\u003eWithout the volatile keyword on the count field in the Counter class, there is no guarantee that the final value of count will be 20,000. However, with count marked as volatile, we can be sure that changes made by one thread will be immediately visible to the other thread, and the final value of count will be 20,000.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e8. Deadlocks\u003c/strong\u003e\nIn Java, a deadlock occurs when two or more threads are blocked, waiting for each other to release the locks they hold. As a result, none of the threads can make progress and the program hangs.\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s an example to illustrate how a deadlock can occur in Java:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class DeadlockExample {\n    private Object lock1 = new Object();\n    private Object lock2 = new Object();\n\n    public void method1() {\n        synchronized (lock1) {\n            System.out.println(\u0026quot;Acquired lock1 in method1\u0026quot;);\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {}\n            synchronized (lock2) {\n                System.out.println(\u0026quot;Acquired lock2 in method1\u0026quot;);\n            }\n        }\n    }\n\n    public void method2() {\n        synchronized (lock2) {\n            System.out.println(\u0026quot;Acquired lock2 in method2\u0026quot;);\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {}\n            synchronized (lock1) {\n                System.out.println(\u0026quot;Acquired lock1 in method2\u0026quot;);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        final DeadlockExample example = new DeadlockExample();\n        Thread thread1 = new Thread(new Runnable() {\n            public void run() {\n                example.method1();\n            }\n        });\n        Thread thread2 = new Thread(new Runnable() {\n            public void run() {\n                example.method2();\n            }\n        });\n        thread1.start();\n        thread2.start();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, there are two methods, method1() and method2(), which each synchronize on a different lock. The main() method creates two threads that each call one of these methods.\u003c/p\u003e\n\u003cp\u003eNow, suppose that thread1 acquires lock1 and then calls method2(), which tries to acquire lock2. At the same time, thread2 has already acquired lock2 and is trying to acquire lock1. Both threads are blocked waiting for the other thread to release its lock, causing a deadlock.\u003c/p\u003e\n\u003cp\u003eDeadlock can occur in a concurrent system when the following conditions are met:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMutual Exclusion: At least one resource is held in a mutually exclusive mode, meaning only one thread can use it at a time.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHold and Wait: A thread is holding at least one resource and is waiting to acquire additional resources that are currently held by other threads.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eNo Preemption: Resources cannot be preempted or taken away from threads that are holding them. The only way to release a resource is for the thread to voluntarily release it.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCircular Wait: A circular chain of threads exists, where each thread is waiting for a resource that is held by the next thread in the chain. In other words, there is a cycle in the resource allocation graph.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo avoid deadlocks, you can use some techniques like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eAcquire locks in a fixed order.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eUse timeouts when acquiring locks to avoid indefinitely waiting for a lock.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eUse tryLock() instead of synchronized blocks to acquire locks in a non-blocking way.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eUse higher-level concurrency utilities like java.util.concurrent classes, which handle synchronization and - locking automatically.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","url":"https://karthikselvam.com/posts/2023/01/23/threads/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"23016-23-09T10:2323:00+00:00","date_modified":"23016-23-09T10:2323:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"f7d5285750b0c221397309ad910af98f154422a2","title":"Handling Transactions in Microservices","summary":"2023","content_text":"Handling transactions involving more than one microservice can be challenging since each microservice typically has its own data store and transaction management. However, there are several best practices that can help to ensure consistency and reliability across microservices:\nThe Saga pattern: This involves breaking the transaction into multiple smaller transactions, each of which is handled by a separate microservice. If a transaction fails, the other services can be rolled back, ensuring that the system remains consistent. Let\u0026rsquo;s say you have a system where a user can place an order that involves multiple microservices. The order might involve checking inventory levels, processing payments, and shipping products. You can use the Saga pattern to handle this transaction by breaking it down into smaller transactions, each handled by a separate microservice. If one of the transactions fails, the other transactions can be rolled back, ensuring that the system remains consistent. For example, the payment service fails to process a payment. The shipping service can be notified to cancel the shipment, and the inventory service can be notified to restock the item. This ensures that the system remains consistent even though one of the transactions failed.\nDistributed transaction coordinator: A distributed transaction coordinator can help to manage transactions across multiple microservices. The coordinator can ensure that all transactions are either committed or rolled back as a single unit, ensuring consistency across the system.For example, you could use a tool like Apache Kafka to implement a distributed transaction coordinator. When a user places an order, the order microservice can publish a message to a Kafka topic. Each microservice that needs to handle the transaction can subscribe to the topic and perform its own transaction. If one of the microservices fails, the coordinator can ensure that all transactions are either committed or rolled back as a single unit, ensuring consistency across the system.\nCompensating transactions: A compensating transaction is a transaction that undoes the effects of a previous transaction. This can be used to handle failures in the system by rolling back the changes made by previous transactions and restoring the system to its previous state.For example, Let\u0026rsquo;s say you have a system where a user can transfer money between accounts. This transaction involves two microservices: one to debit the account and another to credit the account. If the credit service fails, you can use a compensating transaction to handle the failure. The debit service can be notified to reverse the debit transaction, ensuring that the system remains consistent.\nEvent-driven architectures: In an event-driven architecture, each microservice publishes events when it completes a transaction. Other microservices can subscribe to these events and use them to trigger their own transactions. This can help to ensure consistency across the system and reduce the risk of failures.For example, Let\u0026rsquo;s say you have a system where a user can place an order that involves multiple microservices. Each microservice can publish an event when it completes a transaction. For example, the inventory service can publish an event when it updates the inventory level, and the shipping service can publish an event when it ships the product. Other microservices can subscribe to these events and use them to trigger their own transactions. This can help to ensure consistency across the system and reduce the risk of failures.\nIdempotency: Idempotency is the property of a system where performing the same operation multiple times has the same result as performing it once. By designing microservices to be idempotent, you can reduce the risk of failures and ensure consistency across the system.For example, Let\u0026rsquo;s say you have a system where a user can update their profile information. To ensure idempotency, you can design the microservice to only update the profile if the request includes a unique identifier, such as a UUID. If the same request is made multiple times, the microservice will recognize the duplicate request and return the same result as the original request. This ensures that the system remains consistent even if the same request is made multiple times.\n","content_html":"\u003cp\u003eHandling transactions involving more than one microservice can be challenging since each microservice typically has its own data store and transaction management. However, there are several best practices that can help to ensure consistency and reliability across microservices:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eThe Saga pattern\u003c/strong\u003e: This involves breaking the transaction into multiple smaller transactions, each of which is handled by a separate microservice. If a transaction fails, the other services can be rolled back, ensuring that the system remains consistent. Let\u0026rsquo;s say you have a system where a user can place an order that involves multiple microservices. The order might involve checking inventory levels, processing payments, and shipping products. You can use the Saga pattern to handle this transaction by breaking it down into smaller transactions, each handled by a separate microservice. If one of the transactions fails, the other transactions can be rolled back, ensuring that the system remains consistent. For example, the payment service fails to process a payment. The shipping service can be notified to cancel the shipment, and the inventory service can be notified to restock the item. This ensures that the system remains consistent even though one of the transactions failed.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eDistributed transaction coordinator\u003c/strong\u003e: A distributed transaction coordinator can help to manage transactions across multiple microservices. The coordinator can ensure that all transactions are either committed or rolled back as a single unit, ensuring consistency across the system.For example, you could use a tool like Apache Kafka to implement a distributed transaction coordinator. When a user places an order, the order microservice can publish a message to a Kafka topic. Each microservice that needs to handle the transaction can subscribe to the topic and perform its own transaction. If one of the microservices fails, the coordinator can ensure that all transactions are either committed or rolled back as a single unit, ensuring consistency across the system.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eCompensating transactions\u003c/strong\u003e: A compensating transaction is a transaction that undoes the effects of a previous transaction. This can be used to handle failures in the system by rolling back the changes made by previous transactions and restoring the system to its previous state.For example, Let\u0026rsquo;s say you have a system where a user can transfer money between accounts. This transaction involves two microservices: one to debit the account and another to credit the account. If the credit service fails, you can use a compensating transaction to handle the failure. The debit service can be notified to reverse the debit transaction, ensuring that the system remains consistent.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eEvent-driven architectures\u003c/strong\u003e: In an event-driven architecture, each microservice publishes events when it completes a transaction. Other microservices can subscribe to these events and use them to trigger their own transactions. This can help to ensure consistency across the system and reduce the risk of failures.For example, Let\u0026rsquo;s say you have a system where a user can place an order that involves multiple microservices. Each microservice can publish an event when it completes a transaction. For example, the inventory service can publish an event when it updates the inventory level, and the shipping service can publish an event when it ships the product. Other microservices can subscribe to these events and use them to trigger their own transactions. This can help to ensure consistency across the system and reduce the risk of failures.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eIdempotency\u003c/strong\u003e: Idempotency is the property of a system where performing the same operation multiple times has the same result as performing it once. By designing microservices to be idempotent, you can reduce the risk of failures and ensure consistency across the system.For example, Let\u0026rsquo;s say you have a system where a user can update their profile information. To ensure idempotency, you can design the microservice to only update the profile if the request includes a unique identifier, such as a UUID. If the same request is made multiple times, the microservice will recognize the duplicate request and return the same result as the original request. This ensures that the system remains consistent even if the same request is made multiple times.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n","url":"https://karthikselvam.com/posts/2023/01/23/transactions/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"23016-23-09T10:2323:00+00:00","date_modified":"23016-23-09T10:2323:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"eba735900b0ace564675c58fe0efb719545324fe","title":"Prototype Design Pattern Practice Qestions","summary":"2023","content_text":"Exercise 1: Basic Prototype Implementation Objective: Implement a basic prototype. Steps: Create an interface Prototype with a method Prototype clone(). Implement a class ConcretePrototype that implements Prototype and includes some fields. Demonstrate creating and cloning instances of ConcretePrototype.\nExercise 2: Deep vs. Shallow Copy Objective: Understand deep and shallow copying. Steps: Create a class Address with fields street and city. Modify ConcretePrototype to include an Address field. Implement both shallow and deep copy methods in ConcretePrototype. Demonstrate the differences between shallow and deep copying.\nExercise 3: Registry for Prototypes Objective: Use a prototype registry. Steps: Create a prototype registry class that maintains a map of prototype names to prototype instances. Implement methods to add prototypes to the registry and to create new instances by cloning prototypes. Demonstrate using the registry to create new instances of different prototypes.\nExercise 4: Prototype with Composition Objective: Implement the Prototype Pattern with composition. Steps: Create a class Document with fields title and a list of Page objects. Implement Page as a class with a content field. Implement cloning for both Document and Page classes. Demonstrate cloning a Document with multiple Page objects.\nExercise 5: Prototype Pattern in a Game Objective: Apply the Prototype Pattern in a real-world scenario. Steps: Create a class Enemy with fields type, health, and attackPower. Implement the clone method in Enemy. Create a registry for different types of enemies. Demonstrate cloning different types of enemies from the registry.\nExercise 6: Prototype with Immutable Objects Objective: Implement cloning for immutable objects. Steps: Create an immutable class Person with fields name and age. Implement a builder for Person to facilitate creating instances. Demonstrate creating and cloning immutable Person instances using the builder.\nExercise 7: Prototype with Polymorphism Objective: Use the Prototype Pattern with polymorphism. Steps: Create an abstract class Shape with a method clone(). Implement concrete classes Circle and Square that extend Shape. Create a registry of Shape objects. Demonstrate cloning different shapes from the registry.\n","content_html":"\u003cp\u003eExercise 1: Basic Prototype Implementation\nObjective: Implement a basic prototype.\nSteps:\nCreate an interface Prototype with a method Prototype clone().\nImplement a class ConcretePrototype that implements Prototype and includes some fields.\nDemonstrate creating and cloning instances of ConcretePrototype.\u003c/p\u003e\n\u003cp\u003eExercise 2: Deep vs. Shallow Copy\nObjective: Understand deep and shallow copying.\nSteps:\nCreate a class Address with fields street and city.\nModify ConcretePrototype to include an Address field.\nImplement both shallow and deep copy methods in ConcretePrototype.\nDemonstrate the differences between shallow and deep copying.\u003c/p\u003e\n\u003cp\u003eExercise 3: Registry for Prototypes\nObjective: Use a prototype registry.\nSteps:\nCreate a prototype registry class that maintains a map of prototype names to prototype instances.\nImplement methods to add prototypes to the registry and to create new instances by cloning prototypes.\nDemonstrate using the registry to create new instances of different prototypes.\u003c/p\u003e\n\u003cp\u003eExercise 4: Prototype with Composition\nObjective: Implement the Prototype Pattern with composition.\nSteps:\nCreate a class Document with fields title and a list of Page objects.\nImplement Page as a class with a content field.\nImplement cloning for both Document and Page classes.\nDemonstrate cloning a Document with multiple Page objects.\u003c/p\u003e\n\u003cp\u003eExercise 5: Prototype Pattern in a Game\nObjective: Apply the Prototype Pattern in a real-world scenario.\nSteps:\nCreate a class Enemy with fields type, health, and attackPower.\nImplement the clone method in Enemy.\nCreate a registry for different types of enemies.\nDemonstrate cloning different types of enemies from the registry.\u003c/p\u003e\n\u003cp\u003eExercise 6: Prototype with Immutable Objects\nObjective: Implement cloning for immutable objects.\nSteps:\nCreate an immutable class Person with fields name and age.\nImplement a builder for Person to facilitate creating instances.\nDemonstrate creating and cloning immutable Person instances using the builder.\u003c/p\u003e\n\u003cp\u003eExercise 7: Prototype with Polymorphism\nObjective: Use the Prototype Pattern with polymorphism.\nSteps:\nCreate an abstract class Shape with a method clone().\nImplement concrete classes Circle and Square that extend Shape.\nCreate a registry of Shape objects.\nDemonstrate cloning different shapes from the registry.\u003c/p\u003e\n","url":"https://karthikselvam.com/posts/2023/01/23/prototype_pattern/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"23016-23-09T10:2323:00+00:00","date_modified":"23016-23-09T10:2323:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"2786bfa0726b97fc4f665e04abf6324878196781","title":"Singleton Design Pattern Practice Qestions","summary":"2023","content_text":"Exercise 1: Basic Singleton Implementation Objective: Implement a basic Singleton Pattern. Steps: Create a Logger class that follows the Singleton Pattern. Ensure only one instance of Logger is created. Add a method log(String message) to log messages.\nExercise 2: Thread-Safe Singleton Objective: Implement a thread-safe Singleton. Steps: Modify the Logger class to make it thread-safe. Use the double-checked locking principle to ensure thread safety. Demonstrate logging from multiple threads.\nExercise 3: Lazy Initialization Objective: Implement Singleton with lazy initialization. Steps: Create a DatabaseConnection class that follows the Singleton Pattern with lazy initialization. Ensure the instance is created only when needed. Add a method connect() to simulate database connection.\nExercise 4: Singleton with Enum Objective: Implement Singleton using an enum. Steps: Create an enum Configuration that follows the Singleton Pattern. Add methods to set and get configuration values. Demonstrate setting and getting configuration values.\nExercise 5: Serialization and Singleton Objective: Ensure Singleton property during serialization. Steps: Create a Settings class that follows the Singleton Pattern. Ensure the Singleton property is maintained during serialization and deserialization. Demonstrate serialization and deserialization of Settings.\nExercise 6: Singleton and Reflection Objective: Protect Singleton from reflection attacks. Steps: Create a Preferences class that follows the Singleton Pattern. Protect the Singleton instance from being instantiated via reflection. Demonstrate the protection mechanism.\nExercise 7: Singleton in Multithreading Environment Objective: Implement a Singleton for a multi-threaded environment. Steps: Create a Cache class that follows the Singleton Pattern. Ensure the Cache class works correctly in a multi-threaded environment. Add methods to add and retrieve items from the cache.\nExercise 8: Singleton in Dependency Injection Objective: Integrate Singleton with a dependency injection framework. Steps: Choose a dependency injection framework (e.g., Spring). Create a ServiceManager class that follows the Singleton Pattern. Integrate ServiceManager with the chosen dependency injection framework. Demonstrate the injection of ServiceManager into a client class.\nExercise 9: Singleton with Bill Pugh Method Objective: Implement Singleton using Bill Pugh Singleton Design. Steps: Create a ResourceManager class that follows the Singleton Pattern using Bill Pugh Singleton Design. Ensure thread safety and lazy initialization. Demonstrate accessing the ResourceManager instance.\nExercise 10: Test Singleton Pattern Objective: Write unit tests for Singleton implementation. Steps: Choose a Singleton class (e.g., Logger). Write unit tests to ensure only one instance of the class is created. Write tests to ensure thread safety and correct behavior of methods\n","content_html":"\u003cp\u003eExercise 1: Basic Singleton Implementation\nObjective: Implement a basic Singleton Pattern.\nSteps:\nCreate a Logger class that follows the Singleton Pattern.\nEnsure only one instance of Logger is created.\nAdd a method log(String message) to log messages.\u003c/p\u003e\n\u003cp\u003eExercise 2: Thread-Safe Singleton\nObjective: Implement a thread-safe Singleton.\nSteps:\nModify the Logger class to make it thread-safe.\nUse the double-checked locking principle to ensure thread safety.\nDemonstrate logging from multiple threads.\u003c/p\u003e\n\u003cp\u003eExercise 3: Lazy Initialization\nObjective: Implement Singleton with lazy initialization.\nSteps:\nCreate a DatabaseConnection class that follows the Singleton Pattern with lazy initialization.\nEnsure the instance is created only when needed.\nAdd a method connect() to simulate database connection.\u003c/p\u003e\n\u003cp\u003eExercise 4: Singleton with Enum\nObjective: Implement Singleton using an enum.\nSteps:\nCreate an enum Configuration that follows the Singleton Pattern.\nAdd methods to set and get configuration values.\nDemonstrate setting and getting configuration values.\u003c/p\u003e\n\u003cp\u003eExercise 5: Serialization and Singleton\nObjective: Ensure Singleton property during serialization.\nSteps:\nCreate a Settings class that follows the Singleton Pattern.\nEnsure the Singleton property is maintained during serialization and deserialization.\nDemonstrate serialization and deserialization of Settings.\u003c/p\u003e\n\u003cp\u003eExercise 6: Singleton and Reflection\nObjective: Protect Singleton from reflection attacks.\nSteps:\nCreate a Preferences class that follows the Singleton Pattern.\nProtect the Singleton instance from being instantiated via reflection.\nDemonstrate the protection mechanism.\u003c/p\u003e\n\u003cp\u003eExercise 7: Singleton in Multithreading Environment\nObjective: Implement a Singleton for a multi-threaded environment.\nSteps:\nCreate a Cache class that follows the Singleton Pattern.\nEnsure the Cache class works correctly in a multi-threaded environment.\nAdd methods to add and retrieve items from the cache.\u003c/p\u003e\n\u003cp\u003eExercise 8: Singleton in Dependency Injection\nObjective: Integrate Singleton with a dependency injection framework.\nSteps:\nChoose a dependency injection framework (e.g., Spring).\nCreate a ServiceManager class that follows the Singleton Pattern.\nIntegrate ServiceManager with the chosen dependency injection framework.\nDemonstrate the injection of ServiceManager into a client class.\u003c/p\u003e\n\u003cp\u003eExercise 9: Singleton with Bill Pugh Method\nObjective: Implement Singleton using Bill Pugh Singleton Design.\nSteps:\nCreate a ResourceManager class that follows the Singleton Pattern using Bill Pugh Singleton Design.\nEnsure thread safety and lazy initialization.\nDemonstrate accessing the ResourceManager instance.\u003c/p\u003e\n\u003cp\u003eExercise 10: Test Singleton Pattern\nObjective: Write unit tests for Singleton implementation.\nSteps:\nChoose a Singleton class (e.g., Logger).\nWrite unit tests to ensure only one instance of the class is created.\nWrite tests to ensure thread safety and correct behavior of methods\u003c/p\u003e\n","url":"https://karthikselvam.com/posts/2023/01/23/singleton_pattern/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"23016-23-09T10:2323:00+00:00","date_modified":"23016-23-09T10:2323:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"1123e424eb0fd7f8a321618bed192d63a17e62d1","title":"Strategy Design Pattern Practice Qestions","summary":"2023","content_text":" Payment Processing System : Develop a payment processing system that supports multiple payment methods (e.g., Credit Card, PayPal, Bitcoin). Define an interface PaymentStrategy with a method pay(double amount). Implement concrete classes CreditCardPayment, PayPalPayment, and BitcoinPayment that implement the PaymentStrategy interface. Create an Order class that uses a PaymentStrategy to process payments. Demonstrate switching between different payment strategies at runtime. Text Formatting : Create a text editor that can format text in various ways (e.g., plain text, HTML, Markdown). Define an interface TextFormatter with a method format(String text). Implement concrete classes PlainTextFormatter, HTMLFormatter, and MarkdownFormatter that implement the TextFormatter interface. Create a TextEditor class that uses a TextFormatter to format text. Demonstrate changing the text formatting strategy at runtime. Travel Route Planning : Develop a travel planning application that can find routes using different transportation methods (e.g., Car, Bike, Walking). Define an interface RouteStrategy with a method calculateRoute(String start, String end). Implement concrete classes CarRoute, BikeRoute, and WalkingRoute that implement the RouteStrategy interface. Create a TravelPlanner class that uses a RouteStrategy to calculate routes. Demonstrate changing the route calculation strategy at runtime. Context-Aware Strategies : Create a recommendation system that provides different recommendations based on user context (e.g., Movie Recommendations, Book Recommendations, Product Recommendations). Define an interface RecommendationStrategy with a method recommend(String userContext). Implement concrete classes MovieRecommendation, BookRecommendation, and ProductRecommendation that implement the RecommendationStrategy interface. Create a Recommender class that uses a RecommendationStrategy to generate recommendations. Demonstrate adapting the recommendation strategy based on different user contexts. ","content_html":"\u003col\u003e\n\u003cli\u003ePayment Processing System  : Develop a payment processing system that supports multiple payment methods (e.g., Credit Card, PayPal, Bitcoin).\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eDefine an interface PaymentStrategy with a method pay(double amount).\u003c/li\u003e\n\u003cli\u003eImplement concrete classes CreditCardPayment, PayPalPayment, and BitcoinPayment that implement the PaymentStrategy interface.\u003c/li\u003e\n\u003cli\u003eCreate an Order class that uses a PaymentStrategy to process payments.\u003c/li\u003e\n\u003cli\u003eDemonstrate switching between different payment strategies at runtime.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eText Formatting : Create a text editor that can format text in various ways (e.g., plain text, HTML, Markdown).\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eDefine an interface TextFormatter with a method format(String text).\u003c/li\u003e\n\u003cli\u003eImplement concrete classes PlainTextFormatter, HTMLFormatter, and MarkdownFormatter that implement the TextFormatter interface.\u003c/li\u003e\n\u003cli\u003eCreate a TextEditor class that uses a TextFormatter to format text.\u003c/li\u003e\n\u003cli\u003eDemonstrate changing the text formatting strategy at runtime.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eTravel Route Planning : Develop a travel planning application that can find routes using different transportation methods (e.g., Car, Bike, Walking).\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eDefine an interface RouteStrategy with a method calculateRoute(String start, String end).\u003c/li\u003e\n\u003cli\u003eImplement concrete classes CarRoute, BikeRoute, and WalkingRoute that implement the RouteStrategy interface.\u003c/li\u003e\n\u003cli\u003eCreate a TravelPlanner class that uses a RouteStrategy to calculate routes.\u003c/li\u003e\n\u003cli\u003eDemonstrate changing the route calculation strategy at runtime.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003eContext-Aware Strategies : Create a recommendation system that provides different recommendations based on user context (e.g., Movie Recommendations, Book Recommendations, Product Recommendations).\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eDefine an interface RecommendationStrategy with a method recommend(String userContext).\u003c/li\u003e\n\u003cli\u003eImplement concrete classes MovieRecommendation, BookRecommendation, and ProductRecommendation that implement the RecommendationStrategy interface.\u003c/li\u003e\n\u003cli\u003eCreate a Recommender class that uses a RecommendationStrategy to generate recommendations.\u003c/li\u003e\n\u003cli\u003eDemonstrate adapting the recommendation strategy based on different user contexts.\u003c/li\u003e\n\u003c/ul\u003e\n","url":"https://karthikselvam.com/posts/2023/01/23/strategy_pattern_questions/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"23016-23-09T10:2323:00+00:00","date_modified":"23016-23-09T10:2323:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"a4c1692c7d833547388455ce5ff2a4e05d2457a6","title":"Structural Design Patterns","summary":"2023","content_text":"Structural Design Patterns are design patterns that focus on the composition of classes and objects to form larger structures, without changing their individual behaviors. They help to simplify the relationships between objects and classes in a system, and to make the system more flexible and efficient. Following are some of the commonly used structural design patterns.\n1. Adapter pattern : Adapter pattern is a structural design pattern that allows incompatible classes to work together by converting the interface of one class into another interface that clients expect. This pattern is useful when you have an existing class that cannot be changed, but you need to use it with other classes that have different interfaces.\nLet\u0026rsquo;s consider a car example to explain the Adapter pattern in Java. Suppose we have an existing class called \u0026ldquo;Car\u0026rdquo; that has a method called \u0026ldquo;drive()\u0026rdquo; that takes no arguments and starts the car. We also have another class called \u0026ldquo;Engine\u0026rdquo; that has a method called \u0026ldquo;start()\u0026rdquo; that starts the engine. However, the interfaces of these two classes are not compatible because the \u0026ldquo;drive()\u0026rdquo; method takes no arguments, while the \u0026ldquo;start()\u0026rdquo; method of the Engine class takes an argument.\nTo make these classes work together, we can create an adapter class called \u0026ldquo;EngineAdapter\u0026rdquo; that implements the Car interface and uses the Engine class to start the car. The EngineAdapter will have a reference to an Engine object and will use its \u0026ldquo;start()\u0026rdquo; method to start the car when the \u0026ldquo;drive()\u0026rdquo; method is called.\nHere is the example code in Java:\ninterface Car { void drive(); } class Engine { void start(String key) { System.out.println(\u0026quot;Starting engine with key: \u0026quot; + key); } } class EngineAdapter implements Car { private Engine engine; public EngineAdapter(Engine engine) { this.engine = engine; } @Override public void drive() { engine.start(\u0026quot;ignition key\u0026quot;); } } public class Main { public static void main(String[] args) { Engine engine = new Engine(); Car car = new EngineAdapter(engine); car.drive(); } } In this example, the EngineAdapter class adapts the Engine class to the Car interface by implementing the drive() method and using the start() method of the Engine class to start the car. When we call the drive() method on the Car object, it calls the start() method of the Engine object, which starts the car engine.\nIn summary, the Adapter pattern allows us to use incompatible classes together by creating an adapter class that implements the required interface and uses the existing class to provide the required functionality.\n2. Composite pattern : Adapter pattern is a structural design pattern that allows incompatible classes to work together by converting the interface of one class into another interface that clients expect. This pattern is useful when you have an existing class that cannot be changed, but you need to use it with other classes that have different interfaces.\n","content_html":"\u003cp\u003eStructural Design Patterns are design patterns that focus on the composition of classes and objects to form larger structures, without changing their individual behaviors. They help to simplify the relationships between objects and classes in a system, and to make the system more flexible and efficient. Following are some of the commonly used structural design patterns.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. Adapter pattern\u003c/strong\u003e : Adapter pattern is a structural design pattern that allows incompatible classes to work together by converting the interface of one class into another interface that clients expect. This pattern is useful when you have an existing class that cannot be changed, but you need to use it with other classes that have different interfaces.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s consider a car example to explain the Adapter pattern in Java. Suppose we have an existing class called \u0026ldquo;Car\u0026rdquo; that has a method called \u0026ldquo;drive()\u0026rdquo; that takes no arguments and starts the car. We also have another class called \u0026ldquo;Engine\u0026rdquo; that has a method called \u0026ldquo;start()\u0026rdquo; that starts the engine. However, the interfaces of these two classes are not compatible because the \u0026ldquo;drive()\u0026rdquo; method takes no arguments, while the \u0026ldquo;start()\u0026rdquo; method of the Engine class takes an argument.\u003c/p\u003e\n\u003cp\u003eTo make these classes work together, we can create an adapter class called \u0026ldquo;EngineAdapter\u0026rdquo; that implements the Car interface and uses the Engine class to start the car. The EngineAdapter will have a reference to an Engine object and will use its \u0026ldquo;start()\u0026rdquo; method to start the car when the \u0026ldquo;drive()\u0026rdquo; method is called.\u003c/p\u003e\n\u003cp\u003eHere is the example code in Java:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003einterface Car {\n    void drive();\n}\n\nclass Engine {\n    void start(String key) {\n        System.out.println(\u0026quot;Starting engine with key: \u0026quot; + key);\n    }\n}\n\nclass EngineAdapter implements Car {\n    private Engine engine;\n    \n    public EngineAdapter(Engine engine) {\n        this.engine = engine;\n    }\n    \n    @Override\n    public void drive() {\n        engine.start(\u0026quot;ignition key\u0026quot;);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Engine engine = new Engine();\n        Car car = new EngineAdapter(engine);\n        car.drive();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, the EngineAdapter class adapts the Engine class to the Car interface by implementing the drive() method and using the start() method of the Engine class to start the car. When we call the drive() method on the Car object, it calls the start() method of the Engine object, which starts the car engine.\u003c/p\u003e\n\u003cp\u003eIn summary, the Adapter pattern allows us to use incompatible classes together by creating an adapter class that implements the required interface and uses the existing class to provide the required functionality.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e2. Composite pattern\u003c/strong\u003e : Adapter pattern is a structural design pattern that allows incompatible classes to work together by converting the interface of one class into another interface that clients expect. This pattern is useful when you have an existing class that cannot be changed, but you need to use it with other classes that have different interfaces.\u003c/p\u003e\n","url":"https://karthikselvam.com/posts/2023/01/23/structural_patterns/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"23016-23-09T10:2323:00+00:00","date_modified":"23016-23-09T10:2323:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e","title":"Arrays","summary":"2023","content_text":"In this article, we will solve array-related problems that are commonly encountered in interviews.\n1. Contains Duplicate.\nclass Solution { public boolean containsDuplicate(int[] nums) { // Use a hash set to keep track of seen elements HashSet\u0026lt;Integer\u0026gt; seen = new HashSet\u0026lt;\u0026gt;(); for (int num : nums) { // If we've already seen this element, then we have a duplicate if (seen.contains(num)) { return true; } // Otherwise, add it to the set seen.add(num); } // If we make it through the loop without finding a duplicate, then there isn't one return false; } } Time complexity: O(n) We loop through the array of integers once, which takes O(n) time. The hash set\u0026rsquo;s average time complexity for insertion and lookup is O(1), so the total time complexity of the loop is also O(n).\nSpace complexity: O(n) In the worst case, all elements in the input array are distinct and we must store them all in the hash set. The hash set will therefore have a size of n, so the space complexity is O(n).\n2. Valid Anagram.\npublic boolean isAnagram(String s, String t) { // Check if the lengths of the two strings are the same if (s.length() != t.length()) { return false; } // Create an array to count the occurrences of characters int[] count = new int[26]; // Iterate over the two strings and update the count array for (int i = 0; i \u0026lt; s.length(); i++) { // Increment the count of the character in the first string count[s.charAt(i) - 'a']++; // Decrement the count of the character in the second string count[t.charAt(i) - 'a']--; } // Iterate over the count array and check if all the counts are 0 for (int c : count) { if (c != 0) { // If any count is non-zero, the two strings are not anagrams return false; } } // If all counts are 0, the two strings are anagrams return true; } Time complexity: O(n), where n is the length of the strings, since we iterate over the two strings once.\nSpace complexity: O(1), since we use a fixed-size array of size 26 to count the occurrences of characters.\n3. Two Sum.\npublic int[] twoSum(int[] nums, int target) { // Create a hash table to store the indices of each element Map\u0026lt;Integer, Integer\u0026gt; indexMap = new HashMap\u0026lt;\u0026gt;(); // Iterate over the array for (int i = 0; i \u0026lt; nums.length; i++) { // Calculate the complement of the current element int complement = target - nums[i]; // Check if the complement is in the hash table if (indexMap.containsKey(complement)) { // If it is, return the indices of the two numbers return new int[] { indexMap.get(complement), i }; } // If the complement is not in the hash table, add the current element and its index indexMap.put(nums[i], i); } // If no two numbers add up to the target, return null return null; } Time complexity: O(n), where n is the length of the array, since we iterate over the array once.\nSpace complexity: O(n), since we may store all n elements of the array in the hash table.\n4. Group Anagrams.\nclass Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) { // create a map to store the anagram groups Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // iterate through each string in the input array for (String str : strs) { // convert the string to a character array char[] arr = str.toCharArray(); // sort the characters in the array Arrays.sort(arr); // create a new string from the sorted characters String sorted = new String(arr); // check if the sorted string is already a key in the map if (!map.containsKey(sorted)) { // if not, create a new list for this group map.put(sorted, new ArrayList\u0026lt;\u0026gt;()); } // add the current string to the appropriate group map.get(sorted).add(str); } // create a list to hold the anagram groups List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groups = new ArrayList\u0026lt;\u0026gt;(); // add each group to the list for (List\u0026lt;String\u0026gt; group : map.values()) { groups.add(group); } // return the list of anagram groups return groups; } } Time complexity: O(n * k log k), where n is the number of strings in the input array and k is the maximum length of a string in the array. The main loop iterates through each string in the array and sorts its characters, which takes O(k log k) time per string.\nSpace complexity: O(n * k), where n is the number of strings in the input array and k is the maximum length of a string in the array. The map can potentially store all n strings, and each string may have up to k characters. Additionally, the list of anagram groups also takes O(n * k) space.\n5. Product of Array Except Self.\nclass Solution { public int[] productExceptSelf(int[] nums) { int n = nums.length; int[] res = new int[n]; // Initialize the result array with 1 for (int i = 0; i \u0026lt; n; i++) { res[i] = 1; } // Calculate the left products int left = 1; for (int i = 1; i \u0026lt; n; i++) { left *= nums[i - 1]; res[i] *= left; } // Calculate the right products int right = 1; for (int i = n - 2; i \u0026gt;= 0; i--) { right *= nums[i + 1]; res[i] *= right; } return res; } } Suppose we have the input array nums = [1, 2, 3, 4]. The goal is to calculate the product of all elements in the array except the current element. In other words, for each element nums[i], we need to calculate the product of all elements except nums[i].\nTo solve this problem, we can first initialize the result array res with all ones, because the product of any number with one is the number itself. So, res = [1, 1, 1, 1].\nNext, we traverse the array from left to right and calculate the product of all elements to the left of each element. For the first element, there are no elements to the left, so we skip it. For the second element, the product of all elements to the left is simply the first element, so we set res[1] to 1 * 1 = 1. For the third element, the product of all elements to the left is 1 * 2 = 2, so we set res[2] to 1 * 2 = 2. For the fourth element, the product of all elements to the left is 1 * 2 * 3 = 6, so we set res[3] to 1 * 2 * 3 = 6. After this step, res = [1, 1, 2, 6].\nNext, we traverse the array from right to left and calculate the product of all elements to the right of each element. For the last element, there are no elements to the right, so we skip it. For the third element, the product of all elements to the right is simply the fourth element, so we set res[2] to 2 * 4 = 8. For the second element, the product of all elements to the right is 4 * 3 = 12, so we set res[1] to 1 * 12 = 12. For the first element, the product of all elements to the right is 4 * 3 * 2 = 24, so we set res[0] to 1 * 24 = 24. After this step, res = [24, 12, 8, 6].\nThus, the output for the input array nums = [1, 2, 3, 4] is [24, 12, 8, 6], which is the product of all elements in the array except the current element.\nTime Complexity: O(n) - The solution traverses the array three times, each taking O(n) time. Thus, the overall time complexity is O(n).\nSpace Complexity: O(1) - The solution uses only constant space for storing the variables, and the output array is not considered in the space complexity calculation.If we consider the output array in the space complexity calculation, the space complexity would be O(n).\n5. Top K Frequent Elements.\npublic int[] topKFrequent(int[] nums, int k) { HashMap\u0026lt;Integer,Integer\u0026gt; map = new HashMap\u0026lt;Integer,Integer\u0026gt;(); for(int num : nums){ map.put(num,map.getOrDefault(num,0)+1); } // Sorting in ascending order //PriorityQueue\u0026lt;Map.Entry\u0026lt;Integer,Integer\u0026gt;\u0026gt; minHeap = new PriorityQueue\u0026lt;Map.Entry\u0026lt;Integer,Integer\u0026gt;\u0026gt;((e1,e2) -\u0026gt; e1.getValue() - e2.getValue()); PriorityQueue\u0026lt;Map.Entry\u0026lt;Integer,Integer\u0026gt;\u0026gt; maxHeap = new PriorityQueue\u0026lt;Map.Entry\u0026lt;Integer,Integer\u0026gt;\u0026gt;((e1,e2) -\u0026gt; e2.getValue() - e1.getValue()); for(Map.Entry\u0026lt;Integer,Integer\u0026gt; entry : map.entrySet()) { maxHeap.add(entry) ; } int i = 0; int[] result = new int[k]; while(i \u0026lt; k){ Map.Entry\u0026lt;Integer,Integer\u0026gt; currEntry = maxHeap.poll() ; result[i] = currEntry.getKey(); i++; } return result; } Time Complexity: Building the HashMap takes O(n) time, as we need to iterate through the entire input array. Building the PriorityQueue takes O(n log k) time. For each element in the HashMap, we perform an operation that takes O(log k) time to add the entry to the priority queue. We do this operation n times, so the total time complexity of building the PriorityQueue is O(n log k). Extracting the top k frequent elements from the PriorityQueue takes O(k log n) time. We perform the poll operation k times, which takes O(log n) time each time. Therefore, the overall time complexity of the topKFrequent method is O(n log k).\nSpace Complexity: O(n) because we need to store the frequency of each element in the input array in the HashMap. The size of the HashMap is bounded by the number of distinct elements in the input array, which is at most n. The PriorityQueue can also have at most k elements, so its space complexity is O(k). Combining these two space requirements, the overall space complexity of the topKFrequent method is O(n).\n6. Longest Consecutive Sequence.\nclass Solution { public int longestConsecutive(int[] nums) { if (nums == null || nums.length == 0) return 0; HashSet\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int num : nums) { set.add(num); } int longestStreak = 0; for (int num : nums) { if (!set.contains(num - 1)) { // Only process if it's the start of a sequence int currentNum = num; int currentStreak = 1; while (set.contains(currentNum + 1)) { currentNum++; currentStreak++; } longestStreak = Math.max(longestStreak, currentStreak); } } return longestStreak; } } Time complexity: Building the HashSet initially takes O(n) time, as we need to add each element of the array to the HashSet.The subsequent iteration over the array takes O(n) time as well, as we examine each element exactly once. Within the iteration, the while loop that checks for consecutive elements also takes O(n) time in the worst case, but it does not run for each element. It runs only when we encounter the start of a consecutive sequence, which happens relatively infrequently in practice.\nSpace complexity: O(n), This is because we use a HashSet to store the elements of the array, which can take up to O(n) space in the worst case if all elements are unique.\n","content_html":"\u003cp\u003eIn this article, we will solve array-related problems that are commonly encountered in interviews.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. \u003ca href=\"https://leetcode.com/problems/contains-duplicate/\"\u003eContains Duplicate\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        // Use a hash set to keep track of seen elements\n        HashSet\u0026lt;Integer\u0026gt; seen = new HashSet\u0026lt;\u0026gt;();\n        \n        for (int num : nums) {\n            // If we've already seen this element, then we have a duplicate\n            if (seen.contains(num)) {\n                return true;\n            }\n            \n            // Otherwise, add it to the set\n            seen.add(num);\n        }\n        \n        // If we make it through the loop without finding a duplicate, then there isn't one\n        return false;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n) We loop through the array of integers once, which takes O(n) time.\nThe hash set\u0026rsquo;s average time complexity for insertion and lookup is O(1), so the total time complexity of the loop is also O(n).\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(n) In the worst case, all elements in the input array are distinct and we must store them all in the hash set. The hash set will therefore have a size of n, so the space complexity is O(n).\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e2. \u003ca href=\"https://leetcode.com/problems/valid-anagram/\"\u003eValid Anagram\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic boolean isAnagram(String s, String t) {\n    // Check if the lengths of the two strings are the same\n    if (s.length() != t.length()) {\n        return false;\n    }\n    \n    // Create an array to count the occurrences of characters\n    int[] count = new int[26];\n    \n    // Iterate over the two strings and update the count array\n    for (int i = 0; i \u0026lt; s.length(); i++) {\n        // Increment the count of the character in the first string\n        count[s.charAt(i) - 'a']++;\n        // Decrement the count of the character in the second string\n        count[t.charAt(i) - 'a']--;\n    }\n    \n    // Iterate over the count array and check if all the counts are 0\n    for (int c : count) {\n        if (c != 0) {\n            // If any count is non-zero, the two strings are not anagrams\n            return false;\n        }\n    }\n    \n    // If all counts are 0, the two strings are anagrams\n    return true;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n), where n is the length of the strings, since we iterate over the two strings once.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(1), since we use a fixed-size array of size 26 to count the occurrences of characters.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e3. \u003ca href=\"https://leetcode.com/problems/two-sum/\"\u003eTwo Sum\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic int[] twoSum(int[] nums, int target) {\n    // Create a hash table to store the indices of each element\n    Map\u0026lt;Integer, Integer\u0026gt; indexMap = new HashMap\u0026lt;\u0026gt;();\n    \n    // Iterate over the array\n    for (int i = 0; i \u0026lt; nums.length; i++) {\n        // Calculate the complement of the current element\n        int complement = target - nums[i];\n        // Check if the complement is in the hash table\n        if (indexMap.containsKey(complement)) {\n            // If it is, return the indices of the two numbers\n            return new int[] { indexMap.get(complement), i };\n        }\n        // If the complement is not in the hash table, add the current element and its index\n        indexMap.put(nums[i], i);\n    }\n    \n    // If no two numbers add up to the target, return null\n    return null;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n), where n is the length of the array, since we iterate over the array once.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(n), since we may store all n elements of the array in the hash table.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e4. \u003ca href=\"https://leetcode.com/problems/group-anagrams/\"\u003eGroup Anagrams\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) {\n        // create a map to store the anagram groups\n        Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;();\n        \n        // iterate through each string in the input array\n        for (String str : strs) {\n            // convert the string to a character array\n            char[] arr = str.toCharArray();\n            // sort the characters in the array\n            Arrays.sort(arr);\n            // create a new string from the sorted characters\n            String sorted = new String(arr);\n            \n            // check if the sorted string is already a key in the map\n            if (!map.containsKey(sorted)) {\n                // if not, create a new list for this group\n                map.put(sorted, new ArrayList\u0026lt;\u0026gt;());\n            }\n            \n            // add the current string to the appropriate group\n            map.get(sorted).add(str);\n        }\n        \n        // create a list to hold the anagram groups\n        List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groups = new ArrayList\u0026lt;\u0026gt;();\n        \n        // add each group to the list\n        for (List\u0026lt;String\u0026gt; group : map.values()) {\n            groups.add(group);\n        }\n        \n        // return the list of anagram groups\n        return groups;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n * k log k), where n is the number of strings in the input array and k is the maximum length of a string in the array. The main loop iterates through each string in the array and sorts its characters, which takes O(k log k) time per string.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(n * k), where n is the number of strings in the input array and k is the maximum length of a string in the array. The map can potentially store all n strings, and each string may have up to k characters. Additionally, the list of anagram groups also takes O(n * k) space.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e5. \u003ca href=\"https://leetcode.com/problems/product-of-array-except-self/\"\u003eProduct of Array Except Self\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        int[] res = new int[n];\n        \n        // Initialize the result array with 1\n        for (int i = 0; i \u0026lt; n; i++) {\n            res[i] = 1;\n        }\n        \n        // Calculate the left products\n        int left = 1;\n        for (int i = 1; i \u0026lt; n; i++) {\n            left *= nums[i - 1];\n            res[i] *= left;\n        }\n        \n        // Calculate the right products\n        int right = 1;\n        for (int i = n - 2; i \u0026gt;= 0; i--) {\n            right *= nums[i + 1];\n            res[i] *= right;\n        }\n        \n        return res;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSuppose we have the input array nums = [1, 2, 3, 4]. The goal is to calculate the product of all elements in the array except the current element. In other words, for each element nums[i], we need to calculate the product of all elements except nums[i].\u003c/p\u003e\n\u003cp\u003eTo solve this problem, we can first initialize the result array res with all ones, because the product of any number with one is the number itself. So, res = [1, 1, 1, 1].\u003c/p\u003e\n\u003cp\u003eNext, we traverse the array from left to right and calculate the product of all elements to the left of each element. For the first element, there are no elements to the left, so we skip it. For the second element, the product of all elements to the left is simply the first element, so we set res[1] to 1 * 1 = 1. For the third element, the product of all elements to the left is 1 * 2 = 2, so we set res[2] to 1 * 2 = 2. For the fourth element, the product of all elements to the left is 1 * 2 * 3 = 6, so we set res[3] to 1 * 2 * 3 = 6. After this step, res = [1, 1, 2, 6].\u003c/p\u003e\n\u003cp\u003eNext, we traverse the array from right to left and calculate the product of all elements to the right of each element. For the last element, there are no elements to the right, so we skip it. For the third element, the product of all elements to the right is simply the fourth element, so we set res[2] to 2 * 4 = 8. For the second element, the product of all elements to the right is 4 * 3 = 12, so we set res[1] to 1 * 12 = 12. For the first element, the product of all elements to the right is 4 * 3 * 2 = 24, so we set res[0] to 1 * 24 = 24. After this step, res = [24, 12, 8, 6].\u003c/p\u003e\n\u003cp\u003eThus, the output for the input array nums = [1, 2, 3, 4] is [24, 12, 8, 6], which is the product of all elements in the array except the current element.\u003c/p\u003e\n\u003cp\u003eTime Complexity: O(n) - The solution traverses the array three times, each taking O(n) time. Thus, the overall time complexity is O(n).\u003c/p\u003e\n\u003cp\u003eSpace Complexity: O(1) - The solution uses only constant space for storing the variables, and the output array is not considered in the space complexity calculation.If we consider the output array in the space complexity calculation, the space complexity would be O(n).\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e5. \u003ca href=\"https://leetcode.com/problems/top-k-frequent-elements/description/\"\u003eTop K Frequent Elements\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public int[] topKFrequent(int[] nums, int k) {\n        HashMap\u0026lt;Integer,Integer\u0026gt; map = new HashMap\u0026lt;Integer,Integer\u0026gt;();\n        for(int num : nums){\n            map.put(num,map.getOrDefault(num,0)+1);\n        }\n        // Sorting in ascending order\n        //PriorityQueue\u0026lt;Map.Entry\u0026lt;Integer,Integer\u0026gt;\u0026gt; minHeap = new PriorityQueue\u0026lt;Map.Entry\u0026lt;Integer,Integer\u0026gt;\u0026gt;((e1,e2) -\u0026gt; e1.getValue() - e2.getValue());\n        PriorityQueue\u0026lt;Map.Entry\u0026lt;Integer,Integer\u0026gt;\u0026gt; maxHeap = new PriorityQueue\u0026lt;Map.Entry\u0026lt;Integer,Integer\u0026gt;\u0026gt;((e1,e2) -\u0026gt; e2.getValue() - e1.getValue());\n        for(Map.Entry\u0026lt;Integer,Integer\u0026gt; entry : map.entrySet()) {\n           maxHeap.add(entry) ;\n        }\n        int i = 0; \n        int[] result = new int[k];\n        while(i \u0026lt; k){\n           Map.Entry\u0026lt;Integer,Integer\u0026gt; currEntry = maxHeap.poll() ;\n           result[i] = currEntry.getKey();\n            i++;\n        }\n          return result;  \n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime Complexity: Building the HashMap takes O(n) time, as we need to iterate through the entire input array.\nBuilding the PriorityQueue takes O(n log k) time. For each element in the HashMap, we perform an operation that takes O(log k) time to add the entry to the priority queue. We do this operation n times, so the total time complexity of building the PriorityQueue is O(n log k). Extracting the top k frequent elements from the PriorityQueue takes O(k log n) time. We perform the poll operation k times, which takes O(log n) time each time. Therefore, the overall time complexity of the topKFrequent method is O(n log k).\u003c/p\u003e\n\u003cp\u003eSpace Complexity: O(n) because we need to store the frequency of each element in the input array in the HashMap. The size of the HashMap is bounded by the number of distinct elements in the input array, which is at most n. The PriorityQueue can also have at most k elements, so its space complexity is O(k). Combining these two space requirements, the overall space complexity of the topKFrequent method is O(n).\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e6. \u003ca href=\"https://leetcode.com/problems/longest-consecutive-sequence\"\u003eLongest Consecutive Sequence\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public int longestConsecutive(int[] nums) {\n        if (nums == null || nums.length == 0)\n            return 0;\n\n        HashSet\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;();\n        for (int num : nums) {\n            set.add(num);\n        }\n\n        int longestStreak = 0;\n\n        for (int num : nums) {\n            if (!set.contains(num - 1)) { // Only process if it's the start of a sequence\n                int currentNum = num;\n                int currentStreak = 1;\n\n                while (set.contains(currentNum + 1)) {\n                    currentNum++;\n                    currentStreak++;\n                }\n\n                longestStreak = Math.max(longestStreak, currentStreak);\n            }\n        }\n\n        return longestStreak;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: Building the HashSet initially takes O(n) time, as we need to add each element of the array to the HashSet.The subsequent iteration over the array takes O(n) time as well, as we examine each element exactly once. Within the iteration, the while loop that checks for consecutive elements also takes O(n) time in the worst case, but it does not run for each element. It runs only when we encounter the start of a consecutive sequence, which happens relatively infrequently in practice.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(n), This is because we use a HashSet to store the elements of the array, which can take up to O(n) space in the worst case if all elements are unique.\u003c/p\u003e\n\u003chr\u003e\n","url":"https://karthikselvam.com/posts/2023/01/22/arrays/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"22016-22-09T10:2222:00+00:00","date_modified":"22016-22-09T10:2222:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e","title":"Arrays","summary":"2023","content_text":"1. Tell me about a time when you went above and beyond to meet customer needs. Situation: In my previous role as a Senior Software Development Engineer at [Company Name], we had a critical customer who relied heavily on one of our core services for their day-to-day operations. The service was generally reliable, but we noticed an increase in latency during peak hours, which started to affect the customer’s business. They were experiencing delays that disrupted their workflow, leading to frustration and potential loss of business for them.\nTask: As the senior engineer responsible for the service, I was tasked with investigating the root cause of the latency and finding a solution. The challenge was that this issue was intermittent and had not surfaced in our regular testing or monitoring processes. Additionally, the customer had an important launch event in two weeks, and they needed this issue resolved before then.\nAction: I decided to go beyond the typical debugging process and took the following steps:\nDeep Dive into Logs: I led a detailed analysis of logs and metrics from both our production and pre-production environments to identify patterns during peak times. I involved the DevOps team to help simulate the exact production load in a controlled environment.\nCustomer Collaboration: I personally reached out to the customer’s technical team to understand the specific scenarios where they were facing issues. This allowed me to replicate their exact usage patterns and identify bottlenecks that weren’t evident in generic load testing.\nOptimizing the Code: Upon identifying the bottleneck, I worked on optimizing the service\u0026rsquo;s code, specifically focusing on the database queries and caching mechanisms that were causing the delays. I also refactored parts of the code to make the service more resilient under heavy load.\nProactive Communication: Throughout this process, I kept the customer informed about our progress, ensuring that they felt supported and knew we were prioritizing their needs.\nTesting and Deployment: Once the optimizations were implemented, I coordinated with the QA team to conduct rigorous testing. I also worked with the DevOps team to deploy the changes in a phased manner, closely monitoring the service during the deployment to ensure there were no regressions.\nResult: The optimization efforts reduced the service\u0026rsquo;s latency by 60% during peak hours, which significantly improved the customer’s experience. The issue was resolved well before their launch event, and they were able to proceed without any disruptions. The customer was highly appreciative of the proactive approach and the level of detail we went into to solve their problem. This not only strengthened our relationship with them but also led to a long-term partnership and additional business opportunities.\nReflection: This experience reinforced the importance of being customer-obsessed, especially in a senior role. Going beyond the expected duties, engaging directly with the customer, and ensuring that their needs are met, even under tight deadlines, is crucial in building trust and delivering exceptional service.\n2. Can you provide an example of a time when you received negative customer feedback? What did you do to address it? Situation: In my previous role as a Senior Software Development Engineer at [Company Name], we launched a new version of our platform with several major updates and features. However, shortly after the release, we started receiving negative feedback from a key customer segment. They reported that the new user interface was confusing, and some of the features they relied on were either harder to access or didn’t work as expected.\nTask: As the senior engineer responsible for this project, my task was to address the feedback promptly. This involved understanding the root cause of the issues, devising a plan to resolve them, and restoring customer satisfaction.\nAction: To tackle this, I took the following steps:\nEngage Directly with Customers: I initiated direct communication with the affected customers to gather detailed feedback. I set up calls and meetings with key users to understand their specific pain points and how the changes impacted their workflow. This allowed me to get a clearer picture of the issues beyond what was reported in generic feedback channels.\nAnalyze the Feedback: I worked closely with the UX team to analyze the feedback and identify common patterns. We discovered that the navigation changes we made, though intended to streamline the interface, had unintentionally made it harder for some users to complete their tasks efficiently. Additionally, there were a few bugs in the new features that had slipped through our testing process.\nImplement Rapid Improvements: Based on the feedback, I prioritized quick wins that could immediately improve the user experience. We rolled out a patch that fixed the bugs and made some immediate adjustments to the navigation flow based on customer input. I also proposed and led a short-term project to create customizable interface options, allowing users to revert to a layout closer to the previous version if they preferred it.\nProactive Communication: Throughout this process, I maintained open lines of communication with the affected customers, providing regular updates on our progress and the changes we were making. I also took the opportunity to thank them for their feedback and assured them that we were committed to addressing their concerns.\nPost-Release Follow-Up: After the changes were implemented, I followed up with the customers to gather additional feedback and ensure the modifications addressed their issues. I also monitored the platform for further feedback to ensure the improvements were well-received.\nResult: The quick response and the adjustments we made led to a significant reduction in customer complaints, and the feedback shifted from negative to positive. The customizable interface option was particularly well-received, as it gave users more control over their experience. Our relationship with the customers improved, and they appreciated our responsiveness and willingness to adapt based on their needs.\nReflection: This experience reinforced the importance of actively listening to customer feedback and being agile in responding to it. By engaging directly with customers and being transparent about the steps we were taking, we were able to turn a negative situation into a positive one, ultimately enhancing the customer experience and strengthening our product.\n3. Tell me about a time when you had to deliver a product or feature under a tight deadline. How did you ensure it met customer expectations?? Situation: At my previous company, we had a client who requested a new feature for their application just weeks before their product launch. The feature was crucial for their marketing campaign, and they needed it delivered within an extremely tight deadline of two weeks.\nTask: As the lead developer, my task was to ensure that we delivered a fully functional, high-quality feature on time, without compromising our existing development schedule.\nAction: I started by breaking down the feature requirements into manageable tasks and prioritized them based on the client’s most critical needs. I then assembled a small team of developers and designers, ensuring everyone was clear on their responsibilities and the importance of meeting the deadline.\nTo maximize efficiency, I implemented daily stand-up meetings to track progress, identify any roadblocks early, and make quick decisions. I also set up a continuous integration pipeline to automate testing and deployment, so that we could catch and fix bugs as early as possible.\nThroughout the development process, I maintained close communication with the client to keep them updated on our progress and to manage their expectations. This also allowed us to get quick feedback on the feature’s implementation, ensuring we were aligned with their vision.\nResult: We successfully delivered the feature on time, and it met the client’s expectations in terms of functionality and quality. The client was impressed with our ability to meet such a tight deadline without compromising on the end product. This experience not only strengthened our relationship with the client but also demonstrated our team’s ability to work efficiently under pressure.\n4. Tell about a time you disagreed with your teamamt? Situation: In one of my previous projects, we were tasked with breaking down a monolithic application into microservices. The goal was to improve scalability and maintainability.\nTask: My role was to design the microservices architecture and ensure a smooth transition from the monolithic system. However, a teammate and I had a fundamental disagreement about how to approach this.\nAction: My teammate advocated for a \u0026ldquo;big bang\u0026rdquo; approach, where we would decompose the entire application at once and deploy all microservices simultaneously. They believed this would be more efficient and faster. I, on the other hand, favored an incremental approach. I suggested breaking down the application one component at a time, deploying each microservice individually, and ensuring that each one worked correctly before moving on to the next. I felt this would minimize risk and make it easier to identify and fix issues.\nTo resolve the disagreement, we decided to: Discuss Concerns: We sat down and outlined the pros and cons of both approaches. I highlighted the potential risks of a \u0026ldquo;big bang\u0026rdquo; deployment, such as the difficulty in debugging and the high impact of potential failures. Run Experiments: We agreed to conduct a proof-of-concept by splitting one part of the monolith into a microservice and deploying it. This would give us insights into the complexity and potential issues we might face. Consult with Stakeholders: We brought in our tech lead and a few other senior engineers to get their perspectives and advice. They supported the idea of an incremental approach given the complexity of our system.\nResult: The proof-of-concept was successful and demonstrated the benefits of an incremental approach. It allowed us to catch and resolve issues early, and it provided the team with valuable learning experiences. As a result, we adopted the incremental approach for the rest of the project.\nIn the end, the project was a success. The incremental approach proved to be effective in managing risks and ensuring a smooth transition to microservices. This experience reinforced the importance of open communication, experimentation, and involving stakeholders in decision-making processes.\n","content_html":"\u003cp\u003e\u003cstrong\u003e1. Tell me about a time when you went above and beyond to meet customer needs.\u003c/strong\u003e\nSituation: In my previous role as a Senior Software Development Engineer at [Company Name], we had a critical customer who relied heavily on one of our core services for their day-to-day operations. The service was generally reliable, but we noticed an increase in latency during peak hours, which started to affect the customer’s business. They were experiencing delays that disrupted their workflow, leading to frustration and potential loss of business for them.\u003c/p\u003e\n\u003cp\u003eTask: As the senior engineer responsible for the service, I was tasked with investigating the root cause of the latency and finding a solution. The challenge was that this issue was intermittent and had not surfaced in our regular testing or monitoring processes. Additionally, the customer had an important launch event in two weeks, and they needed this issue resolved before then.\u003c/p\u003e\n\u003cp\u003eAction:\nI decided to go beyond the typical debugging process and took the following steps:\u003c/p\u003e\n\u003cp\u003eDeep Dive into Logs: I led a detailed analysis of logs and metrics from both our production and pre-production environments to identify patterns during peak times. I involved the DevOps team to help simulate the exact production load in a controlled environment.\u003c/p\u003e\n\u003cp\u003eCustomer Collaboration: I personally reached out to the customer’s technical team to understand the specific scenarios where they were facing issues. This allowed me to replicate their exact usage patterns and identify bottlenecks that weren’t evident in generic load testing.\u003c/p\u003e\n\u003cp\u003eOptimizing the Code: Upon identifying the bottleneck, I worked on optimizing the service\u0026rsquo;s code, specifically focusing on the database queries and caching mechanisms that were causing the delays. I also refactored parts of the code to make the service more resilient under heavy load.\u003c/p\u003e\n\u003cp\u003eProactive Communication: Throughout this process, I kept the customer informed about our progress, ensuring that they felt supported and knew we were prioritizing their needs.\u003c/p\u003e\n\u003cp\u003eTesting and Deployment: Once the optimizations were implemented, I coordinated with the QA team to conduct rigorous testing. I also worked with the DevOps team to deploy the changes in a phased manner, closely monitoring the service during the deployment to ensure there were no regressions.\u003c/p\u003e\n\u003cp\u003eResult:\nThe optimization efforts reduced the service\u0026rsquo;s latency by 60% during peak hours, which significantly improved the customer’s experience. The issue was resolved well before their launch event, and they were able to proceed without any disruptions. The customer was highly appreciative of the proactive approach and the level of detail we went into to solve their problem. This not only strengthened our relationship with them but also led to a long-term partnership and additional business opportunities.\u003c/p\u003e\n\u003cp\u003eReflection:\nThis experience reinforced the importance of being customer-obsessed, especially in a senior role. Going beyond the expected duties, engaging directly with the customer, and ensuring that their needs are met, even under tight deadlines, is crucial in building trust and delivering exceptional service.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2. Can you provide an example of a time when you received negative customer feedback? What did you do to address it?\u003c/strong\u003e\nSituation:\nIn my previous role as a Senior Software Development Engineer at [Company Name], we launched a new version of our platform with several major updates and features. However, shortly after the release, we started receiving negative feedback from a key customer segment. They reported that the new user interface was confusing, and some of the features they relied on were either harder to access or didn’t work as expected.\u003c/p\u003e\n\u003cp\u003eTask:\nAs the senior engineer responsible for this project, my task was to address the feedback promptly. This involved understanding the root cause of the issues, devising a plan to resolve them, and restoring customer satisfaction.\u003c/p\u003e\n\u003cp\u003eAction:\nTo tackle this, I took the following steps:\u003c/p\u003e\n\u003cp\u003eEngage Directly with Customers:\nI initiated direct communication with the affected customers to gather detailed feedback. I set up calls and meetings with key users to understand their specific pain points and how the changes impacted their workflow. This allowed me to get a clearer picture of the issues beyond what was reported in generic feedback channels.\u003c/p\u003e\n\u003cp\u003eAnalyze the Feedback:\nI worked closely with the UX team to analyze the feedback and identify common patterns. We discovered that the navigation changes we made, though intended to streamline the interface, had unintentionally made it harder for some users to complete their tasks efficiently. Additionally, there were a few bugs in the new features that had slipped through our testing process.\u003c/p\u003e\n\u003cp\u003eImplement Rapid Improvements:\nBased on the feedback, I prioritized quick wins that could immediately improve the user experience. We rolled out a patch that fixed the bugs and made some immediate adjustments to the navigation flow based on customer input.\nI also proposed and led a short-term project to create customizable interface options, allowing users to revert to a layout closer to the previous version if they preferred it.\u003c/p\u003e\n\u003cp\u003eProactive Communication:\nThroughout this process, I maintained open lines of communication with the affected customers, providing regular updates on our progress and the changes we were making. I also took the opportunity to thank them for their feedback and assured them that we were committed to addressing their concerns.\u003c/p\u003e\n\u003cp\u003ePost-Release Follow-Up:\nAfter the changes were implemented, I followed up with the customers to gather additional feedback and ensure the modifications addressed their issues. I also monitored the platform for further feedback to ensure the improvements were well-received.\u003c/p\u003e\n\u003cp\u003eResult:\nThe quick response and the adjustments we made led to a significant reduction in customer complaints, and the feedback shifted from negative to positive. The customizable interface option was particularly well-received, as it gave users more control over their experience. Our relationship with the customers improved, and they appreciated our responsiveness and willingness to adapt based on their needs.\u003c/p\u003e\n\u003cp\u003eReflection:\nThis experience reinforced the importance of actively listening to customer feedback and being agile in responding to it. By engaging directly with customers and being transparent about the steps we were taking, we were able to turn a negative situation into a positive one, ultimately enhancing the customer experience and strengthening our product.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e3. Tell me about a time when you had to deliver a product or feature under a tight deadline. How did you ensure it met customer expectations??\u003c/strong\u003e\nSituation: At my previous company, we had a client who requested a new feature for their application just weeks before their product launch. The feature was crucial for their marketing campaign, and they needed it delivered within an extremely tight deadline of two weeks.\u003c/p\u003e\n\u003cp\u003eTask: As the lead developer, my task was to ensure that we delivered a fully functional, high-quality feature on time, without compromising our existing development schedule.\u003c/p\u003e\n\u003cp\u003eAction: I started by breaking down the feature requirements into manageable tasks and prioritized them based on the client’s most critical needs. I then assembled a small team of developers and designers, ensuring everyone was clear on their responsibilities and the importance of meeting the deadline.\u003c/p\u003e\n\u003cp\u003eTo maximize efficiency, I implemented daily stand-up meetings to track progress, identify any roadblocks early, and make quick decisions. I also set up a continuous integration pipeline to automate testing and deployment, so that we could catch and fix bugs as early as possible.\u003c/p\u003e\n\u003cp\u003eThroughout the development process, I maintained close communication with the client to keep them updated on our progress and to manage their expectations. This also allowed us to get quick feedback on the feature’s implementation, ensuring we were aligned with their vision.\u003c/p\u003e\n\u003cp\u003eResult: We successfully delivered the feature on time, and it met the client’s expectations in terms of functionality and quality. The client was impressed with our ability to meet such a tight deadline without compromising on the end product. This experience not only strengthened our relationship with the client but also demonstrated our team’s ability to work efficiently under pressure.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e4. Tell about a time you disagreed with your teamamt?\u003c/strong\u003e\nSituation:\nIn one of my previous projects, we were tasked with breaking down a monolithic application into microservices. The goal was to improve scalability and maintainability.\u003c/p\u003e\n\u003cp\u003eTask:\nMy role was to design the microservices architecture and ensure a smooth transition from the monolithic system. However, a teammate and I had a fundamental disagreement about how to approach this.\u003c/p\u003e\n\u003cp\u003eAction:\nMy teammate advocated for a \u0026ldquo;big bang\u0026rdquo; approach, where we would decompose the entire application at once and deploy all microservices simultaneously. They believed this would be more efficient and faster. I, on the other hand, favored an incremental approach. I suggested breaking down the application one component at a time, deploying each microservice individually, and ensuring that each one worked correctly before moving on to the next. I felt this would minimize risk and make it easier to identify and fix issues.\u003c/p\u003e\n\u003cp\u003eTo resolve the disagreement, we decided to:\nDiscuss Concerns: We sat down and outlined the pros and cons of both approaches. I highlighted the potential risks of a \u0026ldquo;big bang\u0026rdquo; deployment, such as the difficulty in debugging and the high impact of potential failures.\nRun Experiments: We agreed to conduct a proof-of-concept by splitting one part of the monolith into a microservice and deploying it. This would give us insights into the complexity and potential issues we might face.\nConsult with Stakeholders: We brought in our tech lead and a few other senior engineers to get their perspectives and advice. They supported the idea of an incremental approach given the complexity of our system.\u003c/p\u003e\n\u003cp\u003eResult:\nThe proof-of-concept was successful and demonstrated the benefits of an incremental approach. It allowed us to catch and resolve issues early, and it provided the team with valuable learning experiences. As a result, we adopted the incremental approach for the rest of the project.\u003c/p\u003e\n\u003cp\u003eIn the end, the project was a success. The incremental approach proved to be effective in managing risks and ensuring a smooth transition to microservices. This experience reinforced the importance of open communication, experimentation, and involving stakeholders in decision-making processes.\u003c/p\u003e\n","url":"https://karthikselvam.com/posts/2023/01/22/behavioral_questions/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"22016-22-09T10:2222:00+00:00","date_modified":"22016-22-09T10:2222:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"575763f908340acfa54632d9df52079ca5e13ba3","title":"Greedy Problems","summary":"2023","content_text":"In this article, we will solve greedy problems that are commonly encountered in interviews.\n1. Jump Game.\npublic boolean canJump(int[] nums) { int lastIndex = nums.length - 1; // set last index as the end of the array for (int i = nums.length - 2; i \u0026gt;= 0; i--) { // iterate backwards through the array if (i + nums[i] \u0026gt;= lastIndex) { // check if we can reach the current last index from current index lastIndex = i; // update last index to current index } } return lastIndex == 0; // check if we can reach the first index } if (i + nums[i] \u0026gt;= lastIndex) This line checks if we can reach the current lastIndex from the current index i. Here\u0026rsquo;s how it works:\ni is the current index we\u0026rsquo;re looking at. nums[i] is the maximum number of steps we can take from index i. i + nums[i] is the index we would end up at if we were to make a jump of size nums[i] from index i. lastIndex is the last index we need to be able to reach. Time complexity: O(n) where n is the length of the input array. This is because we only iterate through the input array once.\nSpace complexity: O(1) because we only use a constant amount of extra space to store the lastIndex variable.\n","content_html":"\u003cp\u003eIn this article, we will solve greedy problems that are commonly encountered in interviews.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. \u003ca href=\"https://leetcode.com/problems/jump-game/\"\u003eJump Game\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic boolean canJump(int[] nums) {\n    int lastIndex = nums.length - 1; // set last index as the end of the array\n    for (int i = nums.length - 2; i \u0026gt;= 0; i--) { // iterate backwards through the array\n        if (i + nums[i] \u0026gt;= lastIndex) { // check if we can reach the current last index from current index\n            lastIndex = i; // update last index to current index\n        }\n    }\n    return lastIndex == 0; // check if we can reach the first index\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eif (i + nums[i] \u0026gt;= lastIndex)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis line checks if we can reach the current lastIndex from the current index i. Here\u0026rsquo;s how it works:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ei is the current index we\u0026rsquo;re looking at.\u003c/li\u003e\n\u003cli\u003enums[i] is the maximum number of steps we can take from index i.\u003c/li\u003e\n\u003cli\u003ei + nums[i] is the index we would end up at if we were to make a jump of size nums[i] from index i.\u003c/li\u003e\n\u003cli\u003elastIndex is the last index we need to be able to reach.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTime complexity: O(n) where n is the length of the input array. This is because we only iterate through the input array once.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(1) because we only use a constant amount of extra space to store the lastIndex variable.\u003c/p\u003e\n\u003chr\u003e\n","url":"https://karthikselvam.com/posts/2023/01/22/greedy/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"22016-22-09T10:2222:00+00:00","date_modified":"22016-22-09T10:2222:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"99267cc8937fb84d59bd60cc8326f8d752393db1","title":"Intervals","summary":"2023","content_text":"In this article, we will solve intervals-related problems that are commonly encountered in interviews.\n1. Merge Intervals.\npublic int[][] merge(int[][] intervals) { List\u0026lt;int[]\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (intervals.length \u0026lt; 2) { return intervals; } Arrays.sort(intervals, Comparator.comparingInt(a -\u0026gt; a[0])); int start = intervals[0][0]; int end = intervals[0][1]; for (int i = 1; i \u0026lt; intervals.length; i++) { if (end \u0026gt;= intervals[i][0]) { end = Math.max(end, intervals[i][1]); } else { result.add(new int[]{start, end}); start = intervals[i][0]; end = intervals[i][1]; } } result.add(new int[]{start, end}); return result.toArray(new int[result.size()][]); } Time complexity: O(n log n) for the initial sorting of the intervals array, plus O(n) for the loop that iterates over the sorted intervals. Within the loop, the operations Math.max and adding to the result list take constant time. Therefore, the overall time complexity is O(n log n + n) = O(n log n).\nSpace complexity: O(n) for the result list, which could potentially store all n intervals if none of them overlap. The intervals array is modified in place, so it does not contribute to the space complexity. Therefore, the overall space complexity is O(n).\n2. Non-overlapping Intervals. One approach to solve this problem is to use the greedy algorithm. We can first sort the intervals based on their end time. Then, you can iterate through the intervals and keep track of the current end time. If the start time of the current interval is less than the current end time, then it overlaps with the previous interval and needs to be removed. Otherwise, update the current end time to be the end time of the current interval.\npublic int eraseOverlapIntervals(int[][] intervals) { Arrays.sort(intervals,Comparator.comparingInt(a -\u0026gt; a[1])); int count = 0; int end = Integer.MIN_VALUE; for(int[] interval : intervals){ int start = interval[0]; int currEnd = interval[1]; if(start \u0026lt; end){ count++; } else{ end = currEnd; } } return count; } Time complexity: O(n log n) for the initial sorting of the intervals array, plus O(n) for the loop that iterates over the sorted intervals. Within the loop, the operations Math.max and adding to the result list take constant time. Therefore, the overall time complexity is O(n log n + n) = O(n log n).\nSpace complexity: O(1)\n3. Insert Interval.\nclass Solution { public int[][] insert(int[][] intervals, int[] newInterval) { List\u0026lt;int[]\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); int i = 0; // add all intervals before newInterval while (i \u0026lt; intervals.length \u0026amp;\u0026amp; intervals[i][1] \u0026lt; newInterval[0]) { result.add(intervals[i]); i++; } // merge intervals that overlap with newInterval while (i \u0026lt; intervals.length \u0026amp;\u0026amp; intervals[i][0] \u0026lt;= newInterval[1]) { newInterval[0] = Math.min(newInterval[0], intervals[i][0]); newInterval[1] = Math.max(newInterval[1], intervals[i][1]); i++; } result.add(newInterval); // add all remaining intervals while (i \u0026lt; intervals.length) { result.add(intervals[i]); i++; } return result.toArray(new int[result.size()][2]); } } Time complexity: O(n), The method iterates through each interval once, which takes O(n) time complexity.\nSpace complexity: O(n), The method uses an ArrayList to store the resulting intervals, which can take up to O(n) space complexity in the worst case.\n","content_html":"\u003cp\u003eIn this article, we will solve intervals-related problems that are commonly encountered in interviews.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. \u003ca href=\"https://leetcode.com/problems/merge-intervals/\"\u003eMerge Intervals\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic int[][] merge(int[][] intervals) {\n    List\u0026lt;int[]\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\n    if (intervals.length \u0026lt; 2) {\n        return intervals;\n    }\n    Arrays.sort(intervals, Comparator.comparingInt(a -\u0026gt; a[0]));\n    int start = intervals[0][0];\n    int end = intervals[0][1];\n    for (int i = 1; i \u0026lt; intervals.length; i++) {\n        if (end \u0026gt;= intervals[i][0]) {\n            end = Math.max(end, intervals[i][1]);\n        } else {\n            result.add(new int[]{start, end});\n            start = intervals[i][0];\n            end = intervals[i][1];\n        }\n    }\n    result.add(new int[]{start, end});\n    return result.toArray(new int[result.size()][]);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity:  O(n log n) for the initial sorting of the intervals array, plus O(n) for the loop that iterates over the sorted intervals. Within the loop, the operations Math.max and adding to the result list take constant time. Therefore, the overall time complexity is O(n log n + n) = O(n log n).\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(n) for the result list, which could potentially store all n intervals if none of them overlap. The intervals array is modified in place, so it does not contribute to the space complexity. Therefore, the overall space complexity is O(n).\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e2. \u003ca href=\"https://leetcode.com/problems/non-overlapping-intervals/\"\u003eNon-overlapping Intervals\u003c/a\u003e.\u003c/strong\u003e\nOne approach to solve this problem is to use the greedy algorithm. We can first sort the intervals based on their end time. Then, you can iterate through the intervals and keep track of the current end time. If the start time of the current interval is less than the current end time, then it overlaps with the previous interval and needs to be removed. Otherwise, update the current end time to be the end time of the current interval.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public int eraseOverlapIntervals(int[][] intervals) {\n        Arrays.sort(intervals,Comparator.comparingInt(a -\u0026gt; a[1]));\n        int count = 0;\n        int end = Integer.MIN_VALUE;\n        for(int[] interval : intervals){\n            int start = interval[0];\n            int currEnd = interval[1];\n            if(start \u0026lt; end){\n                count++;\n            } else{\n                end = currEnd;\n            }\n        }\n        return count;\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity:  O(n log n) for the initial sorting of the intervals array, plus O(n) for the loop that iterates over the sorted intervals. Within the loop, the operations Math.max and adding to the result list take constant time. Therefore, the overall time complexity is O(n log n + n) = O(n log n).\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(1)\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e3. \u003ca href=\"https://leetcode.com/problems/insert-interval/\"\u003eInsert Interval\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        List\u0026lt;int[]\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\n        int i = 0;\n        \n        // add all intervals before newInterval\n        while (i \u0026lt; intervals.length \u0026amp;\u0026amp; intervals[i][1] \u0026lt; newInterval[0]) {\n            result.add(intervals[i]);\n            i++;\n        }\n        \n        // merge intervals that overlap with newInterval\n        while (i \u0026lt; intervals.length \u0026amp;\u0026amp; intervals[i][0] \u0026lt;= newInterval[1]) {\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n            i++;\n        }\n        \n        result.add(newInterval);\n        \n        // add all remaining intervals\n        while (i \u0026lt; intervals.length) {\n            result.add(intervals[i]);\n            i++;\n        }\n        \n        return result.toArray(new int[result.size()][2]);\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity: O(n), The method iterates through each interval once, which takes O(n) time complexity.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(n), The method uses an ArrayList to store the resulting intervals, which can take up to O(n) space complexity in the worst case.\u003c/p\u003e\n\u003chr\u003e\n","url":"https://karthikselvam.com/posts/2023/01/22/intervals/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"22016-22-09T10:2222:00+00:00","date_modified":"22016-22-09T10:2222:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"f6806e7aeb68b1f432fa9b2ba67456e59c2dc6c5","title":"Sliding Window","summary":"2023","content_text":"In this article, we will solve sliding window related problems that are commonly encountered in interviews.\n1. Best Time to Buy and Sell Stock.\nclass Solution { public int maxProfit(int[] prices) { if (prices == null || prices.length == 0) { return 0; } int minPrice = Integer.MAX_VALUE; int maxProfit = 0; for (int price : prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; } } Time complexity: O(n), where n is the length of the input string.\nSpace complexity: O(1)\n2. Longest Substring Without Repeating Characters.\nclass Solution { public int lengthOfLongestSubstring(String s) { if (s == null || s.length() == 0) { return 0; } Map\u0026lt;Character, Integer\u0026gt; charIndexMap = new HashMap\u0026lt;\u0026gt;(); int maxLength = 0; int start = 0; for (int end = 0; end \u0026lt; s.length(); end++) { char currentChar = s.charAt(end); if (charIndexMap.containsKey(currentChar)) { start = Math.max(start, charIndexMap.get(currentChar) + 1); } charIndexMap.put(currentChar, end); maxLength = Math.max(maxLength, end - start + 1); } return maxLength; } } Time complexity: O(n), where n is the length of the input string s.\nSpace complexity: O(min(m, n)), where m is the size of the character set and n is the length of the input string s.\n3. Longest Substring Without Repeating Characters.\nclass Solution { public int characterReplacement(String s, int k) { int n = s.length(); int[] count = new int[26]; int maxCount = 0; int maxLength = 0; int start = 0; for (int end = 0; end \u0026lt; n; end++) { maxCount = Math.max(maxCount, ++count[s.charAt(end) - 'A']); while (end - start + 1 - maxCount \u0026gt; k) { count[s.charAt(start) - 'A']--; start++; } maxLength = Math.max(maxLength, end - start + 1); } return maxLength; } } Time complexity: O(n), where n is the length of the input string s.\nSpace complexity: O(1), which is constant space.\n4. Permutation in String.\npublic class PermutationInString { public boolean checkInclusion(String s1, String s2) { if (s1.length() \u0026gt; s2.length()) { return false; } int[] s1Count = new int[26]; int[] s2Count = new int[26]; for (int i = 0; i \u0026lt; s1.length(); i++) { s1Count[s1.charAt(i) - 'a']++; s2Count[s2.charAt(i) - 'a']++; } for (int i = 0; i \u0026lt; s2.length() - s1.length(); i++) { if (matches(s1Count, s2Count)) { return true; } s2Count[s2.charAt(i) - 'a']--; s2Count[s2.charAt(i + s1.length()) - 'a']++; } return matches(s1Count, s2Count); } private boolean matches(int[] s1Count, int[] s2Count) { for (int i = 0; i \u0026lt; 26; i++) { if (s1Count[i] != s2Count[i]) { return false; } } return true; } } Time complexity: O(n),The algorithm iterates through both strings once to initialize the count arrays. Then, it iterates through the second string s2 once more to check for the presence of any permutation of s1. Therefore, the time complexity of the algorithm is O(n), where n is the length of the second string s2.\nSpace complexity: O(1), which is constant space.\n","content_html":"\u003cp\u003eIn this article, we will solve sliding window related problems that are commonly encountered in interviews.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. \u003ca href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\"\u003eBest Time to Buy and Sell Stock\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public int maxProfit(int[] prices) {\n        if (prices == null || prices.length == 0) {\n            return 0;\n        }\n        \n        int minPrice = Integer.MAX_VALUE;\n        int maxProfit = 0;\n        \n        for (int price : prices) {\n            minPrice = Math.min(minPrice, price);\n            maxProfit = Math.max(maxProfit, price - minPrice);\n        }\n        return maxProfit;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity:  O(n), where n is the length of the input string.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(1)\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e2. \u003ca href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/\"\u003eLongest Substring Without Repeating Characters\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        Map\u0026lt;Character, Integer\u0026gt; charIndexMap = new HashMap\u0026lt;\u0026gt;();\n        int maxLength = 0;\n        int start = 0;\n        for (int end = 0; end \u0026lt; s.length(); end++) {\n            char currentChar = s.charAt(end);\n            if (charIndexMap.containsKey(currentChar)) {\n                start = Math.max(start, charIndexMap.get(currentChar) + 1);\n            }\n            charIndexMap.put(currentChar, end);\n            maxLength = Math.max(maxLength, end - start + 1);\n        }\n        return maxLength;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity:  O(n), where n is the length of the input string s.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(min(m, n)), where m is the size of the character set and n is the length of the input string s.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e3. \u003ca href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/\"\u003eLongest Substring Without Repeating Characters\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public int characterReplacement(String s, int k) {\n        int n = s.length();\n        int[] count = new int[26];\n        int maxCount = 0;\n        int maxLength = 0;\n        int start = 0;\n        for (int end = 0; end \u0026lt; n; end++) {\n            maxCount = Math.max(maxCount, ++count[s.charAt(end) - 'A']);\n            while (end - start + 1 - maxCount \u0026gt; k) {\n                count[s.charAt(start) - 'A']--;\n                start++;\n            }\n            maxLength = Math.max(maxLength, end - start + 1);\n        }\n        return maxLength;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity:  O(n), where n is the length of the input string s.\u003c/p\u003e\n\u003cp\u003eSpace complexity:  O(1), which is constant space.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e4. \u003ca href=\"https://leetcode.com/problems/permutation-in-string\"\u003ePermutation in String\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class PermutationInString {\n    public boolean checkInclusion(String s1, String s2) {\n        if (s1.length() \u0026gt; s2.length()) {\n            return false;\n        }\n        int[] s1Count = new int[26];\n        int[] s2Count = new int[26];\n        for (int i = 0; i \u0026lt; s1.length(); i++) {\n            s1Count[s1.charAt(i) - 'a']++;\n            s2Count[s2.charAt(i) - 'a']++;\n        }\n        for (int i = 0; i \u0026lt; s2.length() - s1.length(); i++) {\n            if (matches(s1Count, s2Count)) {\n                return true;\n            }\n            s2Count[s2.charAt(i) - 'a']--;\n            s2Count[s2.charAt(i + s1.length()) - 'a']++;\n        }\n        return matches(s1Count, s2Count);\n    }\n    private boolean matches(int[] s1Count, int[] s2Count) {\n        for (int i = 0; i \u0026lt; 26; i++) {\n            if (s1Count[i] != s2Count[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity:  O(n),The algorithm iterates through both strings once to initialize the count arrays. Then, it iterates through the second string s2 once more to check for the presence of any permutation of s1. Therefore, the time complexity of the algorithm is O(n), where n is the length of the second string s2.\u003c/p\u003e\n\u003cp\u003eSpace complexity:  O(1), which is constant space.\u003c/p\u003e\n\u003chr\u003e\n","url":"https://karthikselvam.com/posts/2023/01/22/sliding_window/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"22016-22-09T10:2222:00+00:00","date_modified":"22016-22-09T10:2222:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}},{"id":"e84f1612da8285c621a7a358cb10697ec23831c8","title":"Two Pointers","summary":"2023","content_text":"In this article, we will solve Two Pointers related problems that are commonly encountered in interviews.\n1. Valid Palindrome.\nclass Solution { public boolean isPalindrome(String s) { if (s == null || s.isEmpty()) { return true; // Empty string is considered a palindrome } // Preprocess the string: remove non-alphanumeric characters and convert to lowercase StringBuilder sb = new StringBuilder(); for (char c : s.toCharArray()) { if (Character.isLetterOrDigit(c)) { sb.append(Character.toLowerCase(c)); } } String processedString = sb.toString(); // Use two pointers approach to check if the string is a palindrome int left = 0, right = processedString.length() - 1; while (left \u0026lt; right) { if (processedString.charAt(left) != processedString.charAt(right)) { return false; } left++; right--; } return true; } } Time complexity: O(n), where n is the length of the input string.\nSpace complexity: O(n), The space required by the StringBuilder can be at most the same as the input string, which is O(n) in the worst case. The processed string may require additional space, but it is still bounded by the length of the input string, which is O(n). Therefore, the overall space complexity is also O(n).\n2. Two Sum II - Input Array Is Sorted.\nclass Solution { public int[] twoSum(int[] numbers, int target) { int left = 0; int right = numbers.length - 1; while (left \u0026lt; right) { int sum = numbers[left] + numbers[right]; if (sum == target) { return new int[]{left + 1, right + 1}; // Indices are 1-based } else if (sum \u0026lt; target) { left++; } else { right--; } } // If no such pair is found return new int[]{-1, -1}; } } Time complexity: O(n), where n is the number of elements in the array.\nSpace complexity: O(1), meaning it uses constant extra space.\n3. 3Sum.\nclass Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); // Sort the array for (int i = 0; i \u0026lt; nums.length - 2; i++) { // Avoid duplicates if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } int left = i + 1; int right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) { result.add(Arrays.asList(nums[i], nums[left], nums[right])); // Avoid duplicates while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left + 1]) { left++; } while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right - 1]) { right--; } // Move pointers left++; right--; } else if (sum \u0026lt; 0) { left++; } else { right--; } } } return result; } } Time complexity: O(n log n), Sorting the array takes O(n log n) time complexity.\nSpace complexity: The space complexity of the result list is O(m), where m is the number of unique triplets that sum up to zero.\n4. Container With Most Water.\nclass Solution { public int maxArea(int[] height) { int maxArea = 0; int left = 0; int right = height.length - 1; while (left \u0026lt; right) { int minHeight = Math.min(height[left], height[right]); int width = right - left; int area = width * minHeight; maxArea = Math.max(maxArea, area); if (height[left] \u0026lt; height[right]) { left++; } else { right--; } } return maxArea; } } Time complexity: O(n), where n is the number of elements in the array, the time complexity is O(n).\nSpace complexity: O(1)\n5. Trapping Rain Water.\npublic class TrappingRainWater { public int trap(int[] height) { if (height == null || height.length == 0) { return 0; } int n = height.length; int[] leftMax = new int[n]; int[] rightMax = new int[n]; // Calculate the maximum height of bars to the left of each position leftMax[0] = height[0]; for (int i = 1; i \u0026lt; n; i++) { leftMax[i] = Math.max(leftMax[i - 1], height[i]); } // Calculate the maximum height of bars to the right of each position rightMax[n - 1] = height[n - 1]; for (int i = n - 2; i \u0026gt;= 0; i--) { rightMax[i] = Math.max(rightMax[i + 1], height[i]); } // Calculate the trapped water at each position int totalWater = 0; for (int i = 0; i \u0026lt; n; i++) { int minHeight = Math.min(leftMax[i], rightMax[i]); totalWater += minHeight - height[i]; } return totalWater; } } Time complexity: O(n), Each iteration through the array takes O(n) time, where n is the number of elements in the array.\nSpace complexity: O(n), where n is the number of elements in the array.\n","content_html":"\u003cp\u003eIn this article, we will solve Two Pointers related problems that are commonly encountered in interviews.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. \u003ca href=\"https://leetcode.com/problems/valid-palindrome/\"\u003eValid Palindrome\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public boolean isPalindrome(String s) {\n        if (s == null || s.isEmpty()) {\n            return true; // Empty string is considered a palindrome\n        }\n        // Preprocess the string: remove non-alphanumeric characters and convert to lowercase\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetterOrDigit(c)) {\n                sb.append(Character.toLowerCase(c));\n            }\n        }\n        String processedString = sb.toString();\n        // Use two pointers approach to check if the string is a palindrome\n        int left = 0, right = processedString.length() - 1;\n        while (left \u0026lt; right) {\n            if (processedString.charAt(left) != processedString.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity:  O(n), where n is the length of the input string.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(n), The space required by the StringBuilder can be at most the same as the input string, which is O(n) in the worst case. The processed string may require additional space, but it is still bounded by the length of the input string, which is O(n). Therefore, the overall space complexity is also O(n).\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e2. \u003ca href=\"https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/\"\u003eTwo Sum II - Input Array Is Sorted\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int left = 0;\n        int right = numbers.length - 1;\n        \n        while (left \u0026lt; right) {\n            int sum = numbers[left] + numbers[right];\n            if (sum == target) {\n                return new int[]{left + 1, right + 1}; // Indices are 1-based\n            } else if (sum \u0026lt; target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        // If no such pair is found\n        return new int[]{-1, -1};\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity:  O(n), where n is the number of elements in the array.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(1), meaning it uses constant extra space.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e3. \u003ca href=\"https://leetcode.com/problems/3sum/\"\u003e3Sum\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) {\n        List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();\n        Arrays.sort(nums); // Sort the array\n        for (int i = 0; i \u0026lt; nums.length - 2; i++) {\n            // Avoid duplicates\n            if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) {\n                continue;\n            }\n            int left = i + 1;\n            int right = nums.length - 1;\n            while (left \u0026lt; right) {\n                int sum = nums[i] + nums[left] + nums[right];\n                \n                if (sum == 0) {\n                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n                    // Avoid duplicates\n                    while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left + 1]) {\n                        left++;\n                    }\n                    while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right - 1]) {\n                        right--;\n                    }\n                    // Move pointers\n                    left++;\n                    right--;\n                } else if (sum \u0026lt; 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        return result;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity:  O(n log n), Sorting the array takes O(n log n) time complexity.\u003c/p\u003e\n\u003cp\u003eSpace complexity: The space complexity of the result list is O(m), where m is the number of unique triplets that sum up to zero.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e4. \u003ca href=\"https://leetcode.com/problems/container-with-most-water\"\u003eContainer With Most Water\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass Solution {\n    public int maxArea(int[] height) {\n        int maxArea = 0;\n        int left = 0;\n        int right = height.length - 1;\n        while (left \u0026lt; right) {\n            int minHeight = Math.min(height[left], height[right]);\n            int width = right - left;\n            int area = width * minHeight;\n            maxArea = Math.max(maxArea, area);\n            \n            if (height[left] \u0026lt; height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return maxArea;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity:  O(n), where n is the number of elements in the array, the time complexity is O(n).\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(1)\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e5. \u003ca href=\"https://leetcode.com/problems/trapping-rain-water/\"\u003eTrapping Rain Water\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class TrappingRainWater {\n    public int trap(int[] height) {\n        if (height == null || height.length == 0) {\n            return 0;\n        }\n        int n = height.length;\n        int[] leftMax = new int[n];\n        int[] rightMax = new int[n];\n        // Calculate the maximum height of bars to the left of each position\n        leftMax[0] = height[0];\n        for (int i = 1; i \u0026lt; n; i++) {\n            leftMax[i] = Math.max(leftMax[i - 1], height[i]);\n        }\n        // Calculate the maximum height of bars to the right of each position\n        rightMax[n - 1] = height[n - 1];\n        for (int i = n - 2; i \u0026gt;= 0; i--) {\n            rightMax[i] = Math.max(rightMax[i + 1], height[i]);\n        }\n        // Calculate the trapped water at each position\n        int totalWater = 0;\n        for (int i = 0; i \u0026lt; n; i++) {\n            int minHeight = Math.min(leftMax[i], rightMax[i]);\n            totalWater += minHeight - height[i];\n        }\n        return totalWater;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTime complexity:  O(n), Each iteration through the array takes O(n) time, where n is the number of elements in the array.\u003c/p\u003e\n\u003cp\u003eSpace complexity: O(n), where n is the number of elements in the array.\u003c/p\u003e\n\u003chr\u003e\n","url":"https://karthikselvam.com/posts/2023/01/22/two_pointers/","image":"https://karthikselvam.com/photos/<no value>","banner_image":"https://karthikselvam.com/photos/<no value>","date_published":"22016-22-09T10:2222:00+00:00","date_modified":"22016-22-09T10:2222:00+00:00","author":{"name":"Ronalds Vilcins","url":"https://ronaldsvilcins.com/"}}]}