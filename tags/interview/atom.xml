<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>interview on Karthik Selvam</title><link>https://karthikselvam.com/tags/interview/</link><description>Recent content in interview on Karthik Selvam</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 10 May 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://karthikselvam.com/tags/interview/atom.xml" rel="self" type="application/rss+xml"/><item><title>Command Pattern</title><link>https://karthikselvam.com/posts/2024/05/10/command_pattern/</link><pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate><guid>https://karthikselvam.com/posts/2024/05/10/command_pattern/</guid><description>Implement Transaction Management: Extend the Command Pattern implementation to support transaction management. This exercise will involve implementing methods to start, commit, and rollback transactions, where a transaction consists of multiple commands that are executed atomically. // Command interface interface Command { void execute(); void undo(); } // Concrete command class ConcreteCommand implements Command { private Receiver receiver; ConcreteCommand(Receiver receiver) { this.receiver = receiver; } public void execute() { receiver.action(); } public void undo() { receiver.</description></item><item><title>Scaling Databases</title><link>https://karthikselvam.com/posts/2024/05/02/scaling_db/</link><pubDate>Thu, 02 May 2024 00:00:00 +0000</pubDate><guid>https://karthikselvam.com/posts/2024/05/02/scaling_db/</guid><description>Storage services are stateful services. Compared to stateless services, stateful services have mechanisms to ensure consistency and require redundancy to avoid data loss. A stateful service may choose mechanisms like Paxos for strong consistency or eventual consistency mechanisms. These are complex decisions, and tradeoffs have to be made, which depend on the various requirements like consistency, complexity, security, latency, and performance. This is one reason we keep all services stateless as much as possible and keep state only in stateful services.</description></item><item><title>Non Functional Requirements</title><link>https://karthikselvam.com/posts/2024/05/01/non_functional_requirements/</link><pubDate>Wed, 01 May 2024 00:00:00 +0000</pubDate><guid>https://karthikselvam.com/posts/2024/05/01/non_functional_requirements/</guid><description>A system has functional and non-functional requirements. Functional requirements describe the inputs and outputs of the system. You can represent them as a rough API specification and endpoints.
Non-functional requirements refer to requirements other than the system inputs and outputs. Typical non-functional requirements include the following
Scalability—The ability of a system to adjust its hardware resource usage easily and with little fuss to cost-efficiently support its load. The process of expanding to support a larger load or number of users is called scal- ing.</description></item><item><title>Using Collections the right way</title><link>https://karthikselvam.com/posts/2023/02/23/collections/</link><pubDate>Thu, 23 Feb 2023 00:00:00 +0000</pubDate><guid>https://karthikselvam.com/posts/2023/02/23/collections/</guid><description>Iterating through a List # Iterating through a List using Index. Iterating through a list is a basic operation on a collection, but over the years it’s gone through a few significant changes. We’ll begin with the old and evolve an example—enumerating a list of names—to the elegant style.
final List&amp;lt;String&amp;gt; friends = Arrays.asList(&amp;quot;Brian&amp;quot;, &amp;quot;Nate&amp;quot;, &amp;quot;Neal&amp;quot;, &amp;quot;Raju&amp;quot;, &amp;quot;Sara&amp;quot;, &amp;quot;Scott&amp;quot;); Here’s the habitual, but not so desirable, way to iterate and print each of the elements</description></item><item><title>Capacity Estimation on the fly</title><link>https://karthikselvam.com/posts/2023/01/23/capacity_estimation/</link><pubDate>Mon, 23 Jan 2023 00:00:00 +0000</pubDate><guid>https://karthikselvam.com/posts/2023/01/23/capacity_estimation/</guid><description>Capacity estimation is a crucial component of system design interviews, and it can be quite challenging if one is not adequately prepared. However, with the right approach, it is possible to accurately estimate the storage, bandwidth, and memory/cache requirements needed for a particular system. This article provides a comprehensive framework for capacity estimation, which will enable you to confidently tackle capacity-related questions during system design interviews.
Typically following estimates are required :</description></item></channel></rss>