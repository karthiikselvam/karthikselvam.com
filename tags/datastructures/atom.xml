<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>datastructures on Karthik Selvam</title><link>https://karthikselvam.com/tags/datastructures/</link><description>Recent content in datastructures on Karthik Selvam</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 22 Apr 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://karthikselvam.com/tags/datastructures/atom.xml" rel="self" type="application/rss+xml"/><item><title>Linked List</title><link>https://karthikselvam.com/posts/2024/04/22/linked_list/</link><pubDate>Mon, 22 Apr 2024 00:00:00 +0000</pubDate><guid>https://karthikselvam.com/posts/2024/04/22/linked_list/</guid><description>In this article, we will solve linked list related problems that are commonly encountered in interviews.
1. Reverse Linked List.
public class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode current = head; while (current != null) { ListNode nextTemp = current.next; current.next = prev; prev = current; current = nextTemp; } return prev; // prev now points to the new head of the reversed list } } Time complexity: O(n), where n is the number of nodes in the linked list.</description></item><item><title>Recursion &amp; Backtracking</title><link>https://karthikselvam.com/posts/2024/04/22/recursion_backtracking/</link><pubDate>Mon, 22 Apr 2024 00:00:00 +0000</pubDate><guid>https://karthikselvam.com/posts/2024/04/22/recursion_backtracking/</guid><description>In this article, we will solve recursion and backtracking related problems that are commonly encountered in interviews.
**1. Given an array of integers, print all combinations of size X.
public static void printCombos(int[] a, int x) { if (a == null || a.length == 0 || x &amp;gt; a.length) return; int[] buffer = new int[x]; printCombosHelper(a, buffer, 0, 0); } public static void printCombosHelper(int[] a, int[] buffer, int startIndex, int bufferIndex) { // termination cases - buffer full if (bufferIndex == buffer.</description></item><item><title>Trees</title><link>https://karthikselvam.com/posts/2024/04/21/trees/</link><pubDate>Sun, 21 Apr 2024 00:00:00 +0000</pubDate><guid>https://karthikselvam.com/posts/2024/04/21/trees/</guid><description>In this article, we will solve trees-related problems that are commonly encountered in interviews.
1. Invert Binary Tree.
public TreeNode invertTree(TreeNode root) { if(root == null) { return null; } TreeNode tempNode = root.left; root.left = root.right; root.right = tempNode; invertTree(root.left); invertTree(root.right); return root; } Time complexity: O(n) The given code performs a depth-first search traversal of the binary tree, and visits each node exactly once. Therefore, the time complexity of the code is O(n), where n is the number of nodes in the binary tree.</description></item><item><title>Binary Search</title><link>https://karthikselvam.com/posts/2023/08/08/binary_search/</link><pubDate>Tue, 08 Aug 2023 00:00:00 +0000</pubDate><guid>https://karthikselvam.com/posts/2023/08/08/binary_search/</guid><description>In this article, we will solve binary search related problems that are commonly encountered in interviews.
1. Implement a binary search on a sorted array to find the index of a target element.
public class BinarySearchExample { public static int binarySearch(int[] array, int target) { int left = 0; int right = array.length - 1; while (left &amp;lt;= right) { int mid = left + (right - left) / 2; if (array[mid] == target) { return mid; // Target found } else if (array[mid] &amp;lt; target) { left = mid + 1; // Search right half } else { right = mid - 1; // Search left half } } return -1; // Target not found } public static void main(String[] args) { int[] sortedArray = {1, 3, 5, 7, 9, 11}; int target = 7; int result = binarySearch(sortedArray, target); if (result !</description></item><item><title>Arrays</title><link>https://karthikselvam.com/posts/2023/01/22/arrays/</link><pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate><guid>https://karthikselvam.com/posts/2023/01/22/arrays/</guid><description>In this article, we will solve array-related problems that are commonly encountered in interviews.
1. Contains Duplicate.
class Solution { public boolean containsDuplicate(int[] nums) { // Use a hash set to keep track of seen elements HashSet&amp;lt;Integer&amp;gt; seen = new HashSet&amp;lt;&amp;gt;(); for (int num : nums) { // If we've already seen this element, then we have a duplicate if (seen.contains(num)) { return true; } // Otherwise, add it to the set seen.</description></item><item><title>Greedy Problems</title><link>https://karthikselvam.com/posts/2023/01/22/greedy/</link><pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate><guid>https://karthikselvam.com/posts/2023/01/22/greedy/</guid><description>In this article, we will solve greedy problems that are commonly encountered in interviews.
1. Jump Game.
public boolean canJump(int[] nums) { int lastIndex = nums.length - 1; // set last index as the end of the array for (int i = nums.length - 2; i &amp;gt;= 0; i--) { // iterate backwards through the array if (i + nums[i] &amp;gt;= lastIndex) { // check if we can reach the current last index from current index lastIndex = i; // update last index to current index } } return lastIndex == 0; // check if we can reach the first index } if (i + nums[i] &amp;gt;= lastIndex) This line checks if we can reach the current lastIndex from the current index i.</description></item><item><title>Intervals</title><link>https://karthikselvam.com/posts/2023/01/22/intervals/</link><pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate><guid>https://karthikselvam.com/posts/2023/01/22/intervals/</guid><description>In this article, we will solve intervals-related problems that are commonly encountered in interviews.
1. Merge Intervals.
public int[][] merge(int[][] intervals) { List&amp;lt;int[]&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); if (intervals.length &amp;lt; 2) { return intervals; } Arrays.sort(intervals, Comparator.comparingInt(a -&amp;gt; a[0])); int start = intervals[0][0]; int end = intervals[0][1]; for (int i = 1; i &amp;lt; intervals.length; i++) { if (end &amp;gt;= intervals[i][0]) { end = Math.max(end, intervals[i][1]); } else { result.add(new int[]{start, end}); start = intervals[i][0]; end = intervals[i][1]; } } result.</description></item><item><title>Sliding Window</title><link>https://karthikselvam.com/posts/2023/01/22/sliding_window/</link><pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate><guid>https://karthikselvam.com/posts/2023/01/22/sliding_window/</guid><description>In this article, we will solve sliding window related problems that are commonly encountered in interviews.
1. Best Time to Buy and Sell Stock.
class Solution { public int maxProfit(int[] prices) { if (prices == null || prices.length == 0) { return 0; } int minPrice = Integer.MAX_VALUE; int maxProfit = 0; for (int price : prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; } } Time complexity: O(n), where n is the length of the input string.</description></item><item><title>Two Pointers</title><link>https://karthikselvam.com/posts/2023/01/22/two_pointers/</link><pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate><guid>https://karthikselvam.com/posts/2023/01/22/two_pointers/</guid><description>In this article, we will solve Two Pointers related problems that are commonly encountered in interviews.
1. Valid Palindrome.
class Solution { public boolean isPalindrome(String s) { if (s == null || s.isEmpty()) { return true; // Empty string is considered a palindrome } // Preprocess the string: remove non-alphanumeric characters and convert to lowercase StringBuilder sb = new StringBuilder(); for (char c : s.toCharArray()) { if (Character.isLetterOrDigit(c)) { sb.append(Character.toLowerCase(c)); } } String processedString = sb.</description></item></channel></rss>