<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>datastructures on Karthik Selvam</title><link>https://karthikselvam.com/tags/datastructures/</link><description>Recent content in datastructures on Karthik Selvam</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 22 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://karthikselvam.com/tags/datastructures/atom.xml" rel="self" type="application/rss+xml"/><item><title>Arrays</title><link>https://karthikselvam.com/posts/2023/01/22/arrays/</link><pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate><guid>https://karthikselvam.com/posts/2023/01/22/arrays/</guid><description>In this article, we will solve array-related problems that are commonly encountered in interviews.
1. Contains Duplicate.
class Solution { public boolean containsDuplicate(int[] nums) { // Use a hash set to keep track of seen elements HashSet&amp;lt;Integer&amp;gt; seen = new HashSet&amp;lt;&amp;gt;(); for (int num : nums) { // If we've already seen this element, then we have a duplicate if (seen.contains(num)) { return true; } // Otherwise, add it to the set seen.</description></item><item><title>Greedy Problems</title><link>https://karthikselvam.com/posts/2023/01/22/greedy/</link><pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate><guid>https://karthikselvam.com/posts/2023/01/22/greedy/</guid><description>In this article, we will solve greedy problems that are commonly encountered in interviews.
1. Jump Game.
public boolean canJump(int[] nums) { int lastIndex = nums.length - 1; // set last index as the end of the array for (int i = nums.length - 2; i &amp;gt;= 0; i--) { // iterate backwards through the array if (i + nums[i] &amp;gt;= lastIndex) { // check if we can reach the current last index from current index lastIndex = i; // update last index to current index } } return lastIndex == 0; // check if we can reach the first index } if (i + nums[i] &amp;gt;= lastIndex) This line checks if we can reach the current lastIndex from the current index i.</description></item><item><title>Intervals</title><link>https://karthikselvam.com/posts/2023/01/22/intervals/</link><pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate><guid>https://karthikselvam.com/posts/2023/01/22/intervals/</guid><description>In this article, we will solve intervals-related problems that are commonly encountered in interviews.
1. Merge Intervals.
public int[][] merge(int[][] intervals) { List&amp;lt;int[]&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); if (intervals.length &amp;lt; 2) { return intervals; } Arrays.sort(intervals, Comparator.comparingInt(a -&amp;gt; a[0])); int start = intervals[0][0]; int end = intervals[0][1]; for (int i = 1; i &amp;lt; intervals.length; i++) { if (end &amp;gt;= intervals[i][0]) { end = Math.max(end, intervals[i][1]); } else { result.add(new int[]{start, end}); start = intervals[i][0]; end = intervals[i][1]; } } result.</description></item><item><title>Trees</title><link>https://karthikselvam.com/posts/2023/01/22/trees/</link><pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate><guid>https://karthikselvam.com/posts/2023/01/22/trees/</guid><description>In this article, we will solve trees-related problems that are commonly encountered in interviews.
1. Invert Binary Tree.
public TreeNode invertTree(TreeNode root) { if(root == null) { return null; } TreeNode tempNode = root.left; root.left = root.right; root.right = tempNode; invertTree(root.left); invertTree(root.right); return root; } Time complexity: O(n) The given code performs a depth-first search traversal of the binary tree, and visits each node exactly once. Therefore, the time complexity of the code is O(n), where n is the number of nodes in the binary tree.</description></item></channel></rss>