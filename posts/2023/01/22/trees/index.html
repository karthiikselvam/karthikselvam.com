<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Ronalds Vilcins - https://karthikselvam.com/"><title>Trees | Karthik Selvam</title><meta name=description content="2023"><meta name=twitter:card content="summary"><meta name=twitter:title content="Trees"><meta name=twitter:description content="2023"><meta property="og:title" content="Trees"><meta property="og:description" content="2023"><meta property="og:type" content="article"><meta property="og:url" content="https://karthikselvam.com/posts/2023/01/22/trees/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-01-22T00:00:00+00:00"><meta itemprop=name content="Trees"><meta itemprop=description content="2023"><meta itemprop=datePublished content="2023-01-22T00:00:00+00:00"><meta itemprop=dateModified content="2023-01-22T00:00:00+00:00"><meta itemprop=wordCount content="2374"><meta itemprop=keywords content="datastructures,"><link rel=canonical href=https://karthikselvam.com/posts/2023/01/22/trees/><link rel=dns-prefetch href=https://www.google-analytics.com><link href=https://www.google-analytics.com rel=preconnect crossorigin><link rel=alternate type=application/atom+xml title="Karthik Selvam" href=https://karthikselvam.com/atom.xml><link rel=alternate type=application/json title="Karthik Selvam" href=https://karthikselvam.com/feed.json><script src=https://kit.fontawesome.com/8d06e0a013.js crossorigin=anonymous></script>
<link rel="shortcut icon" type=image/png href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII="><style>*,:after,:before{box-sizing:border-box;padding:0}body{font:1rem/1.5 '-apple-system',BlinkMacSystemFont,avenir next,avenir,helvetica,helvetica neue,ubuntu,roboto,noto,segoe ui,arial,sans-serif;text-rendering:optimizeSpeed}.posts hr{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:none;border-bottom:1px #353535;flex:1 0 1rem}main{max-width:70ch;padding:2ch;margin:auto}a,body{color:#353535}::selection,a:focus,a:hover{background-color:#353535;color:#fff}.meta{margin:0 0 2.5rem}.tags::before{content:"\2022";margin-left:1rem}code,pre{color:#353535;font-family:San Francisco Mono,Monaco,consolas,lucida console,dejavu sans mono,bitstream vera sans mono,monospace;font-size:normal;border:1px solid #353535;font-size:small}code{padding:.1rem;border:none}pre{padding:.5rem;overflow-x:auto}pre code{border:none}img{max-width:100%;border:1px solid #353535}hr{background:#353535;height:1px;border:0}ul{list-style-type:square}ul,ol{padding-left:1.2rem}header li,footer li{display:inline;text-transform:uppercase}header a,footer a{text-decoration:none}header ul,footer ul{justify-content:space-between;display:flex}header,section,footer{padding:1rem 0}blockquote{border-left:5px solid #353535;padding-left:1rem}.posts ul,header ul,footer ul{list-style:none}.posts,header ul,footer ul{padding:0}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.7rem}.posts li a,.posts li div{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}.hash{opacity:.25;text-decoration:none}table{border-collapse:collapse;text-align:left;width:100%}table tr{background:#fff;border-bottom:1px solid}table th,table td{padding:10px 20px}</style><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Trees","headline":"Trees","alternativeHeadline":"","description":"2023","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/karthikselvam.com\/posts\/2023\/01\/22\/trees\/"},"author":{"@type":"Person","name":""},"creator":{"@type":"Person","name":""},"accountablePerson":{"@type":"Person","name":""},"copyrightHolder":"Karthik Selvam","copyrightYear":"2023","dateCreated":"2023-01-22T00:00:00.00Z","datePublished":"2023-01-22T00:00:00.00Z","dateModified":"2023-01-22T00:00:00.00Z","publisher":{"@type":"Organization","name":"Karthik Selvam","url":"https://karthikselvam.com/","logo":{"@type":"ImageObject","url":"https:\/\/karthikselvam.com\/","width":"32","height":"32"}},"image":"https://karthikselvam.com/","url":"https:\/\/karthikselvam.com\/posts\/2023\/01\/22\/trees\/","wordCount":"2374","genre":["datastructures"],"keywords":["datastructures"]}</script></head><body><main><header><nav><ul><li><a href=/>Blog</a></li><li><a href=/about/>@Karthik</a></li><li><a href=https://twitter.com/karthiikselvam><i class="fa-brands fa-twitter"></i></a>
&nbsp;&nbsp;
<a href=https://www.instagram.com/karthiikselvam/><i class="fa-brands fa-instagram"></i></a>
&nbsp;&nbsp;
<a href=https://www.linkedin.com/in/karthiiks/><i class="fa-brands fa-linkedin"></i></a></li></ul></nav></header><hr><section><h2 itemprop="name headline">Trees</h2><p class=meta><time itemprop=datePublished datetime=2023-01-22>January 22, 2023</time> &bull;
<a href=/tags/datastructures>datastructures</a></p><span itemprop=articleBody><p>In this article, we will solve trees-related problems that are commonly encountered in interviews.</p><p><strong>1. <a href=https://leetcode.com/problems/invert-binary-tree/>Invert Binary Tree</a>.</strong></p><pre><code class=language-java>public TreeNode invertTree(TreeNode root) {
    if(root == null) {
        return null;
    }
    TreeNode tempNode = root.left;
    root.left = root.right;
    root.right = tempNode;
    invertTree(root.left);
    invertTree(root.right);
    return root;
}
</code></pre><p>Time complexity: O(n) The given code performs a depth-first search traversal of the binary tree, and visits each node exactly once. Therefore, the time complexity of the code is O(n), where n is the number of nodes in the binary tree.</p><p>Space complexity: O(n) The space complexity of the code depends on the maximum depth of the binary tree. In the worst case, if the binary tree is skewed (i.e., all the nodes are in a straight line), the maximum depth of the tree would be n (the number of nodes), and the space complexity of the code would be O(n) due to the recursive function calls. However, in the best case, if the binary tree is balanced, the maximum depth of the tree would be log(n), and the space complexity of the code would be O(log(n)).</p><hr><p><strong>2. <a href=https://leetcode.com/problems/maximum-depth-of-binary-tree/>Maximum Depth of Binary Tree</a>.</strong></p><pre><code class=language-java>    public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);

        return  1 + Math.max(left,right);
    }
</code></pre><p>Time complexity: O(n) where n is the number of nodes in the binary tree, since the code visits each node exactly once.</p><p>Space complexity: O(h), where h is the height of the binary tree, since the code uses a recursive approach, and the maximum depth of the recursive call stack is equal to the height of the binary tree. In the worst case, where the binary tree is skewed (i.e., all the nodes are in a straight line), the height of the tree would be n (the number of nodes), and the space complexity of the code would be O(n). However, in the best case, where the binary tree is balanced, the height of the tree would be log(n), and the space complexity of the code would be O(log(n)).</p><hr><p><strong>3. <a href=https://leetcode.com/problems/diameter-of-binary-tree/>Diameter of Binary Tree</a>.</strong></p><pre><code class=language-java>public int diameterOfBinaryTree(TreeNode root) {
    int leftDepth  = depth(root.left);
    int rightDepth = depth(root.right);
    return Math.max(Math.max(diameterOfBinaryTree(root.left), diameterOfBinaryTree(root.right)), leftDepth + rightDepth);
}

private int depth(TreeNode root){
    if(root == null){
        return 0;
    }
    
    int left = depth(root.left);
    int right = depth(root.right);

    return 1 + Math.max(left, right);
}
</code></pre><p>Time complexity: O(n^2^) wwhere n is the number of nodes in the binary tree, since for each node, the code visits all the nodes in its left and right subtrees to compute the diameter.</p><p>Space complexity: O(h), where h is the height of the binary tree, since the code uses a recursive approach, and the maximum depth of the recursive call stack is equal to the height of the binary tree. In the worst case, where the binary tree is skewed (i.e., all the nodes are in a straight line), the height of the tree would be n (the number of nodes), and the space complexity of the code would be O(n). However, in the best case, where the binary tree is balanced, the height of the tree would be log(n), and the space complexity of the code would be O(log(n)).</p><p>Optimized Verison : We can optimize by computing the diameter of the binary tree in a single pass, instead of recursively computing the depth of each node multiple times.</p><pre><code class=language-java>public int diameterOfBinaryTree(TreeNode root) {
    int[] max = {0};
    depth(root, max);
    return max[0];
}

private int depth(TreeNode root, int[] max) {
    if (root == null) {
        return 0;
    }
    
    int left = depth(root.left, max);
    int right = depth(root.right, max);
    
    max[0] = Math.max(max[0], left + right);
    
    return 1 + Math.max(left, right);
}
</code></pre><p>Time complexity: O(n) where n is the number of nodes in the binary tree.</p><p>Space complexity: O(h), where h is the height of the binary tree.</p><hr><p><strong>4. <a href=https://leetcode.com/problems/balanced-binary-tree/>Balanced Binary Tree</a>.</strong></p><pre><code class=language-java>public boolean isBalanced(TreeNode root) {        
    if(root == null){
        return true;
    }
    int leftHeight = height(root.left);
    int rightHeight = height(root.right);

    if(Math.abs(leftHeight - rightHeight) &gt; 1){
        return false;
    }

    return isBalanced(root.left) &amp;&amp; isBalanced(root.right); 
}

private int height(TreeNode root){
    if(root == null){
        return 0;
    }

    int left = height(root.left);
    int right = height(root.right);

    return 1 + Math.max(left,right);
}
</code></pre><p>Time complexity: O(n log n) in the worst case, where n is the number of nodes in the binary tree. This is because the height of each node is computed recursively using the height method, which has a time complexity of O(n) in the worst case. Since the height method is called for each node in the binary tree, the overall time complexity of isBalanced is O(n log n), because the binary tree has a maximum of log n levels.</p><p>Space complexity: O(n) in the worst case, where n is the number of nodes in the binary tree. This is because the height method is called recursively for each node in the binary tree, and the maximum depth of the recursive call stack is equal to the height of the binary tree, which is O(n) in the worst case. Additionally, the method uses a constant amount of extra space to store the heights of the left and right subtrees of each node. Therefore, the overall space complexity of isBalanced is O(n).</p><p>Optimized version :</p><pre><code class=language-java>public boolean isBalanced(TreeNode root) {        
    return checkBalance(root) != -1;
}

private int checkBalance(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int left = checkBalance(root.left);
    if (left == -1) {
        return -1;
    }
    int right = checkBalance(root.right);
    if (right == -1) {
        return -1;
    }
    if (Math.abs(left - right) &gt; 1) {
        return -1;
    }
    return 1 + Math.max(left, right);
}
</code></pre><p>The time complexity of the optimized isBalanced method is O(n), where n is the number of nodes in the binary tree, because each node is visited only once and its height is computed in constant time. The space complexity is O(n) as well, because the maximum depth of the recursive call stack is equal to the height of the binary tree, which is O(n) in the worst case.</p><hr><p><strong>5. <a href=https://leetcode.com/problems/same-tree/>Same Tree</a>.</strong></p><pre><code class=language-java>public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null &amp;&amp; q == null) {
        return true;
    }
    if (p == null || q == null || p.val != q.val) {
        return false;
    }
    return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);
}
</code></pre><p>Time complexity: O(n), where n is the total number of nodes in the tree. This is because the function performs a recursive traversal of the entire tree, visiting each node once.</p><p>Space complexity: O(n), where n is the height of the tree. This is because the function uses a call stack to keep track of the recursive calls, and the maximum size of the call stack is proportional to the height of the tree. In the worst case, when the tree is completely unbalanced and resembles a linked list, the space complexity of the function becomes O(n). However, in a balanced tree, the space complexity is closer to O(log n), where log n is the height of the tree.</p><hr><p><strong>6. <a href=https://leetcode.com/problems/subtree-of-another-tree/>Subtree of Another Tree</a>.</strong></p><pre><code class=language-java>public boolean isSubtree(TreeNode s, TreeNode t) {
    if (s == null) {
        return false;
    }
    if (isSameTree(s, t)) {
        return true;
    }
    return isSubtree(s.left, t) || isSubtree(s.right, t);
}

public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null &amp;&amp; q == null) {
        return true;
    }
    if (p == null || q == null || p.val != q.val) {
        return false;
    }
    return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);
}
</code></pre><p>Time complexity: O(m * n), where m and n are the number of nodes in the trees s and t, respectively. This is because in the worst case, the function performs an isSameTree check for each node in s with t, which takes O(n) time. However, in the average case, the time complexity is closer to O(m), as the function will terminate early once it finds a matching subtree.</p><p>Space complexity: O(max(m, n)), as the function uses a call stack to keep track of the recursive calls, and the maximum size of the call stack is proportional to the height of the trees. In the worst case, when the trees are completely unbalanced and resemble linked lists, the space complexity becomes O(m) or O(n), whichever is greater.</p><p>Optimized version :</p><pre><code class=language-java>public boolean isSubtree(TreeNode s, TreeNode t) {
    String sPreOrder = getPreOrder(s);
    String tPreOrder = getPreOrder(t);
    return sPreOrder.indexOf(tPreOrder) != -1;
}

private String getPreOrder(TreeNode node) {
    if (node == null) {
        return &quot;null&quot;;
    }
    String left = getPreOrder(node.left);
    String right = getPreOrder(node.right);
    return &quot;#&quot; + node.val + &quot; &quot; + left + &quot; &quot; + right;
}
</code></pre><pre><code>sPreOrder: &quot;#3 #4 #1 null null #2 null null #5 null null&quot;
tPreOrder: &quot;#4 #1 null null #2 null null&quot;
</code></pre><p>The substring &ldquo;#4 #1 null null #2 null null&rdquo; is found in the string &ldquo;#3 #4 #1 null null #2 null null #5 null null&rdquo;, so we know that t is a subtree of s. Therefore, the function returns true.</p><p>Note that if t were not a subtree of s, then the function would have returned false. The pre-order traversal string of t would not be a substring of the pre-order traversal string of s, so the indexOf method would return -1.</p><p>Time complexity: O(m + n), where m and n are the number of nodes in the trees s and t, respectively. This is because the function only needs to traverse each tree once to get the pre-order traversal string, and the string matching operation takes O(m + n) time in the worst case</p><p>Space complexity: O(m + n), as it needs to store the pre-order traversal strings of both trees.</p><hr><p><strong>6. <a href=https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/>Lowest Common Ancestor of a Binary Search Tree</a>.</strong></p><pre><code class=language-java>class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || p == null || q == null) {
            return null;
        }
        
        if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) {
            return lowestCommonAncestor(root.left, p, q);
        }
        
        if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) {
            return lowestCommonAncestor(root.right, p, q);
        }
        
        return root;
    }
}
</code></pre><p>Time complexity: O(log N) in the best case and O(N) in the worst case, where N is the number of nodes in the BST. In the best case, when the BST is balanced, the time complexity of the algorithm is O(log N) since we eliminate half of the tree at each level. In the worst case, when the BST is skewed, the time complexity is O(N) since we may have to traverse the entire tree.</p><p>Space complexity: O(log N) in the best case and O(N) in the worst case. In the best case, when the BST is balanced, the space complexity of the algorithm is O(log N) since we only use a constant amount of space for each level of the recursive call stack. In the worst case, when the BST is skewed, the space complexity is O(N) since we may have to store all N nodes on the call stack.</p><hr><p><strong>7. <a href=https://leetcode.com/problems/binary-tree-level-order-traversal/>Binary Tree Level Order Traversal</a>.</strong></p><pre><code class=language-java>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if (root == null) {
            return result;
        }
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List&lt;Integer&gt; levelNodes = new ArrayList&lt;&gt;();
            for (int i = 0; i &lt; levelSize; i++) {
                TreeNode node = queue.poll();
                levelNodes.add(node.val);
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            result.add(levelNodes);
        }
        return result;
    }
}
</code></pre><p>Time complexity: O(N), where N is the number of nodes in the binary tree, since we need to visit each node once.</p><p>Space complexity: O(N) since we may need to store all N nodes in the queue at once in the worst case.</p><hr><p><strong>8. <a href=https://leetcode.com/problems/binary-tree-right-side-view/>Binary Tree Right Side View</a>.</strong></p><pre><code class=language-java>class Solution {
    public List&lt;Integer&gt; rightSideView(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        if (root == null) {
            return result;
        }
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            for (int i = 0; i &lt; levelSize; i++) {
                TreeNode node = queue.poll();
                if (i == levelSize - 1) {
                    result.add(node.val);
                }
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
        }
        return result;
    }
}
</code></pre><p>Time complexity: O(N), where N is the number of nodes in the binary tree, since we need to visit each node once.</p><p>Space complexity: O(N) since we may need to store all N nodes in the queue at once in the worst case.</p><hr><p><strong>8. <a href=https://leetcode.com/problems/validate-binary-search-tree/>Validate Binary Search Tree</a>.</strong></p><pre><code class=language-java>class Solution {
    public boolean isValidBST(TreeNode root) {
        // Use long instead of int to handle edge cases where value equals Integer.MIN_VALUE or Integer.MAX_VALUE
        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }
    
    private boolean isValidBST(TreeNode node, long minVal, long maxVal) {
        if (node == null) {
            return true;
        }
        if (node.val &lt;= minVal || node.val &gt;= maxVal) {
            return false;
        }
        return isValidBST(node.left, minVal, node.val) &amp;&amp; isValidBST(node.right, node.val, maxVal);
    }
}
</code></pre><p>Time complexity: O(n), where n is the number of nodes in the tree. This is because we visit each node exactly once during the in-order traversal.</p><p>Space complexity: O(n), where n is the number of nodes in the tree. This is because we need to store the recursive call stack during the traversal, which can be as large as the height of the tree, and in the worst case the height of the tree can be n.</p><hr><p><strong>8. <a href=https://leetcode.com/problems/count-good-nodes-in-binary-tree/>Count Good Nodes in Binary Tree</a>.</strong></p><pre><code class=language-java>class Solution {
    public int goodNodes(TreeNode root) {
        return countGoodNodes(root, Integer.MIN_VALUE);
    }
    
    private int countGoodNodes(TreeNode node, int maxSoFar) {
        if (node == null) return 0;
        
        int count = 0;
        if (node.val &gt;= maxSoFar) {
            count++;
            maxSoFar = node.val;
        }
        
        count += countGoodNodes(node.left, maxSoFar);
        count += countGoodNodes(node.right, maxSoFar);
        
        return count;
    }
}
</code></pre><p>Time complexity: O(n), where n is the number of nodes in the binary tree. This is because we traverse each node once in a depth-first manner.</p><p>Space complexity:O(h), where h is the height of the binary tree. This space is used for the recursive call stack. In the worst case, where the binary tree is skewed and has a height equivalent to the number of nodes (h ≈ n), the space complexity would be O(n). However, in a balanced binary tree, the space complexity would be O(log n), where log n is the height of the tree.</p><hr></span></section><hr><footer><nav><ul><li>© 2024 Karthik Selvam</li><li><a href=https://twitter.com/karthiikselvam><i class="fa-brands fa-twitter"></i></a>
&nbsp;&nbsp;
<a href=https://www.instagram.com/karthiikselvam/><i class="fa-brands fa-instagram"></i></a>
&nbsp;&nbsp;
<a href=https://www.linkedin.com/in/karthiiks/><i class="fa-brands fa-linkedin"></i></a></li></ul></nav></footer></main></body></html>