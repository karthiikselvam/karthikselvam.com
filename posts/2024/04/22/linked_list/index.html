<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Ronalds Vilcins - https://karthikselvam.com/"><title>Linked List | Karthik Selvam</title><meta name=description content="2024"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linked List"><meta name=twitter:description content="2024"><meta property="og:title" content="Linked List"><meta property="og:description" content="2024"><meta property="og:type" content="article"><meta property="og:url" content="https://karthikselvam.com/posts/2024/04/22/linked_list/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-22T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-22T00:00:00+00:00"><meta itemprop=name content="Linked List"><meta itemprop=description content="2024"><meta itemprop=datePublished content="2024-04-22T00:00:00+00:00"><meta itemprop=dateModified content="2024-04-22T00:00:00+00:00"><meta itemprop=wordCount content="1290"><meta itemprop=keywords content="datastructures,"><link rel=canonical href=https://karthikselvam.com/posts/2024/04/22/linked_list/><link rel=dns-prefetch href=https://www.google-analytics.com><link href=https://www.google-analytics.com rel=preconnect crossorigin><link rel=alternate type=application/atom+xml title="Karthik Selvam" href=https://karthikselvam.com/atom.xml><link rel=alternate type=application/json title="Karthik Selvam" href=https://karthikselvam.com/feed.json><script src=https://kit.fontawesome.com/8d06e0a013.js crossorigin=anonymous></script>
<link rel="shortcut icon" type=image/png href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII="><style>*,:after,:before{box-sizing:border-box;padding:0}body{font:1rem/1.5 '-apple-system',BlinkMacSystemFont,avenir next,avenir,helvetica,helvetica neue,ubuntu,roboto,noto,segoe ui,arial,sans-serif;text-rendering:optimizeSpeed}.posts hr{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:none;border-bottom:1px #353535;flex:1 0 1rem}main{max-width:70ch;padding:2ch;margin:auto}a,body{color:#353535}::selection,a:focus,a:hover{background-color:#353535;color:#fff}.meta{margin:0 0 2.5rem}.tags::before{content:"\2022";margin-left:1rem}code,pre{color:#353535;font-family:San Francisco Mono,Monaco,consolas,lucida console,dejavu sans mono,bitstream vera sans mono,monospace;font-size:normal;border:1px solid #353535;font-size:small}code{padding:.1rem;border:none}pre{padding:.5rem;overflow-x:auto}pre code{border:none}img{max-width:100%;border:1px solid #353535}hr{background:#353535;height:1px;border:0}ul{list-style-type:square}ul,ol{padding-left:1.2rem}header li,footer li{display:inline;text-transform:uppercase}header a,footer a{text-decoration:none}header ul,footer ul{justify-content:space-between;display:flex}header,section,footer{padding:1rem 0}blockquote{border-left:5px solid #353535;padding-left:1rem}.posts ul,header ul,footer ul{list-style:none}.posts,header ul,footer ul{padding:0}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.7rem}.posts li a,.posts li div{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}.hash{opacity:.25;text-decoration:none}table{border-collapse:collapse;text-align:left;width:100%}table tr{background:#fff;border-bottom:1px solid}table th,table td{padding:10px 20px}</style><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Linked List","headline":"Linked List","alternativeHeadline":"","description":"2024","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/karthikselvam.com\/posts\/2024\/04\/22\/linked_list\/"},"author":{"@type":"Person","name":""},"creator":{"@type":"Person","name":""},"accountablePerson":{"@type":"Person","name":""},"copyrightHolder":"Karthik Selvam","copyrightYear":"2024","dateCreated":"2024-04-22T00:00:00.00Z","datePublished":"2024-04-22T00:00:00.00Z","dateModified":"2024-04-22T00:00:00.00Z","publisher":{"@type":"Organization","name":"Karthik Selvam","url":"https://karthikselvam.com/","logo":{"@type":"ImageObject","url":"https:\/\/karthikselvam.com\/","width":"32","height":"32"}},"image":"https://karthikselvam.com/","url":"https:\/\/karthikselvam.com\/posts\/2024\/04\/22\/linked_list\/","wordCount":"1290","genre":["datastructures"],"keywords":["datastructures"]}</script></head><body><main><header><nav><ul><li><a href=/>Blog</a></li><li><a href=/about/>@Karthik</a></li><li><a href=https://twitter.com/karthiikselvam><i class="fa-brands fa-twitter"></i></a>
&nbsp;&nbsp;
<a href=https://www.instagram.com/karthiikselvam/><i class="fa-brands fa-instagram"></i></a>
&nbsp;&nbsp;
<a href=https://www.linkedin.com/in/karthiiks/><i class="fa-brands fa-linkedin"></i></a></li></ul></nav></header><hr><section><h2 itemprop="name headline">Linked List</h2><p class=meta><time itemprop=datePublished datetime=2024-04-22>April 22, 2024</time> &bull;
<a href=/tags/datastructures>datastructures</a></p><span itemprop=articleBody><p>In this article, we will solve linked list related problems that are commonly encountered in interviews.</p><p><strong>1. <a href=https://leetcode.com/problems/reverse-linked-list/>Reverse Linked List</a>.</strong></p><pre><code class=language-java>public class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode current = head;
        
        while (current != null) {
            ListNode nextTemp = current.next;
            current.next = prev;
            prev = current;
            current = nextTemp;
        }
        
        return prev; // prev now points to the new head of the reversed list
    }
}
</code></pre><p>Time complexity: O(n), where n is the number of nodes in the linked list.The algorithm iterates through each node of the linked list once. The time complexity is directly proportional to the number of nodes in the list</p><p>Space complexity: O(1) The iterative approach uses a constant amount of extra space regardless of the size of the input linked list. We only use a few extra pointers (prev, current, nextTemp) to perform the reversal in place, hence the space complexity is constant.</p><hr><p><strong>2. <a href=https://leetcode.com/problems/merge-two-sorted-lists/>Merge Two Sorted Lists</a>.</strong></p><pre><code class=language-java>class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        final ListNode root = new ListNode();
        ListNode prev = root;
        while (list1 != null &amp;&amp; list2 != null) {
            if (list1.val &lt; list2.val) {
                prev.next = list1;
                list1 = list1.next;
            } else {
                prev.next = list2;
                list2 = list2.next;
            }
            prev = prev.next;
        }
        prev.next = list1 != null ? list1 : list2;
        return root.next;
    }
}
</code></pre><p>Time complexity: O(n), where n is the number of nodes in the linked list.The algorithm iterates through each node of the linked list once. The time complexity is directly proportional to the number of nodes in the list</p><p>Space complexity: O(1) The iterative approach uses a constant amount of extra space regardless of the size of the input linked list. We only use a few extra pointers (prev, root) to perform the reversal in place, hence the space complexity is constant.</p><hr><p><strong>3. <a href=https://leetcode.com/problems/reorder-list/>Reorder List</a>.</strong></p><pre><code class=language-java>class Solution {
    public void reorderList(ListNode head) {
        //Find middle of list using a slow and fast pointer approach
        ListNode slow = head;
        ListNode fast = head.next;
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        //Reverse the second half of the list using a tmp variable
        ListNode second = slow.next;
        ListNode prev = slow.next = null;
        while (second != null) {
            ListNode tmp = second.next;
            second.next = prev;
            prev = second;
            second = tmp;
        }
        //Re-assign the pointers to match the pattern
        ListNode first = head;
        second = prev;
        while (second != null) {
            ListNode tmp1 = first.next;
            ListNode tmp2 = second.next;
            first.next = second;
            second.next = tmp1;
            first = tmp1;
            second = tmp2;
        }
    }
}
</code></pre><p>Time complexity: O(n), where n is the number of nodes in the linked list.The algorithm iterates through each node of the linked list once. The time complexity is directly proportional to the number of nodes in the list</p><p>Space complexity: O(1) The iterative approach uses a constant amount of extra space regardless of the size of the input linked list. We only use a few extra pointers (prev, root) to perform the reversal in place, hence the space complexity is constant.</p><hr><p><strong>4. <a href=https://leetcode.com/problems/remove-nth-node-from-end-of-list/>Remove nth node from the end of list</a>.</strong></p><pre><code class=language-java>public class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode fast = dummy;
        ListNode slow = dummy;
        
        // Move fast pointer n steps ahead
        for (int i = 0; i &lt;= n; i++) {
            fast = fast.next;
        }
        
        // Move both fast and slow pointers until fast reaches the end
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }
        
        // Remove the nth node from the end
        slow.next = slow.next.next;
        
        return dummy.next;
    }
}
</code></pre><p>Time complexity: O(n), where n is the number of nodes in the linked list.The algorithm iterates through each node of the linked list once. The time complexity is directly proportional to the number of nodes in the list</p><p>Space complexity: O(1) The iterative approach uses a constant amount of extra space regardless of the size of the input linked list.</p><hr><p><strong>5. <a href=https://leetcode.com/problems/linked-list-cycle/>Linked List Cycle</a>.</strong></p><pre><code class=language-java>public class Solution {

    public boolean hasCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while (fast != null &amp;&amp; fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) return true;
        }
        return false;
    }
}
</code></pre><p>Time complexity: O(n), where n is the number of nodes in the linked list.The algorithm iterates through each node of the linked list once. The time complexity is directly proportional to the number of nodes in the list</p><p>Space complexity: O(1) The iterative approach uses a constant amount of extra space regardless of the size of the input linked list.</p><hr><p><strong>6. <a href=https://leetcode.com/problems/find-the-duplicate-number/>Find the Duplicate Number</a>.</strong></p><pre><code class=language-java>    public int findDuplicate(int[] nums) {
        // Initialize slow and fast pointers
        int slow = nums[0];
        int fast = nums[0];
        
        // Move slow pointer one step and fast pointer two steps
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);
        
        // Move slow pointer to the start
        slow = nums[0];
        
        // Move both pointers at the same speed until they meet
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        
        // Return the duplicate number
        return slow;
    }


</code></pre><p>Time complexity: The first phase, where we detect the cycle, takes O(n) time, where n is the length of the array.The second phase, where we find the entrance to the cycle, also takes O(n) time in the worst case.</p><p>Space complexity: O(1) We are only using a few extra integer variables to store indices (slow and fast pointers), so the space complexity is O(1), constant space.</p><hr><p><strong>7. <a href=https://leetcode.com/problems/merge-k-sorted-lists/>Merge k Sorted Lists</a>.</strong></p><pre><code class=language-java>    //  Solution using Min Heap
    //  Time Complexity: O(n*log(k))
    //  Extra Space Complexity: O(k)
class Solution1 {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) {
            return null;
        }

        PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;((a, b) -&gt; a.val - b.val);
        for (ListNode node : lists) {
            if (node != null) {
                queue.offer(node);
            }
        }

        ListNode dummy = new ListNode(0);
        ListNode current = dummy;

        while (!queue.isEmpty()) {
            ListNode node = queue.poll();
            current.next = node;
            current = current.next;

            if (node.next != null) {
                queue.offer(node.next);
            }
        }

        return dummy.next;
    }
}

class Solution2 {
    public ListNode mergeKLists(ListNode[] lists) {
        int size = lists.length;
        int interval = 1;

        while (interval &lt; size) {
            for (int i = 0; i &lt; size - interval; i += 2 * interval) {
                lists[i] = mergeTwoLists(lists[i], lists[i + interval]);
            }

            interval *= 2;
        }

        return size &gt; 0 ? lists[0] : null;
    }
}

</code></pre><p>Time complexity: The first phase, where we detect the cycle, takes O(n) time, where n is the length of the array.The second phase, where we find the entrance to the cycle, also takes O(n) time in the worst case.</p><p>Space complexity: O(1) We are only using a few extra integer variables to store indices (slow and fast pointers), so the space complexity is O(1), constant space.</p><hr><p><strong>5. <a href=https://leetcode.com/problems/copy-list-with-random-pointer>Copy List with Random Pointer</a>.</strong></p><pre><code class=language-java>class Solution {

    public Node copyRandomList(Node head) {
        Node cur = head;
        HashMap&lt;Node, Node&gt; map = new HashMap&lt;&gt;();
        while (cur != null) {
            map.put(cur, new Node(cur.val));
            cur = cur.next;
        }
        cur = head;
        while (cur != null) {
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        return map.get(head);
    }
}

</code></pre><p>Time complexity: In the first pass, we iterate through the original list once to create a copy of each node. This operation takes O(n), where n is the number of nodes in the original list. In the second pass, we again iterate through the original list once to link the copied nodes and assign random pointers. This operation also takes O(n).</p><p>Space complexity: O(n) due to the HashMap and the additional nodes created for the copied list.</p><hr></span></section><hr><footer><nav><ul><li>© 2025 Karthik Selvam</li><li><a href=https://twitter.com/karthiikselvam><i class="fa-brands fa-twitter"></i></a>
&nbsp;&nbsp;
<a href=https://www.instagram.com/karthiikselvam/><i class="fa-brands fa-instagram"></i></a>
&nbsp;&nbsp;
<a href=https://www.linkedin.com/in/karthiiks/><i class="fa-brands fa-linkedin"></i></a></li></ul></nav></footer></main></body></html>