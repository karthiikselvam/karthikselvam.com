<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Ronalds Vilcins - https://karthikselvam.com/"><title>Recursion & Backtracking | Karthik Selvam</title><meta name=description content="2024"><meta name=twitter:card content="summary"><meta name=twitter:title content="Recursion & Backtracking"><meta name=twitter:description content="2024"><meta property="og:title" content="Recursion & Backtracking"><meta property="og:description" content="2024"><meta property="og:type" content="article"><meta property="og:url" content="https://karthikselvam.com/posts/2024/04/22/recursion_backtracking/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-22T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-22T00:00:00+00:00"><meta itemprop=name content="Recursion & Backtracking"><meta itemprop=description content="2024"><meta itemprop=datePublished content="2024-04-22T00:00:00+00:00"><meta itemprop=dateModified content="2024-04-22T00:00:00+00:00"><meta itemprop=wordCount content="1149"><meta itemprop=keywords content="datastructures,"><link rel=canonical href=https://karthikselvam.com/posts/2024/04/22/recursion_backtracking/><link rel=dns-prefetch href=https://www.google-analytics.com><link href=https://www.google-analytics.com rel=preconnect crossorigin><link rel=alternate type=application/atom+xml title="Karthik Selvam" href=https://karthikselvam.com/atom.xml><link rel=alternate type=application/json title="Karthik Selvam" href=https://karthikselvam.com/feed.json><script src=https://kit.fontawesome.com/8d06e0a013.js crossorigin=anonymous></script>
<link rel="shortcut icon" type=image/png href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII="><style>*,:after,:before{box-sizing:border-box;padding:0}body{font:1rem/1.5 '-apple-system',BlinkMacSystemFont,avenir next,avenir,helvetica,helvetica neue,ubuntu,roboto,noto,segoe ui,arial,sans-serif;text-rendering:optimizeSpeed}.posts hr{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:none;border-bottom:1px #353535;flex:1 0 1rem}main{max-width:70ch;padding:2ch;margin:auto}a,body{color:#353535}::selection,a:focus,a:hover{background-color:#353535;color:#fff}.meta{margin:0 0 2.5rem}.tags::before{content:"\2022";margin-left:1rem}code,pre{color:#353535;font-family:San Francisco Mono,Monaco,consolas,lucida console,dejavu sans mono,bitstream vera sans mono,monospace;font-size:normal;border:1px solid #353535;font-size:small}code{padding:.1rem;border:none}pre{padding:.5rem;overflow-x:auto}pre code{border:none}img{max-width:100%;border:1px solid #353535}hr{background:#353535;height:1px;border:0}ul{list-style-type:square}ul,ol{padding-left:1.2rem}header li,footer li{display:inline;text-transform:uppercase}header a,footer a{text-decoration:none}header ul,footer ul{justify-content:space-between;display:flex}header,section,footer{padding:1rem 0}blockquote{border-left:5px solid #353535;padding-left:1rem}.posts ul,header ul,footer ul{list-style:none}.posts,header ul,footer ul{padding:0}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.7rem}.posts li a,.posts li div{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}.hash{opacity:.25;text-decoration:none}table{border-collapse:collapse;text-align:left;width:100%}table tr{background:#fff;border-bottom:1px solid}table th,table td{padding:10px 20px}</style><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Recursion \u0026 Backtracking","headline":"Recursion \u0026 Backtracking","alternativeHeadline":"","description":"2024","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/karthikselvam.com\/posts\/2024\/04\/22\/recursion_backtracking\/"},"author":{"@type":"Person","name":""},"creator":{"@type":"Person","name":""},"accountablePerson":{"@type":"Person","name":""},"copyrightHolder":"Karthik Selvam","copyrightYear":"2024","dateCreated":"2024-04-22T00:00:00.00Z","datePublished":"2024-04-22T00:00:00.00Z","dateModified":"2024-04-22T00:00:00.00Z","publisher":{"@type":"Organization","name":"Karthik Selvam","url":"https://karthikselvam.com/","logo":{"@type":"ImageObject","url":"https:\/\/karthikselvam.com\/","width":"32","height":"32"}},"image":"https://karthikselvam.com/","url":"https:\/\/karthikselvam.com\/posts\/2024\/04\/22\/recursion_backtracking\/","wordCount":"1149","genre":["datastructures"],"keywords":["datastructures"]}</script></head><body><main><header><nav><ul><li><a href=/>Blog</a></li><li><a href=/about/>@Karthik</a></li><li><a href=https://twitter.com/karthiikselvam><i class="fa-brands fa-twitter"></i></a>
&nbsp;&nbsp;
<a href=https://www.instagram.com/karthiikselvam/><i class="fa-brands fa-instagram"></i></a>
&nbsp;&nbsp;
<a href=https://www.linkedin.com/in/karthiiks/><i class="fa-brands fa-linkedin"></i></a></li></ul></nav></header><hr><section><h2 itemprop="name headline">Recursion & Backtracking</h2><p class=meta><time itemprop=datePublished datetime=2024-04-22>April 22, 2024</time> &bull;
<a href=/tags/datastructures>datastructures</a></p><span itemprop=articleBody><p>In this article, we will solve recursion and backtracking related problems that are commonly encountered in interviews.</p><p>**1. Given an array of integers, print all combinations of size X.</p><pre><code class=language-java>public static void printCombos(int[] a, int x) {
    if (a == null || a.length == 0 || x &gt; a.length)
        return;
    int[] buffer = new int[x];
    printCombosHelper(a, buffer, 0, 0);
}

public static void printCombosHelper(int[] a, int[] buffer, int startIndex, int bufferIndex) {
    // termination cases - buffer full
    if (bufferIndex == buffer.length) {
        printArray(buffer);
        return;
    }
    if (startIndex == a.length) {
        return;
    }
    // find candidates that go into current buffer index
    for (int i = startIndex; i &lt; a.length; i++) {
        // place item into buffer
        buffer[bufferIndex] = a[i];
        // recurse to next buffer index
        printCombosHelper(a, buffer, i + 1, bufferIndex + 1);
    }
}

</code></pre><p>Time complexity: O(n^x), where n is the length of array &lsquo;a&rsquo; and &lsquo;x&rsquo; is the size of combinations.</p><p>Space complexity: O(x), for the buffer array.</p><hr><p>**2. Given an array of integers A, print all its subsets.</p><pre><code class=language-java>public static void printSubsets(int[] a, int x) {
    if (a == null || a.length == 0 || x &gt; a.length)
        return;
    int[] buffer = new int[x];
    printCombosHelper(a, buffer, 0, 0);
}

public static void printSubsetsHelper(int[] a, int[] buffer, int startIndex, int bufferIndex) {
    printArray(buffer);
    // termination cases - buffer full
    if (bufferIndex == buffer.length) {
        return;
    }
    if (startIndex == a.length) {
        return;
    }
    // find candidates that go into current buffer index
    for (int i = startIndex; i &lt; a.length; i++) {
        // place item into buffer
        buffer[bufferIndex] = a[i];
        // recurse to next buffer index
        printCombosHelper(a, buffer, i + 1, bufferIndex + 1);
    }
}

</code></pre><p>Time complexity: O(n^x), where n is the length of array &lsquo;a&rsquo; and &lsquo;x&rsquo; is the size of combinations.</p><p>Space complexity: O(x), for the buffer array.</p><hr><p><strong>3. <a href=https://leetcode.com/problems/subsets/>Subsets</a>.</strong></p><pre><code class=language-java>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; templist  = new  ArrayList&lt;&gt;();
        getSubsets(nums,result,templist,0);
        return result;
    }
    
    public void getSubsets(int[] nums, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tempList , int start){
            result.add(new ArrayList(tempList));
            if(start &gt;= nums.length){
                return;
            }
            for(int i = start ; i &lt; nums.length ; i++){
                tempList.add(nums[i]);
                getSubsets(nums,result,tempList,i+1);
                tempList.remove(tempList.size()-1);
            }
    }
}
</code></pre><hr><p><strong>3. <a href=https://leetcode.com/problems/subsets-ii/>Subsets II</a>.</strong></p><pre><code class=language-java>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {
        Arrays.sort(nums) ;
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; tempList = new ArrayList&lt;&gt;();
        getSubsets(nums,result,tempList,0);
        return result;
    }
    
    public void getSubsets(int[] nums, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tempList , int start){
       result.add(new ArrayList(tempList));
       if(start &gt;= nums.length){
           return;
       }
       for(int i =start ; i &lt; nums.length ; i++){
           if(i &gt; start &amp;&amp; nums[i-1] == nums[i]){
                continue; 
           }
           tempList.add(nums[i]);
           getSubsets(nums,result,tempList,i+1);
           tempList.remove(tempList.size()-1);
       }
    }
}
</code></pre><p>Time complexity: O(n), where n is the number of nodes in the linked list.The algorithm iterates through each node of the linked list once. The time complexity is directly proportional to the number of nodes in the list</p><p>Space complexity: O(1) The iterative approach uses a constant amount of extra space regardless of the size of the input linked list. We only use a few extra pointers (prev, current, nextTemp) to perform the reversal in place, hence the space complexity is constant.</p><hr><p>**4. Given an array A, print all permutations of size X.</p><pre><code class=language-java>public static void printPerms(int[] a, int x) {
    if (a == null || a.length == 0 || x &gt; a.length)
        return;
    int[] buffer = new int[x];
    boolean[] isInBuffer = new boolean[a.length];
    printPermsHelper(a, buffer, 0, isInBuffer);
}

public static void printPermsHelper(int[] a, int[] buffer, int bufferIndex, boolean[] isInBuffer) {
    // termination cases - buffer full
    if (bufferIndex == buffer.length) {
        printArray(buffer);
        return;
    }
    // find candidates that go into current buffer index
    for (int i = startIndex; i &lt; a.length; i++) {
        // place item into buffer
        buffer[bufferIndex] = a[i];
        isInBuffer[i] = true;
        // recurse to next buffer index
        printCombosHelper(a, buffer, bufferIndex + 1, isInBuffer);
        isInBuffer[i] = false;
    }
}
</code></pre><p>Time complexity: O(n^x), where n is the length of array &lsquo;a&rsquo; and &lsquo;x&rsquo; is the size of combinations.</p><p>Space complexity: O(x), for the buffer array.</p><hr><p><strong>6. <a href=https://leetcode.com/problems/palindrome-partitioning/>Palindrome Partitioning</a>.</strong></p><pre><code class=language-java>class Solution {
    public List&lt;List&lt;String&gt;&gt; partition(String s) {
        List&lt;List&lt;String&gt;&gt; partitions = new ArrayList&lt;&gt;();
        backtrack(s, 0, new ArrayList&lt;&gt;(), partitions);
        return partitions;
    }
    
    private void backtrack(String s, int start, List&lt;String&gt; path, List&lt;List&lt;String&gt;&gt; partitions) {
        if (start == s.length()) {
            partitions.add(new ArrayList&lt;&gt;(path));
            return;
        }
        
        for (int end = start + 1; end &lt;= s.length(); end++) {
            if (isPalindrome(s, start, end - 1)) {
                path.add(s.substring(start, end));
                backtrack(s, end, path, partitions);
                path.remove(path.size() - 1);
            }
        }
    }
    
    private boolean isPalindrome(String s, int left, int right) {
        while (left &lt; right) {
            if (s.charAt(left++) != s.charAt(right--)) {
                return false;
            }
        }
        return true;
    }
}

</code></pre><hr><p><strong>7. <a href=hhttps://leetcode.com/problems/combination-sum/>Combination Sum</a>.</strong></p><pre><code class=language-java>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        backtrack(candidates, target, 0, new ArrayList&lt;&gt;(), result);
        return result;
    }
    
    private void backtrack(int[] candidates, int target, int start, List&lt;Integer&gt; combination, List&lt;List&lt;Integer&gt;&gt; result) {
        if (target == 0) {
            result.add(new ArrayList&lt;&gt;(combination));
            return;
        }
        
        for (int i = start; i &lt; candidates.length; i++) {
            if (candidates[i] &lt;= target) {
                combination.add(candidates[i]);
                backtrack(candidates, target - candidates[i], i, combination, result);
                combination.remove(combination.size() - 1);
            }
        }
    }
}
</code></pre><hr><p><strong>8. <a href=https://leetcode.com/problems/permutations/>Permutations</a>.</strong></p><pre><code class=language-java>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        backtrack(result, new ArrayList&lt;&gt;(), nums);
        return result;
    }

    private void backtrack(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tempList, int[] nums) {
        if (tempList.size() == nums.length) {
            result.add(new ArrayList&lt;&gt;(tempList));
        } else {
            for (int i = 0; i &lt; nums.length; i++) {
                if (tempList.contains(nums[i])) continue;
                tempList.add(nums[i]);
                backtrack(result, tempList, nums);
                tempList.remove(tempList.size() - 1);
            }
        }
    }
}

</code></pre><hr><p><strong>8. <a href=https://leetcode.com/problems/combination-sum-ii>Combination Sum II</a>.</strong></p><pre><code class=language-java>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        Arrays.sort(candidates);
        backtrack(result, new ArrayList&lt;&gt;(), candidates, target, 0);
        return result;
    }

    private void backtrack(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tempList, int[] candidates, int remain, int start) {
        if (remain &lt; 0) return;
        else if (remain == 0) result.add(new ArrayList&lt;&gt;(tempList));
        else {
            for (int i = start; i &lt; candidates.length; i++) {
                if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) continue; // skip duplicates
                tempList.add(candidates[i]);
                backtrack(result, tempList, candidates, remain - candidates[i], i + 1);
                tempList.remove(tempList.size() - 1);
            }
        }
    }
}

</code></pre><hr><p><strong>9. <a href=https://leetcode.com/problems/word-search/>Word Search</a>.</strong></p><pre><code class=language-java>class Solution {
    public boolean exist(char[][] board, String word) {
        int rows = board.length ; 
        int cols = board[0].length;
        
        for(int r = 0 ; r &lt; rows; r++ ){
            for(int c = 0 ; c &lt; cols; c++){
                if(dfs(board,word,r,c,rows,cols,0)){
                    return true;
                }
            }
        }
        return false;
    }
    
   public boolean dfs(char[][] board, String word, int r, int c , int rows, int cols, int index) {
       if(index == word.length()){
           return true;
       }
       
       if(oob(r,c,rows,cols) || board[r][c] != word.charAt(index) || board[r][c] == '#' ){
           return false;
       }
       
       char ch = board[r][c];
       board[r][c] = '#';
       boolean result = dfs(board,word,r+1,c,rows,cols,index+1) ||  dfs(board,word,r-1,c,rows,cols,index+1) || 
                dfs(board,word,r,c-1,rows,cols,index+1) ||  dfs(board,word,r,c+1,rows,cols,index+1) ;
       board[r][c] = ch;
       return result;
   }
    
    public boolean oob(int r, int c , int rows , int cols) {
       if(r &gt; rows-1 || r &lt; 0 || c&gt; cols-1 || c &lt; 0) {
           return true;
       } else{
           return false;
       }
    }
}
</code></pre><hr></span></section><hr><footer><nav><ul><li>© 2024 Karthik Selvam</li><li><a href=https://twitter.com/karthiikselvam><i class="fa-brands fa-twitter"></i></a>
&nbsp;&nbsp;
<a href=https://www.instagram.com/karthiikselvam/><i class="fa-brands fa-instagram"></i></a>
&nbsp;&nbsp;
<a href=https://www.linkedin.com/in/karthiiks/><i class="fa-brands fa-linkedin"></i></a></li></ul></nav></footer></main></body></html>