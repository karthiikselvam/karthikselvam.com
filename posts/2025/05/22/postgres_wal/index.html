<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Ronalds Vilcins - https://karthikselvam.com/"><title>Understanding PostgreSQL’s Write-Ahead Logging (WAL) | Karthik Selvam</title><meta name=description content="2023"><meta name=twitter:card content="summary"><meta name=twitter:title content="Understanding PostgreSQL’s Write-Ahead Logging (WAL)"><meta name=twitter:description content="2023"><meta property="og:title" content="Understanding PostgreSQL’s Write-Ahead Logging (WAL)"><meta property="og:description" content="2023"><meta property="og:type" content="article"><meta property="og:url" content="https://karthikselvam.com/posts/2025/05/22/postgres_wal/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-22T00:00:00+00:00"><meta property="article:modified_time" content="2025-05-22T00:00:00+00:00"><meta itemprop=name content="Understanding PostgreSQL’s Write-Ahead Logging (WAL)"><meta itemprop=description content="2023"><meta itemprop=datePublished content="2025-05-22T00:00:00+00:00"><meta itemprop=dateModified content="2025-05-22T00:00:00+00:00"><meta itemprop=wordCount content="621"><meta itemprop=keywords content="postgres,"><link rel=canonical href=https://karthikselvam.com/posts/2025/05/22/postgres_wal/><link rel=dns-prefetch href=https://www.google-analytics.com><link href=https://www.google-analytics.com rel=preconnect crossorigin><link rel=alternate type=application/atom+xml title="Karthik Selvam" href=https://karthikselvam.com/atom.xml><link rel=alternate type=application/json title="Karthik Selvam" href=https://karthikselvam.com/feed.json><script src=https://kit.fontawesome.com/8d06e0a013.js crossorigin=anonymous></script>
<link rel="shortcut icon" type=image/png href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII="><style>*,:after,:before{box-sizing:border-box;padding:0}body{font:1rem/1.5 '-apple-system',BlinkMacSystemFont,avenir next,avenir,helvetica,helvetica neue,ubuntu,roboto,noto,segoe ui,arial,sans-serif;text-rendering:optimizeSpeed}.posts hr{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:none;border-bottom:1px #353535;flex:1 0 1rem}main{max-width:70ch;padding:2ch;margin:auto}a,body{color:#353535}::selection,a:focus,a:hover{background-color:#353535;color:#fff}.meta{margin:0 0 2.5rem}.tags::before{content:"\2022";margin-left:1rem}code,pre{color:#353535;font-family:San Francisco Mono,Monaco,consolas,lucida console,dejavu sans mono,bitstream vera sans mono,monospace;font-size:normal;border:1px solid #353535;font-size:small}code{padding:.1rem;border:none}pre{padding:.5rem;overflow-x:auto}pre code{border:none}img{max-width:100%;border:1px solid #353535}hr{background:#353535;height:1px;border:0}ul{list-style-type:square}ul,ol{padding-left:1.2rem}header li,footer li{display:inline;text-transform:uppercase}header a,footer a{text-decoration:none}header ul,footer ul{justify-content:space-between;display:flex}header,section,footer{padding:1rem 0}blockquote{border-left:5px solid #353535;padding-left:1rem}.posts ul,header ul,footer ul{list-style:none}.posts,header ul,footer ul{padding:0}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.7rem}.posts li a,.posts li div{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}.hash{opacity:.25;text-decoration:none}table{border-collapse:collapse;text-align:left;width:100%}table tr{background:#fff;border-bottom:1px solid}table th,table td{padding:10px 20px}</style><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Understanding PostgreSQL’s Write-Ahead Logging (WAL)","headline":"Understanding PostgreSQL’s Write-Ahead Logging (WAL)","alternativeHeadline":"","description":"2023","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/karthikselvam.com\/posts\/2025\/05\/22\/postgres_wal\/"},"author":{"@type":"Person","name":""},"creator":{"@type":"Person","name":""},"accountablePerson":{"@type":"Person","name":""},"copyrightHolder":"Karthik Selvam","copyrightYear":"2025","dateCreated":"2025-05-22T00:00:00.00Z","datePublished":"2025-05-22T00:00:00.00Z","dateModified":"2025-05-22T00:00:00.00Z","publisher":{"@type":"Organization","name":"Karthik Selvam","url":"https://karthikselvam.com/","logo":{"@type":"ImageObject","url":"https:\/\/karthikselvam.com\/","width":"32","height":"32"}},"image":"https://karthikselvam.com/","url":"https:\/\/karthikselvam.com\/posts\/2025\/05\/22\/postgres_wal\/","wordCount":"621","genre":["postgres"],"keywords":["postgres"]}</script></head><body><main><header><nav><ul><li><a href=/>Blog</a></li><li><a href=/about/>@Karthik</a></li><li><a href=https://twitter.com/karthiikselvam><i class="fa-brands fa-twitter"></i></a>
&nbsp;&nbsp;
<a href=https://www.instagram.com/karthiikselvam/><i class="fa-brands fa-instagram"></i></a>
&nbsp;&nbsp;
<a href=https://www.linkedin.com/in/karthiiks/><i class="fa-brands fa-linkedin"></i></a></li></ul></nav></header><hr><section><h2 itemprop="name headline">Understanding PostgreSQL’s Write-Ahead Logging (WAL)</h2><p class=meta><time itemprop=datePublished datetime=2025-05-22>May 22, 2025</time> &bull;
<a href=/tags/postgres>postgres</a></p><span itemprop=articleBody><p>PostgreSQL’s Write-Ahead Logging (WAL) is at the heart of its durability and crash recovery. If you’ve ever wondered how PostgreSQL ensures your data is safe—even in the event of a crash—this post will walk you through the architecture, flow, and the actual source code that makes it all work.</p><hr><h2 id=high-level-architecture--flow-of-wal>High-Level Architecture & Flow of WAL <a href=#high-level-architecture--flow-of-wal class=hash>#</a></h2><h3 id=what-is-wal>What is WAL? <a href=#what-is-wal class=hash>#</a></h3><p>WAL is a mechanism that ensures all changes to the database are first recorded in a log before being applied to the data files. This guarantees that, even if the system crashes, PostgreSQL can recover to a consistent state.</p><h3 id=key-components>Key Components <a href=#key-components class=hash>#</a></h3><ul><li><strong>WAL Buffers:</strong><br>In-memory buffers that temporarily hold WAL records before they’re written to disk.</li><li><strong>WAL Files:</strong><br>On-disk files (in <code>pg_wal/</code>), typically 16MB each, storing the WAL records.</li><li><strong>WAL Writer Process:</strong><br>A background process that flushes WAL buffers to disk.</li><li><strong>Checkpointer:</strong><br>Ensures data files are consistent with WAL.</li><li><strong>Archiver:</strong><br>Optionally archives completed WAL segments for point-in-time recovery (PITR).</li></ul><h3 id=sequence-of-events>Sequence of Events <a href=#sequence-of-events class=hash>#</a></h3><ol><li><strong>Change Initiation:</strong><br>A transaction modifies data (e.g., an <code>INSERT</code>).</li><li><strong>WAL Record Creation:</strong><br>The change is encoded as a WAL record in memory.</li><li><strong>WAL Buffering:</strong><br>The WAL record is placed in the WAL buffers.</li><li><strong>WAL Flush:</strong><br>Before a transaction commits, its WAL records are flushed to disk.</li><li><strong>WAL File Management:</strong><br>WAL files are rotated, archived, and recycled as needed.</li><li><strong>Crash Recovery:</strong><br>On restart after a crash, WAL is replayed to bring the database to a consistent state.</li></ol><hr><h2 id=mapping-wal-to-the-postgresql-source-code>Mapping WAL to the PostgreSQL Source Code <a href=#mapping-wal-to-the-postgresql-source-code class=hash>#</a></h2><p>Let’s walk through the main code files and functions for each component.</p><h3 id=1-wal-record-creation>1. WAL Record Creation <a href=#1-wal-record-creation class=hash>#</a></h3><ul><li><strong>File:</strong> xlog.c</li><li><strong>Key Struct:</strong> <code>XLogRecord</code></li><li><strong>Key Functions:</strong><ul><li><code>XLogInsert()</code>: Called whenever a change is made (e.g., tuple insert/update/delete). Constructs a WAL record and appends it to the WAL buffers.</li><li><code>XLogRegisterData()</code>, <code>XLogRegisterBuffer()</code>: Used by lower-level code to register data and buffers that should be included in the WAL record.</li></ul></li></ul><h3 id=2-wal-buffering-and-flushing>2. WAL Buffering and Flushing <a href=#2-wal-buffering-and-flushing class=hash>#</a></h3><ul><li><strong>File:</strong> xlog.c</li><li><strong>Key Struct:</strong> <code>XLogCtlData</code> (shared memory control structure for WAL)</li><li><strong>Key Functions:</strong><ul><li><code>XLogWrite()</code>: Flushes WAL buffers to disk.</li><li><code>XLogFlush()</code>: Ensures that WAL up to a certain point is safely on disk (called before commit).</li><li><code>XLogBackgroundFlush()</code>: Used by the WAL writer background process.</li></ul></li></ul><h3 id=3-wal-writer-process>3. WAL Writer Process <a href=#3-wal-writer-process class=hash>#</a></h3><ul><li><strong>File:</strong> walwriter.c</li><li><strong>Key Function:</strong><ul><li><code>WalWriterMain()</code>: Main loop for the WAL writer background process, periodically flushing WAL buffers.</li></ul></li></ul><h3 id=4-wal-file-management>4. WAL File Management <a href=#4-wal-file-management class=hash>#</a></h3><ul><li><strong>File:</strong> xlog.c</li><li><strong>Key Functions:</strong><ul><li><code>XLogFileInit()</code>, <code>XLogFileOpen()</code>, <code>XLogFileClose()</code>: Manage creation, opening, and closing of WAL segment files.</li><li><code>XLogFileName()</code>: Generates the filename for a given WAL segment.</li></ul></li></ul><h3 id=5-crash-recovery>5. Crash Recovery <a href=#5-crash-recovery class=hash>#</a></h3><ul><li><strong>File:</strong> xlog.c</li><li><strong>Key Function:</strong><ul><li><code>StartupXLOG()</code>: Main function for crash recovery; reads and replays WAL records.</li></ul></li></ul><h3 id=6-archiving>6. Archiving <a href=#6-archiving class=hash>#</a></h3><ul><li><strong>File:</strong> xlogarchive.c</li><li><strong>Key Functions:</strong><ul><li><code>XLogArchiveNotify()</code>, <code>XLogArchiveCheckDone()</code></li></ul></li></ul><hr><h2 id=important-structs-macros-and-configurations>Important Structs, Macros, and Configurations <a href=#important-structs-macros-and-configurations class=hash>#</a></h2><ul><li><strong><code>XLogRecPtr</code></strong>: 64-bit pointer to a WAL location.</li><li><strong><code>XLogRecord</code></strong>: Struct representing a single WAL record.</li><li><strong><code>XLogCtlData</code></strong>: Shared memory structure for WAL state.</li></ul><p><strong>Configuration Parameters (in <code>postgresql.conf</code>):</strong></p><ul><li><code>wal_level</code></li><li><code>wal_buffers</code></li><li><code>wal_writer_delay</code></li><li><code>archive_mode</code>, <code>archive_command</code></li><li><code>max_wal_size</code>, <code>min_wal_size</code></li></ul><hr><h2 id=step-by-step-exploration>Step-by-Step Exploration <a href=#step-by-step-exploration class=hash>#</a></h2><ol><li><p><strong>WAL Record Creation:</strong><br>Start in <code>xlog.c</code> with <code>XLogInsert()</code>. See how a WAL record is constructed and added to the buffer. Explore how <code>XLogRegisterData()</code> and <code>XLogRegisterBuffer()</code> are used to build the record.</p></li><li><p><strong>WAL Buffering and Flushing:</strong><br>Follow <code>XLogWrite()</code> and <code>XLogFlush()</code>. See how WAL buffers are managed and flushed to disk. Understand the role of <code>XLogCtlData</code>.</p></li><li><p><strong>WAL Writer Process:</strong><br>Look at <code>WalWriterMain()</code> in <code>walwriter.c</code>. See how the background process periodically flushes WAL.</p></li><li><p><strong>WAL File Management:</strong><br>Explore <code>XLogFileInit()</code>, <code>XLogFileOpen()</code>, etc. See how WAL files are created, opened, and rotated.</p></li><li><p><strong>Crash Recovery:</strong><br>Study <code>StartupXLOG()</code>. See how WAL is replayed after a crash.</p></li></ol><hr><h2 id=conclusion>Conclusion <a href=#conclusion class=hash>#</a></h2><p>PostgreSQL’s WAL system is a robust, well-architected mechanism that ensures your data is safe and recoverable. By understanding both the high-level flow and the underlying source code, you gain insight into one of the most critical parts of PostgreSQL’s architecture.</p><hr></span></section><hr><footer><nav><ul><li>© 2025 Karthik Selvam</li><li><a href=https://twitter.com/karthiikselvam><i class="fa-brands fa-twitter"></i></a>
&nbsp;&nbsp;
<a href=https://www.instagram.com/karthiikselvam/><i class="fa-brands fa-instagram"></i></a>
&nbsp;&nbsp;
<a href=https://www.linkedin.com/in/karthiiks/><i class="fa-brands fa-linkedin"></i></a></li></ul></nav></footer></main></body></html>