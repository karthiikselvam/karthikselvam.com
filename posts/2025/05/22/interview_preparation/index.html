<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Ronalds Vilcins - https://karthikselvam.com/"><title>Deep Dive:PostgreSQL WAL, Replication, and Replication Slots | Karthik Selvam</title><meta name=description content="2023"><meta name=twitter:card content="summary"><meta name=twitter:title content="Deep Dive:PostgreSQL WAL, Replication, and Replication Slots"><meta name=twitter:description content="2023"><meta property="og:title" content="Deep Dive:PostgreSQL WAL, Replication, and Replication Slots"><meta property="og:description" content="2023"><meta property="og:type" content="article"><meta property="og:url" content="https://karthikselvam.com/posts/2025/05/22/interview_preparation/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-22T00:00:00+00:00"><meta property="article:modified_time" content="2025-05-22T00:00:00+00:00"><meta itemprop=name content="Deep Dive:PostgreSQL WAL, Replication, and Replication Slots"><meta itemprop=description content="2023"><meta itemprop=datePublished content="2025-05-22T00:00:00+00:00"><meta itemprop=dateModified content="2025-05-22T00:00:00+00:00"><meta itemprop=wordCount content="991"><meta itemprop=keywords content="postgres,"><link rel=canonical href=https://karthikselvam.com/posts/2025/05/22/interview_preparation/><link rel=dns-prefetch href=https://www.google-analytics.com><link href=https://www.google-analytics.com rel=preconnect crossorigin><link rel=alternate type=application/atom+xml title="Karthik Selvam" href=https://karthikselvam.com/atom.xml><link rel=alternate type=application/json title="Karthik Selvam" href=https://karthikselvam.com/feed.json><script src=https://kit.fontawesome.com/8d06e0a013.js crossorigin=anonymous></script>
<link rel="shortcut icon" type=image/png href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII="><style>*,:after,:before{box-sizing:border-box;padding:0}body{font:1rem/1.5 '-apple-system',BlinkMacSystemFont,avenir next,avenir,helvetica,helvetica neue,ubuntu,roboto,noto,segoe ui,arial,sans-serif;text-rendering:optimizeSpeed}.posts hr{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:none;border-bottom:1px #353535;flex:1 0 1rem}main{max-width:70ch;padding:2ch;margin:auto}a,body{color:#353535}::selection,a:focus,a:hover{background-color:#353535;color:#fff}.meta{margin:0 0 2.5rem}.tags::before{content:"\2022";margin-left:1rem}code,pre{color:#353535;font-family:San Francisco Mono,Monaco,consolas,lucida console,dejavu sans mono,bitstream vera sans mono,monospace;font-size:normal;border:1px solid #353535;font-size:small}code{padding:.1rem;border:none}pre{padding:.5rem;overflow-x:auto}pre code{border:none}img{max-width:100%;border:1px solid #353535}hr{background:#353535;height:1px;border:0}ul{list-style-type:square}ul,ol{padding-left:1.2rem}header li,footer li{display:inline;text-transform:uppercase}header a,footer a{text-decoration:none}header ul,footer ul{justify-content:space-between;display:flex}header,section,footer{padding:1rem 0}blockquote{border-left:5px solid #353535;padding-left:1rem}.posts ul,header ul,footer ul{list-style:none}.posts,header ul,footer ul{padding:0}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.7rem}.posts li a,.posts li div{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}.hash{opacity:.25;text-decoration:none}table{border-collapse:collapse;text-align:left;width:100%}table tr{background:#fff;border-bottom:1px solid}table th,table td{padding:10px 20px}</style><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Deep Dive:PostgreSQL WAL, Replication, and Replication Slots","headline":"Deep Dive:PostgreSQL WAL, Replication, and Replication Slots","alternativeHeadline":"","description":"2023","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/karthikselvam.com\/posts\/2025\/05\/22\/interview_preparation\/"},"author":{"@type":"Person","name":""},"creator":{"@type":"Person","name":""},"accountablePerson":{"@type":"Person","name":""},"copyrightHolder":"Karthik Selvam","copyrightYear":"2025","dateCreated":"2025-05-22T00:00:00.00Z","datePublished":"2025-05-22T00:00:00.00Z","dateModified":"2025-05-22T00:00:00.00Z","publisher":{"@type":"Organization","name":"Karthik Selvam","url":"https://karthikselvam.com/","logo":{"@type":"ImageObject","url":"https:\/\/karthikselvam.com\/","width":"32","height":"32"}},"image":"https://karthikselvam.com/","url":"https:\/\/karthikselvam.com\/posts\/2025\/05\/22\/interview_preparation\/","wordCount":"991","genre":["postgres"],"keywords":["postgres"]}</script></head><body><main><header><nav><ul><li><a href=/>Blog</a></li><li><a href=/about/>@Karthik</a></li><li><a href=https://twitter.com/karthiikselvam><i class="fa-brands fa-twitter"></i></a>
&nbsp;&nbsp;
<a href=https://www.instagram.com/karthiikselvam/><i class="fa-brands fa-instagram"></i></a>
&nbsp;&nbsp;
<a href=https://www.linkedin.com/in/karthiiks/><i class="fa-brands fa-linkedin"></i></a></li></ul></nav></header><hr><section><h2 itemprop="name headline">Deep Dive:PostgreSQL WAL, Replication, and Replication Slots</h2><p class=meta><time itemprop=datePublished datetime=2025-05-22>May 22, 2025</time> &bull;
<a href=/tags/postgres>postgres</a></p><span itemprop=articleBody><p>PostgreSQL’s reliability and advanced replication features are built on its Write-Ahead Log (WAL) and the mechanisms that manage it. In this post, we’ll go deep into how WAL works, how physical and logical replication use it, and how replication slots ensure data safety and consistency. We’ll also look at the actual C structures and functions that implement these features.</p><hr><h2 id=1-write-ahead-log-wal-the-foundation>1. Write-Ahead Log (WAL): The Foundation <a href=#1-write-ahead-log-wal-the-foundation class=hash>#</a></h2><h3 id=what-is-wal>What is WAL? <a href=#what-is-wal class=hash>#</a></h3><p>WAL is a sequential log of all changes made to the database. The core rule:<br><strong>No change is made to the data files until the change is safely written to the WAL.</strong></p><h3 id=how-wal-is-written>How WAL is Written <a href=#how-wal-is-written class=hash>#</a></h3><p>When a transaction modifies data:</p><ol><li><strong>WAL Record Creation:</strong><br>Each change (insert, update, delete) generates a WAL record.</li><li><strong>WAL Buffering:</strong><br>WAL records are first written to an in-memory buffer.</li><li><strong>WAL Flush:</strong><br>On commit, WAL records are flushed to disk (<code>pg_wal/</code> directory) using <code>XLogFlush()</code>.</li></ol><p><strong>Relevant code (simplified):</strong></p><pre><code class=language-c>// filepath: src/backend/access/transam/xlog.c
void
XLogFlush(XLogRecPtr record)
{
    // Ensures all WAL up to 'record' is written and fsync'd to disk
}
</code></pre><h3 id=wal-segments-and-lsn>WAL Segments and LSN <a href=#wal-segments-and-lsn class=hash>#</a></h3><ul><li>WAL is stored in segment files (default 16MB each).</li><li>Each WAL record has a Log Sequence Number (LSN), a unique pointer to its position in the log.</li></ul><hr><h2 id=2-wal-replay-crash-recovery-and-standby-sync>2. WAL Replay: Crash Recovery and Standby Sync <a href=#2-wal-replay-crash-recovery-and-standby-sync class=hash>#</a></h2><h3 id=on-the-primary>On the Primary <a href=#on-the-primary class=hash>#</a></h3><ul><li>WAL is both written and replayed as part of normal operation.</li><li>Crash recovery uses WAL to bring data files up to date.</li></ul><h3 id=on-the-standby>On the Standby <a href=#on-the-standby class=hash>#</a></h3><ul><li>Standby receives WAL from the primary (via streaming or file shipping).</li><li>Standby writes WAL to its own <code>pg_wal/</code>.</li><li>Standby <strong>replays</strong> WAL to apply changes to its data files.</li></ul><p><strong>Key functions:</strong></p><pre><code class=language-c>// filepath: src/backend/access/transam/xlog.c
XLogRecPtr GetXLogReplayRecPtr(TimeLineID *replayTLI);
</code></pre><hr><h2 id=3-physical-replication-streaming-wal>3. Physical Replication: Streaming WAL <a href=#3-physical-replication-streaming-wal class=hash>#</a></h2><h3 id=how-it-works>How It Works <a href=#how-it-works class=hash>#</a></h3><ul><li>Standby connects to primary using a replication protocol.</li><li>Primary sends WAL records as soon as they are written to disk.</li><li>Standby writes and replays WAL.</li></ul><p><strong>Key function for sending WAL:</strong></p><pre><code class=language-c>// filepath: src/backend/replication/walsender.c
void XLogSendPhysical(void)
{
    // Reads WAL from disk and sends to standby
}
</code></pre><h3 id=wal-positions>WAL Positions <a href=#wal-positions class=hash>#</a></h3><ul><li><strong>Received:</strong> WAL written to disk on standby.</li><li><strong>Replayed:</strong> WAL applied to data files on standby.</li></ul><p><strong>Code to get these positions:</strong></p><pre><code class=language-c>// filepath: src/backend/replication/walreceiver.c
XLogRecPtr GetWalRcvFlushRecPtr(TimeLineID *receiveTLI);
</code></pre><hr><h2 id=4-logical-replication-decoding-wal>4. Logical Replication: Decoding WAL <a href=#4-logical-replication-decoding-wal class=hash>#</a></h2><h3 id=how-it-works-1>How It Works <a href=#how-it-works-1 class=hash>#</a></h3><ul><li>WAL is written and replayed on the source.</li><li>Logical decoding reads WAL and interprets it as logical changes (row-level).</li><li>Changes are sent to subscribers, which apply them at the SQL level.</li></ul><p><strong>Logical decoding context:</strong></p><pre><code class=language-c>// filepath: src/include/replication/logical.h
typedef struct LogicalDecodingContext LogicalDecodingContext;
</code></pre><p><strong>Sending logical changes:</strong></p><pre><code class=language-c>// filepath: src/backend/replication/walsender.c
void XLogSendLogical(void)
{
    // Decodes and sends logical changes to subscriber
}
</code></pre><h3 id=wal-position-for-logical-replication>WAL Position for Logical Replication <a href=#wal-position-for-logical-replication class=hash>#</a></h3><ul><li>Logical decoding can only process WAL that has been <strong>replayed</strong> (applied).</li><li>This ensures the database state is consistent for decoding.</li></ul><hr><h2 id=5-replication-slots-wal-retention-and-safety>5. Replication Slots: WAL Retention and Safety <a href=#5-replication-slots-wal-retention-and-safety class=hash>#</a></h2><h3 id=what-is-a-replication-slot>What is a Replication Slot? <a href=#what-is-a-replication-slot class=hash>#</a></h3><p>A replication slot is a persistent object that tells PostgreSQL to retain WAL files until a replica (physical or logical) has processed them.</p><h3 id=slot-types>Slot Types <a href=#slot-types class=hash>#</a></h3><ul><li><strong>Physical slots:</strong> Used for physical replication.</li><li><strong>Logical slots:</strong> Used for logical replication.</li></ul><h3 id=slot-structures>Slot Structures <a href=#slot-structures class=hash>#</a></h3><p><strong>On-disk and in-memory representation:</strong></p><pre><code class=language-c>// filepath: src/include/replication/slot.h
typedef struct ReplicationSlotPersistentData
{
    NameData    name;
    Oid         database;
    ReplicationSlotPersistency persistency;
    TransactionId xmin;
    TransactionId catalog_xmin;
    XLogRecPtr   restart_lsn;
    ReplicationSlotInvalidationCause invalidated;
    XLogRecPtr   confirmed_flush;
    // ... more fields
} ReplicationSlotPersistentData;

typedef struct ReplicationSlot
{
    slock_t     mutex;
    bool        in_use;
    pid_t       active_pid;
    bool        just_dirtied;
    bool        dirty;
    TransactionId effective_xmin;
    TransactionId effective_catalog_xmin;
    ReplicationSlotPersistentData data;
    LWLock      io_in_progress_lock;
    ConditionVariable active_cv;
    // ... more fields for logical slots
} ReplicationSlot;
</code></pre><h3 id=slot-creation-and-management>Slot Creation and Management <a href=#slot-creation-and-management class=hash>#</a></h3><p><strong>Creating a physical slot:</strong></p><pre><code class=language-sql>SELECT * FROM pg_create_physical_replication_slot('myslot');
</code></pre><p><strong>Creating a logical slot:</strong></p><pre><code class=language-sql>SELECT * FROM pg_create_logical_replication_slot('myslot', 'pgoutput');
</code></pre><p><strong>Dropping a slot:</strong></p><pre><code class=language-sql>SELECT pg_drop_replication_slot('myslot');
</code></pre><p><strong>C functions:</strong></p><pre><code class=language-c>// filepath: src/backend/replication/slot.c
void ReplicationSlotCreate(const char *name, bool db_specific,
                          ReplicationSlotPersistency persistency,
                          bool two_phase, bool failover, bool synced);

void ReplicationSlotDrop(const char *name, bool nowait);
</code></pre><h3 id=how-slots-work>How Slots Work <a href=#how-slots-work class=hash>#</a></h3><ul><li>Each slot tracks the oldest WAL LSN needed by the replica.</li><li>The server will <strong>not remove</strong> WAL segments older than this LSN.</li><li>As the replica processes WAL, it reports progress, and the slot’s LSN advances.</li><li>Slots are stored in <code>pg_replslot/</code> and in shared memory.</li></ul><p><strong>Advancing slot LSN:</strong></p><pre><code class=language-c>// filepath: src/backend/replication/slot.c
void ReplicationSlotSave(void)
{
    // Saves slot state to disk
}
</code></pre><hr><h2 id=6-monitoring-and-troubleshooting>6. Monitoring and Troubleshooting <a href=#6-monitoring-and-troubleshooting class=hash>#</a></h2><p><strong>View all slots:</strong></p><pre><code class=language-sql>SELECT * FROM pg_replication_slots;
</code></pre><p><strong>Check WAL retention:</strong></p><pre><code class=language-sql>SELECT slot_name, restart_lsn, confirmed_flush_lsn FROM pg_replication_slots;
</code></pre><p><strong>Potential issues:</strong></p><ul><li>If a slot is not advancing (replica is offline or lagging), WAL files will accumulate, possibly filling up disk space.</li><li>Always drop unused slots to allow WAL cleanup.</li></ul><hr><h2 id=7-example-creating-and-using-a-logical-replication-slot>7. Example: Creating and Using a Logical Replication Slot <a href=#7-example-creating-and-using-a-logical-replication-slot class=hash>#</a></h2><p><strong>Step 1: Create a publication on the primary</strong></p><pre><code class=language-sql>CREATE PUBLICATION mypub FOR TABLE mytable;
</code></pre><p><strong>Step 2: Create a logical slot</strong></p><pre><code class=language-sql>SELECT * FROM pg_create_logical_replication_slot('myslot', 'pgoutput');
</code></pre><p><strong>Step 3: On the subscriber, create a subscription</strong></p><pre><code class=language-sql>CREATE SUBSCRIPTION mysub
  CONNECTION 'host=primary ...'
  PUBLICATION mypub;
</code></pre><p><strong>Step 4: Monitor slot progress</strong></p><pre><code class=language-sql>SELECT * FROM pg_replication_slots WHERE slot_name = 'myslot';
</code></pre><hr><h2 id=8-key-macros-and-utilities>8. Key Macros and Utilities <a href=#8-key-macros-and-utilities class=hash>#</a></h2><p><strong>Check slot type:</strong></p><pre><code class=language-c>#define SlotIsPhysical(slot) ((slot)-&gt;data.database == InvalidOid)
#define SlotIsLogical(slot) ((slot)-&gt;data.database != InvalidOid)
</code></pre><p><strong>Compute required LSN for all slots:</strong></p><pre><code class=language-c>XLogRecPtr ReplicationSlotsComputeRequiredLSN(void);
</code></pre><p><strong>Compute logical restart LSN:</strong></p><pre><code class=language-c>XLogRecPtr ReplicationSlotsComputeLogicalRestartLSN(void);
</code></pre><hr><h2 id=9-summary-table>9. Summary Table <a href=#9-summary-table class=hash>#</a></h2><table><thead><tr><th>Feature</th><th>Physical Replication</th><th>Logical Replication</th></tr></thead><tbody><tr><td>Data sent</td><td>Raw WAL records</td><td>Decoded logical changes</td></tr><tr><td>When can send</td><td>As soon as WAL is received</td><td>Only after WAL is replayed</td></tr><tr><td>Slot type</td><td>Physical</td><td>Logical</td></tr><tr><td>Subscriber applies</td><td>At storage level</td><td>At SQL/table level</td></tr><tr><td>Key functions</td><td><code>XLogSendPhysical</code>, <code>GetWalRcvFlushRecPtr</code></td><td><code>XLogSendLogical</code>, <code>LogicalDecodingContext</code></td></tr><tr><td>Slot struct</td><td><code>ReplicationSlot</code></td><td><code>ReplicationSlot</code></td></tr></tbody></table><hr><h2 id=10-conclusion>10. Conclusion <a href=#10-conclusion class=hash>#</a></h2><p>PostgreSQL’s WAL and replication system is both powerful and complex. WAL ensures durability and crash safety, while replication slots guarantee that no replica misses any changes. Understanding the difference between physical and logical replication, and how slots manage WAL retention, is crucial for database reliability and scaling.</p><p>If you want to go even deeper, explore the PostgreSQL source code in the files and functions referenced above. This will give you a true understanding of how these features are implemented.</p><hr><p><strong>Further Reading:</strong></p><ul><li><a href=https://www.postgresql.org/docs/current/wal-intro.html>PostgreSQL WAL Internals</a></li><li><a href=https://www.postgresql.org/docs/current/warm-standby.html>Streaming Replication</a></li><li><a href=https://www.postgresql.org/docs/current/logical-replication.html>Logical Replication</a></li><li><a href=https://www.postgresql.org/docs/current/warm-standby.html#STREAMING-REPLICATION-SLOTS>Replication Slots</a></li></ul><hr></span></section><hr><footer><nav><ul><li>© 2025 Karthik Selvam</li><li><a href=https://twitter.com/karthiikselvam><i class="fa-brands fa-twitter"></i></a>
&nbsp;&nbsp;
<a href=https://www.instagram.com/karthiikselvam/><i class="fa-brands fa-instagram"></i></a>
&nbsp;&nbsp;
<a href=https://www.linkedin.com/in/karthiiks/><i class="fa-brands fa-linkedin"></i></a></li></ul></nav></footer></main></body></html>