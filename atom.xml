<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Karthik Selvam</title><description/><link>https://karthikselvam.com/</link><language>en</language><copyright>Copyright 2025, Ronalds Vilcins</copyright><lastBuildDate>Thu, 29 May 2025 00:00:00 +0000</lastBuildDate><generator>Hugo - gohugo.io</generator><docs>http://cyber.harvard.edu/rss/rss.html</docs><atom:link href="https://ronaldsvilcins.com/atom.xml" rel="self" type="application/atom+xml"/><item><title>Understanding Keystores, Certificates, and How Secure Communication Works in Java Apps</title><link>https://karthikselvam.com/posts/2025/05/29/secure_comm/</link><description>&lt;p>If you’re a developer or engineer starting with Java applications, you’ve probably come across terms like &lt;strong>keystore&lt;/strong>, &lt;strong>certificate&lt;/strong>, &lt;strong>private key&lt;/strong>, and &lt;strong>truststore&lt;/strong>. These are crucial when setting up secure communication between your app and others using SSL/TLS.&lt;/p>
&lt;p>Let’s break down what these terms mean and how they fit together — no fancy jargon, just simple explanations.&lt;/p>
&lt;hr>
&lt;h2 id="what-is-a-keystore">What Is a Keystore? &lt;a href="#what-is-a-keystore" class="hash">#&lt;/a>&lt;/h2>
&lt;p>A &lt;strong>keystore&lt;/strong> is a secure file that stores &lt;strong>private keys&lt;/strong> and &lt;strong>certificates&lt;/strong> your Java app needs to prove its identity and encrypt data.&lt;/p>
&lt;ul>
&lt;li>Private Key: A secret key only your app knows.&lt;/li>
&lt;li>Certificate: A public file that proves your app’s identity.&lt;/li>
&lt;/ul>
&lt;p>Think of a keystore like a locked box where you keep your secret keys and ID cards safely.&lt;/p>
&lt;hr>
&lt;h2 id="common-file-types-youll-see">Common File Types You’ll See &lt;a href="#common-file-types-youll-see" class="hash">#&lt;/a>&lt;/h2>
&lt;p>When dealing with certificates and keys, you might find files with these extensions:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>File Extension&lt;/th>
&lt;th>What It Is&lt;/th>
&lt;th>Purpose&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>.jks&lt;/code>&lt;/td>
&lt;td>Java KeyStore file&lt;/td>
&lt;td>Stores your private keys and certificates securely&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>.crt&lt;/code>&lt;/td>
&lt;td>Certificate file&lt;/td>
&lt;td>Your public certificate that others use to verify you&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>.key&lt;/code>&lt;/td>
&lt;td>Private key file&lt;/td>
&lt;td>Your secret private key&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>.req&lt;/code> (CSR)&lt;/td>
&lt;td>Certificate Signing Request&lt;/td>
&lt;td>A request you send to a Certificate Authority (CA) to get a certificate&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>.public&lt;/code>&lt;/td>
&lt;td>Public key file (less common)&lt;/td>
&lt;td>Contains just the public key part&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="how-does-this-fit-into-secure-communication">How Does This Fit Into Secure Communication? &lt;a href="#how-does-this-fit-into-secure-communication" class="hash">#&lt;/a>&lt;/h2>
&lt;p>Imagine you want your Java app to communicate securely over HTTPS or TLS.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Generate a Private Key (&lt;code>.key&lt;/code>)&lt;/strong>&lt;br>
This is your secret key that proves your identity.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Create a CSR (&lt;code>.req&lt;/code>)&lt;/strong>&lt;br>
A request you send to a trusted Certificate Authority (CA), containing your public key and info about your app.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Get a Certificate (&lt;code>.crt&lt;/code>) from the CA&lt;/strong>&lt;br>
The CA verifies you and issues a certificate, which is like an ID card signed by a trusted authority.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Import the Private Key and Certificate into a Keystore (&lt;code>.jks&lt;/code>)&lt;/strong>&lt;br>
Your Java app uses this keystore to present its identity and encrypt communications.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="sharing-certificates-with-other-apps">Sharing Certificates with Other Apps &lt;a href="#sharing-certificates-with-other-apps" class="hash">#&lt;/a>&lt;/h2>
&lt;p>Your app’s &lt;strong>private key is secret&lt;/strong> and never shared.&lt;/p>
&lt;p>Your app’s &lt;strong>certificate (&lt;code>.crt&lt;/code>) is shared&lt;/strong> with other apps or clients that want to communicate with you.&lt;/p>
&lt;ul>
&lt;li>Other apps import your &lt;code>.crt&lt;/code> into their &lt;strong>truststore&lt;/strong>, which is their list of trusted certificates.&lt;/li>
&lt;li>This lets them verify your app’s identity during the secure handshake.&lt;/li>
&lt;li>If your certificate is &lt;strong>self-signed&lt;/strong>, clients need to manually add your &lt;code>.crt&lt;/code> to their truststore.&lt;/li>
&lt;li>If your certificate is signed by a &lt;strong>public CA&lt;/strong>, most clients already trust it automatically.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="whats-the-difference-between-self-signed-and-ca-signed-certificates">What’s the Difference Between Self-Signed and CA-Signed Certificates? &lt;a href="#whats-the-difference-between-self-signed-and-ca-signed-certificates" class="hash">#&lt;/a>&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Self-Signed Certificate&lt;/th>
&lt;th>CA-Signed Certificate&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>You generate and sign your own certificate&lt;/td>
&lt;td>A trusted CA verifies your identity and signs your certificate&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Clients need to manually trust your certificate&lt;/td>
&lt;td>Clients trust it automatically because they trust the CA&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Often used for testing or internal apps&lt;/td>
&lt;td>Used for public websites and production systems&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="why-should-you-care">Why Should You Care? &lt;a href="#why-should-you-care" class="hash">#&lt;/a>&lt;/h2>
&lt;p>As a Staff Engineer or anyone responsible for system security, you’ll often:&lt;/p>
&lt;ul>
&lt;li>Set up or troubleshoot secure communication between services.&lt;/li>
&lt;li>Fix SSL/TLS errors caused by missing or untrusted certificates.&lt;/li>
&lt;li>Manage certificate renewals and updates.&lt;/li>
&lt;li>Help teams understand how certificates and keystores work together.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="final-thoughts">Final Thoughts &lt;a href="#final-thoughts" class="hash">#&lt;/a>&lt;/h2>
&lt;p>Understanding keystores, certificates, and how they work in Java apps is essential for secure software development. The next step is practicing creating keystores, generating CSRs, importing certificates, and testing secure connections.&lt;/p></description><author>ronalds.vilcins@gmail.com (Ronalds Vilcins)</author><guid>https://karthikselvam.com/posts/2025/05/29/secure_comm/</guid><pubDate>Thu, 29 May 2025 00:00:00 +0000</pubDate></item><item><title>Understanding PostgreSQL’s Write-Ahead Logging (WAL)</title><link>https://karthikselvam.com/posts/2025/05/22/postgres_wal/</link><description>&lt;p>PostgreSQL’s Write-Ahead Logging (WAL) is at the heart of its durability and crash recovery. If you’ve ever wondered how PostgreSQL ensures your data is safe—even in the event of a crash—this post will walk you through the architecture, flow, and the actual source code that makes it all work.&lt;/p>
&lt;hr>
&lt;h2 id="high-level-architecture--flow-of-wal">High-Level Architecture &amp;amp; Flow of WAL &lt;a href="#high-level-architecture--flow-of-wal" class="hash">#&lt;/a>&lt;/h2>
&lt;h3 id="what-is-wal">What is WAL? &lt;a href="#what-is-wal" class="hash">#&lt;/a>&lt;/h3>
&lt;p>WAL is a mechanism that ensures all changes to the database are first recorded in a log before being applied to the data files. This guarantees that, even if the system crashes, PostgreSQL can recover to a consistent state.&lt;/p>
&lt;h3 id="key-components">Key Components &lt;a href="#key-components" class="hash">#&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>WAL Buffers:&lt;/strong>&lt;br>
In-memory buffers that temporarily hold WAL records before they’re written to disk.&lt;/li>
&lt;li>&lt;strong>WAL Files:&lt;/strong>&lt;br>
On-disk files (in &lt;code>pg_wal/&lt;/code>), typically 16MB each, storing the WAL records.&lt;/li>
&lt;li>&lt;strong>WAL Writer Process:&lt;/strong>&lt;br>
A background process that flushes WAL buffers to disk.&lt;/li>
&lt;li>&lt;strong>Checkpointer:&lt;/strong>&lt;br>
Ensures data files are consistent with WAL.&lt;/li>
&lt;li>&lt;strong>Archiver:&lt;/strong>&lt;br>
Optionally archives completed WAL segments for point-in-time recovery (PITR).&lt;/li>
&lt;/ul>
&lt;h3 id="sequence-of-events">Sequence of Events &lt;a href="#sequence-of-events" class="hash">#&lt;/a>&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>Change Initiation:&lt;/strong>&lt;br>
A transaction modifies data (e.g., an &lt;code>INSERT&lt;/code>).&lt;/li>
&lt;li>&lt;strong>WAL Record Creation:&lt;/strong>&lt;br>
The change is encoded as a WAL record in memory.&lt;/li>
&lt;li>&lt;strong>WAL Buffering:&lt;/strong>&lt;br>
The WAL record is placed in the WAL buffers.&lt;/li>
&lt;li>&lt;strong>WAL Flush:&lt;/strong>&lt;br>
Before a transaction commits, its WAL records are flushed to disk.&lt;/li>
&lt;li>&lt;strong>WAL File Management:&lt;/strong>&lt;br>
WAL files are rotated, archived, and recycled as needed.&lt;/li>
&lt;li>&lt;strong>Crash Recovery:&lt;/strong>&lt;br>
On restart after a crash, WAL is replayed to bring the database to a consistent state.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="mapping-wal-to-the-postgresql-source-code">Mapping WAL to the PostgreSQL Source Code &lt;a href="#mapping-wal-to-the-postgresql-source-code" class="hash">#&lt;/a>&lt;/h2>
&lt;p>Let’s walk through the main code files and functions for each component.&lt;/p>
&lt;h3 id="1-wal-record-creation">1. WAL Record Creation &lt;a href="#1-wal-record-creation" class="hash">#&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>File:&lt;/strong> xlog.c&lt;/li>
&lt;li>&lt;strong>Key Struct:&lt;/strong> &lt;code>XLogRecord&lt;/code>&lt;/li>
&lt;li>&lt;strong>Key Functions:&lt;/strong>
&lt;ul>
&lt;li>&lt;code>XLogInsert()&lt;/code>: Called whenever a change is made (e.g., tuple insert/update/delete). Constructs a WAL record and appends it to the WAL buffers.&lt;/li>
&lt;li>&lt;code>XLogRegisterData()&lt;/code>, &lt;code>XLogRegisterBuffer()&lt;/code>: Used by lower-level code to register data and buffers that should be included in the WAL record.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="2-wal-buffering-and-flushing">2. WAL Buffering and Flushing &lt;a href="#2-wal-buffering-and-flushing" class="hash">#&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>File:&lt;/strong> xlog.c&lt;/li>
&lt;li>&lt;strong>Key Struct:&lt;/strong> &lt;code>XLogCtlData&lt;/code> (shared memory control structure for WAL)&lt;/li>
&lt;li>&lt;strong>Key Functions:&lt;/strong>
&lt;ul>
&lt;li>&lt;code>XLogWrite()&lt;/code>: Flushes WAL buffers to disk.&lt;/li>
&lt;li>&lt;code>XLogFlush()&lt;/code>: Ensures that WAL up to a certain point is safely on disk (called before commit).&lt;/li>
&lt;li>&lt;code>XLogBackgroundFlush()&lt;/code>: Used by the WAL writer background process.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="3-wal-writer-process">3. WAL Writer Process &lt;a href="#3-wal-writer-process" class="hash">#&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>File:&lt;/strong> walwriter.c&lt;/li>
&lt;li>&lt;strong>Key Function:&lt;/strong>
&lt;ul>
&lt;li>&lt;code>WalWriterMain()&lt;/code>: Main loop for the WAL writer background process, periodically flushing WAL buffers.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="4-wal-file-management">4. WAL File Management &lt;a href="#4-wal-file-management" class="hash">#&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>File:&lt;/strong> xlog.c&lt;/li>
&lt;li>&lt;strong>Key Functions:&lt;/strong>
&lt;ul>
&lt;li>&lt;code>XLogFileInit()&lt;/code>, &lt;code>XLogFileOpen()&lt;/code>, &lt;code>XLogFileClose()&lt;/code>: Manage creation, opening, and closing of WAL segment files.&lt;/li>
&lt;li>&lt;code>XLogFileName()&lt;/code>: Generates the filename for a given WAL segment.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="5-crash-recovery">5. Crash Recovery &lt;a href="#5-crash-recovery" class="hash">#&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>File:&lt;/strong> xlog.c&lt;/li>
&lt;li>&lt;strong>Key Function:&lt;/strong>
&lt;ul>
&lt;li>&lt;code>StartupXLOG()&lt;/code>: Main function for crash recovery; reads and replays WAL records.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="6-archiving">6. Archiving &lt;a href="#6-archiving" class="hash">#&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>File:&lt;/strong> xlogarchive.c&lt;/li>
&lt;li>&lt;strong>Key Functions:&lt;/strong>
&lt;ul>
&lt;li>&lt;code>XLogArchiveNotify()&lt;/code>, &lt;code>XLogArchiveCheckDone()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="important-structs-macros-and-configurations">Important Structs, Macros, and Configurations &lt;a href="#important-structs-macros-and-configurations" class="hash">#&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>&lt;code>XLogRecPtr&lt;/code>&lt;/strong>: 64-bit pointer to a WAL location.&lt;/li>
&lt;li>&lt;strong>&lt;code>XLogRecord&lt;/code>&lt;/strong>: Struct representing a single WAL record.&lt;/li>
&lt;li>&lt;strong>&lt;code>XLogCtlData&lt;/code>&lt;/strong>: Shared memory structure for WAL state.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Configuration Parameters (in &lt;code>postgresql.conf&lt;/code>):&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>wal_level&lt;/code>&lt;/li>
&lt;li>&lt;code>wal_buffers&lt;/code>&lt;/li>
&lt;li>&lt;code>wal_writer_delay&lt;/code>&lt;/li>
&lt;li>&lt;code>archive_mode&lt;/code>, &lt;code>archive_command&lt;/code>&lt;/li>
&lt;li>&lt;code>max_wal_size&lt;/code>, &lt;code>min_wal_size&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="step-by-step-exploration">Step-by-Step Exploration &lt;a href="#step-by-step-exploration" class="hash">#&lt;/a>&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>WAL Record Creation:&lt;/strong>&lt;br>
Start in &lt;code>xlog.c&lt;/code> with &lt;code>XLogInsert()&lt;/code>. See how a WAL record is constructed and added to the buffer. Explore how &lt;code>XLogRegisterData()&lt;/code> and &lt;code>XLogRegisterBuffer()&lt;/code> are used to build the record.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>WAL Buffering and Flushing:&lt;/strong>&lt;br>
Follow &lt;code>XLogWrite()&lt;/code> and &lt;code>XLogFlush()&lt;/code>. See how WAL buffers are managed and flushed to disk. Understand the role of &lt;code>XLogCtlData&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>WAL Writer Process:&lt;/strong>&lt;br>
Look at &lt;code>WalWriterMain()&lt;/code> in &lt;code>walwriter.c&lt;/code>. See how the background process periodically flushes WAL.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>WAL File Management:&lt;/strong>&lt;br>
Explore &lt;code>XLogFileInit()&lt;/code>, &lt;code>XLogFileOpen()&lt;/code>, etc. See how WAL files are created, opened, and rotated.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Crash Recovery:&lt;/strong>&lt;br>
Study &lt;code>StartupXLOG()&lt;/code>. See how WAL is replayed after a crash.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="conclusion">Conclusion &lt;a href="#conclusion" class="hash">#&lt;/a>&lt;/h2>
&lt;p>PostgreSQL’s WAL system is a robust, well-architected mechanism that ensures your data is safe and recoverable. By understanding both the high-level flow and the underlying source code, you gain insight into one of the most critical parts of PostgreSQL’s architecture.&lt;/p>
&lt;hr></description><author>ronalds.vilcins@gmail.com (Ronalds Vilcins)</author><guid>https://karthikselvam.com/posts/2025/05/22/postgres_wal/</guid><pubDate>Thu, 22 May 2025 00:00:00 +0000</pubDate></item><item><title>Awesome Stuff</title><link>https://karthikselvam.com/posts/2023/02/25/awesome_stuff/</link><description>&lt;p>&lt;strong>1. &lt;a href="https://github.com/kilimchoi/engineering-blogs">Engineering Blogs&lt;/a>&lt;/strong>&lt;/p>
&lt;p>&lt;strong>2. &lt;a href="https://www.falkhausen.de/index.html">Java Packages with UML Diagrams&lt;/a>&lt;/strong>&lt;/p>
&lt;p>&lt;strong>3. &lt;a href="https://github.com/hadign20/student-career-handbook/blob/master/domain-specific/a-deeper-understanding-of-java.md">Java Resources&lt;/a>&lt;/strong>&lt;/p>
&lt;p>&lt;strong>4. &lt;a href="https://aosabook.org/en/">The Architecture of Open Source Applications&lt;/a>&lt;/strong>&lt;/p>
&lt;p>&lt;strong>5. &lt;a href="https://books.dwf.dev/docs/system-design/c0">System Design&lt;/a>&lt;/strong>&lt;/p></description><author>ronalds.vilcins@gmail.com (Ronalds Vilcins)</author><guid>https://karthikselvam.com/posts/2023/02/25/awesome_stuff/</guid><pubDate>Sat, 25 Feb 2023 00:00:00 +0000</pubDate></item><item><title>Fundamentals of Multithreading</title><link>https://karthikselvam.com/posts/2023/01/23/threads/</link><description>&lt;p>&lt;strong>1. Thread creation&lt;/strong> : In Java, you can create a thread by either extending the Thread class or implementing the Runnable interface. Here&amp;rsquo;s how you can do it:&lt;/p>
&lt;ul>
&lt;li>Extending the Thread class:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java">public class MyThread extends Thread {
public void run() {
// code to be executed in this thread
}
}
&lt;/code>&lt;/pre>
&lt;p>You can create an instance of the MyThread class and start the thread using the start() method:&lt;/p>
&lt;pre>&lt;code class="language-java">MyThread myThread = new MyThread();
myThread.start();
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Implementing the Runnable interface:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java">public class MyRunnable implements Runnable {
public void run() {
// code to be executed in this thread
}
}
&lt;/code>&lt;/pre>
&lt;p>You can create an instance of the MyRunnable class and pass it to a Thread object&amp;rsquo;s constructor:&lt;/p>
&lt;pre>&lt;code class="language-java">MyRunnable myRunnable = new MyRunnable();
Thread thread = new Thread(myRunnable);
thread.start();
&lt;/code>&lt;/pre>
&lt;p>In both cases, the run() method contains the code that will be executed when the thread is started. You should not call the run() method directly, but rather use the start() method to start the thread.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>2. Thread Termination&lt;/strong> :
Following are reasons to terminate a thread:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Threads in a computer consume various resources, such as memory, kernel resources, CPU cycles, and cache memory.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>If a thread finished its work, but the application is still running we want to clean up the thread&amp;rsquo;s resources.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>If a thread is misbehaving, we want to stop it.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The application will not stop as long as at least one thread is still running.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>In Java, you can terminate a thread by calling the interrupt() method on the thread object. This method sets a flag on the thread to indicate that it should stop executing. However, it is up to the thread&amp;rsquo;s code to check for the interrupt flag and terminate gracefully.&lt;/p>
&lt;pre>&lt;code class="language-java">public class MyThread extends Thread {
@Override
public void run() {
while (!Thread.currentThread().isInterrupted()) {
// do some work
}
System.out.println(&amp;quot;Thread is terminating.&amp;quot;);
}
}
public class Main {
public static void main(String[] args) {
MyThread thread = new MyThread();
thread.start();
// Interrupt the thread
thread.interrupt();
}
}
&lt;/code>&lt;/pre>
&lt;p>In this example, the MyThread class extends the Thread class and overrides the run() method to do some work in a loop. Inside the loop, the thread checks if it has been interrupted using the isInterrupted() method.&lt;/p>
&lt;p>In the Main class, we create an instance of MyThread and start it. When the interrupt() method is called, the isInterrupted() method in the MyThread class will return true, causing the thread to exit the loop and terminate gracefully.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>3. Daemon Threads&lt;/strong> :
In Java, a daemon thread is a type of thread that runs in the background and does not prevent the Java Virtual Machine (JVM) from exiting when the program finishes execution.&lt;/p>
&lt;p>Daemon threads are typically used for tasks that need to run continuously in the background, such as garbage collection or other system-level tasks. They are also commonly used in server applications to perform tasks like cleaning up old connections or handling periodic maintenance tasks.&lt;/p>
&lt;p>To create a daemon thread in Java, you can use the setDaemon() method on a Thread object. For example, the following code creates a new thread and sets it as a daemon thread:&lt;/p>
&lt;pre>&lt;code class="language-java">Thread myThread = new Thread(new Runnable() {
public void run() {
// Do some background task here
}
});
myThread.setDaemon(true);
myThread.start();
&lt;/code>&lt;/pre>
&lt;p>Once a thread is set as a daemon thread, you cannot change it back to a non-daemon thread.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>4. Joining Threads&lt;/strong> :&lt;/p>
&lt;p>Joining threads in Java is done using the join() method, which allows one thread to wait for another thread to complete before continuing. Here&amp;rsquo;s a simple example of how to use the join() method to join two threads:&lt;/p>
&lt;pre>&lt;code class="language-java">public class JoinExample {
public static void main(String[] args) throws InterruptedException {
Thread t1 = new Thread(() -&amp;gt; {
System.out.println(&amp;quot;Thread 1 is running&amp;quot;);
try {
Thread.sleep(2000); // simulate some work being done
} catch (InterruptedException e) {
System.out.println(&amp;quot;Thread 1 was interrupted&amp;quot;);
}
System.out.println(&amp;quot;Thread 1 is finished&amp;quot;);
});
Thread t2 = new Thread(() -&amp;gt; {
System.out.println(&amp;quot;Thread 2 is running&amp;quot;);
try {
Thread.sleep(1000); // simulate some work being done
} catch (InterruptedException e) {
System.out.println(&amp;quot;Thread 2 was interrupted&amp;quot;);
}
System.out.println(&amp;quot;Thread 2 is finished&amp;quot;);
});
t1.start();
t2.start();
// wait for both threads to finish
t1.join();
t2.join();
System.out.println(&amp;quot;Both threads have finished&amp;quot;);
}
}
&lt;/code>&lt;/pre>
&lt;p>In this example, we create two threads t1 and t2 and start them. We then use the join() method to wait for both threads to finish before printing out a message indicating that both threads have finished.&lt;/p>
&lt;p>When t1.join() and t2.join() are called, the main thread will block and wait until both t1 and t2 have finished executing. Once both threads have completed, the main thread will continue executing and print out the final message.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>5. Resource Sharing in Threads&lt;/strong>&lt;/p>
&lt;p>In Java, resource sharing can be achieved using the concept of synchronized monitors. A synchronized monitor is a mechanism that allows only one thread to access a shared resource at a time.&lt;/p>
&lt;p>To use synchronized monitors in Java, you can use the synchronized keyword to define a block of code that needs to be executed by only one thread at a time. The synchronized keyword can be applied to a method or a block of code.&lt;/p>
&lt;p>Here&amp;rsquo;s an example of using synchronized monitors to share a resource in Java:&lt;/p>
&lt;pre>&lt;code class="language-java">public class SharedResource {
private int value;
public synchronized void increment() {
value++;
}
public synchronized int getValue() {
return value;
}
}
public class ResourceSharingExample {
public static void main(String[] args) {
SharedResource sharedResource = new SharedResource();
// create multiple threads to access the shared resource
Thread t1 = new Thread(() -&amp;gt; {
for (int i = 0; i &amp;lt; 1000; i++) {
sharedResource.increment();
}
});
Thread t2 = new Thread(() -&amp;gt; {
for (int i = 0; i &amp;lt; 1000; i++) {
sharedResource.increment();
}
});
// start the threads
t1.start();
t2.start();
// wait for the threads to finish
try {
t1.join();
t2.join();
} catch (InterruptedException e) {
e.printStackTrace();
}
// print the final value of the shared resource
System.out.println(&amp;quot;Value: &amp;quot; + sharedResource.getValue());
}
}
&lt;/code>&lt;/pre>
&lt;p>In this example, the SharedResource class represents a shared resource that contains a single integer value. The increment() method and getValue() method are both marked as synchronized, which means that only one thread can access them at a time.&lt;/p>
&lt;p>The ResourceSharingExample class creates two threads that access the shared resource using the increment() method. The threads run concurrently, but because of the synchronized monitors, only one thread can execute the increment() method at a time. The final value of the shared resource is printed at the end of the program, which should be 2000 in this case.&lt;/p>
&lt;p>We also achieve some result using Object lock instead of synchronized monitors in Java.&lt;/p>
&lt;pre>&lt;code class="language-java">public class SharedResource {
private int value;
private final Object lock = new Object();
public void increment() {
synchronized (lock) {
value++;
}
}
public int getValue() {
synchronized (lock) {
return value;
}
}
}
public class ResourceSharingExample {
public static void main(String[] args) {
SharedResource sharedResource = new SharedResource();
// create multiple threads to access the shared resource
Thread t1 = new Thread(() -&amp;gt; {
for (int i = 0; i &amp;lt; 1000; i++) {
sharedResource.increment();
}
});
Thread t2 = new Thread(() -&amp;gt; {
for (int i = 0; i &amp;lt; 1000; i++) {
sharedResource.increment();
}
});
// start the threads
t1.start();
t2.start();
// wait for the threads to finish
try {
t1.join();
t2.join();
} catch (InterruptedException e) {
e.printStackTrace();
}
// print the final value of the shared resource
System.out.println(&amp;quot;Value: &amp;quot; + sharedResource.getValue());
}
}
&lt;/code>&lt;/pre>
&lt;p>Using mutiple object locks threads can access the shared resources concurrently without interfering with each other.&lt;/p>
&lt;pre>&lt;code class="language-java">public class SharedResource {
private int value1;
private int value2;
private final Object lock1 = new Object();
private final Object lock2 = new Object();
public void incrementValue1() {
synchronized (lock1) {
value1++;
}
}
public int getValue1() {
synchronized (lock1) {
return value1;
}
}
public void incrementValue2() {
synchronized (lock2) {
value2++;
}
}
public int getValue2() {
synchronized (lock2) {
return value2;
}
}
}
public class ResourceSharingExample {
public static void main(String[] args) {
SharedResource sharedResource = new SharedResource();
// create multiple threads to access the shared resource
Thread t1 = new Thread(() -&amp;gt; {
for (int i = 0; i &amp;lt; 1000; i++) {
sharedResource.incrementValue1();
}
});
Thread t2 = new Thread(() -&amp;gt; {
for (int i = 0; i &amp;lt; 1000; i++) {
sharedResource.incrementValue2();
}
});
// start the threads
t1.start();
t2.start();
// wait for the threads to finish
try {
t1.join();
t2.join();
} catch (InterruptedException e) {
e.printStackTrace();
}
// print the final values of the shared resources
System.out.println(&amp;quot;Value1: &amp;quot; + sharedResource.getValue1());
System.out.println(&amp;quot;Value2: &amp;quot; + sharedResource.getValue2());
}
}
&lt;/code>&lt;/pre>
&lt;p>In this example, the SharedResource class contains two object locks, lock1 and lock2, and two methods for each value, incrementValue1(), getValue1(), incrementValue2(), and getValue2(). The incrementValue1() method and getValue1() method use lock1 to synchronize access to value1, while the incrementValue2() method and getValue2() method use lock2 to synchronize access to value2.&lt;/p>
&lt;p>The ResourceSharingExample class creates two threads that access the shared resources using incrementValue1() and incrementValue2() methods. Because two different object locks are used to synchronize access to two different values, the &lt;strong>threads can access the shared resources concurrently without interfering with each other&lt;/strong>. The final values of the shared resources are printed at the end of the program.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>6. Reentrant lock&lt;/strong>&lt;/p>
&lt;p>A ReentrantLock is a synchronization mechanism in Java that provides a way to protect shared resources from simultaneous access by multiple threads. It is called &amp;ldquo;reentrant&amp;rdquo; because a thread that already holds the lock can acquire it again without blocking, unlike traditional synchronization using the synchronized keyword.&lt;/p>
&lt;pre>&lt;code class="language-java">import java.util.concurrent.locks.ReentrantLock;
public class SharedResource {
private int value;
private ReentrantLock lock = new ReentrantLock();
public void incrementValue() {
lock.lock();
try {
value++;
} finally {
lock.unlock();
}
}
public int getValue() {
lock.lock();
try {
return value;
} finally {
lock.unlock();
}
}
}
public class ResourceSharingExample {
public static void main(String[] args) {
SharedResource sharedResource = new SharedResource();
// create multiple threads to access the shared resource
Thread t1 = new Thread(() -&amp;gt; {
for (int i = 0; i &amp;lt; 1000; i++) {
sharedResource.incrementValue();
}
});
Thread t2 = new Thread(() -&amp;gt; {
for (int i = 0; i &amp;lt; 1000; i++) {
sharedResource.incrementValue();
}
});
// start the threads
t1.start();
t2.start();
// wait for the threads to finish
try {
t1.join();
t2.join();
} catch (InterruptedException e) {
e.printStackTrace();
}
// print the final value of the shared resource
System.out.println(&amp;quot;Value: &amp;quot; + sharedResource.getValue());
}
}
&lt;/code>&lt;/pre>
&lt;p>In this example, the SharedResource class contains a single ReentrantLock and two methods for incrementing and retrieving the value variable. The lock object is used to synchronize access to the value variable.&lt;/p>
&lt;p>The ResourceSharingExample class creates two threads that access the shared resource using the incrementValue() method. Because a ReentrantLock is used to synchronize access to the shared resource, the threads can access the shared resource concurrently without interfering with each other.&lt;/p>
&lt;p>ReentrantLock is like a special key that allows threads to take turns accessing a shared resource. And if a thread already has the key, it can use it again without waiting in line. It provides query methods for testing lock&amp;rsquo;s internal state.&lt;/p>
&lt;p>Example of using ReentrantLock and tryLock() method in Java:&lt;/p>
&lt;pre>&lt;code class="language-java">import java.util.concurrent.locks.ReentrantLock;
public class Example {
public static void main(String[] args) {
ReentrantLock lock = new ReentrantLock();
// acquire the lock using tryLock() method
boolean isLockAcquired = lock.tryLock();
if (isLockAcquired) {
try {
// perform critical section operations here
System.out.println(&amp;quot;Lock acquired and critical section entered.&amp;quot;);
} finally {
// release the lock
lock.unlock();
System.out.println(&amp;quot;Lock released.&amp;quot;);
}
} else {
System.out.println(&amp;quot;Could not acquire lock. Another thread is holding the lock.&amp;quot;);
}
}
}
&lt;/code>&lt;/pre>
&lt;p>Example of using ReentrantReadWriteLock and tryLock() method in Java:&lt;/p>
&lt;pre>&lt;code class="language-java">import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
public class Example {
private Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
private ReadWriteLock lock = new ReentrantReadWriteLock();
public void put(String key, String value) {
lock.writeLock().lock(); // acquire write lock
try {
map.put(key, value); // perform write operation
} finally {
lock.writeLock().unlock(); // release write lock
}
}
public String get(String key) {
lock.readLock().lock(); // acquire read lock
try {
return map.get(key); // perform read operation
} finally {
lock.readLock().unlock(); // release read lock
}
}
}
&lt;/code>&lt;/pre>
&lt;p>In this example, we have a Map object that is accessed by multiple threads. To ensure thread safety and prevent race conditions, we use a ReadWriteLock to control access to the map.&lt;/p>
&lt;p>The put() method acquires a write lock using the writeLock() method, performs a write operation on the map, and then releases the write lock using the unlock() method.&lt;/p>
&lt;p>The get() method acquires a read lock using the readLock() method, performs a read operation on the map, and then releases the read lock using the unlock() method.&lt;/p>
&lt;p>With this approach, multiple threads can simultaneously read from the map, but only one thread can write to the map at a time. This can significantly improve performance in scenarios where reads are much more frequent than writes.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>7. Volatile Keyword&lt;/strong>&lt;/p>
&lt;p>In Java, the volatile keyword is used as a modifier to indicate that a variable&amp;rsquo;s value may be modified by multiple threads at the same time.&lt;/p>
&lt;p>When a variable is marked as volatile, the JVM ensures that any write to that variable is immediately visible to other threads that may access it. This means that changes made to the variable by one thread will be immediately reflected in the value seen by other threads. Without the volatile keyword, there is no guarantee that changes made by one thread will be immediately visible to another thread, which can lead to hard-to-detect bugs.&lt;/p>
&lt;p>The volatile keyword can be used with any primitive type, as well as with references to objects. However, it&amp;rsquo;s important to note that using volatile does not provide atomicity, which means that if multiple threads try to modify the same variable at the same time, race conditions and inconsistencies can still occur.&lt;/p>
&lt;p>In general, the volatile keyword should only be used when there is a specific need for multiple threads to access the same variable, and the programmer is sure that the volatile variable will be accessed in a safe and consistent way.&lt;/p>
&lt;p>Here&amp;rsquo;s an example to illustrate the use of volatile keyword in Java:&lt;/p>
&lt;pre>&lt;code class="language-java">public class Counter {
private volatile int count;
public synchronized void increment() {
count++;
}
public int getCount() {
return count;
}
}
&lt;/code>&lt;/pre>
&lt;p>In this example, we have a Counter class with a private volatile integer field called count. The increment() method is used to increment the value of count by one, and the getCount() method returns the current value of count.&lt;/p>
&lt;p>Without the volatile keyword, there is no guarantee that changes made to count by one thread will be immediately visible to another thread. However, since count is marked as volatile, the JVM ensures that any write to count is immediately visible to other threads that may access it.&lt;/p>
&lt;p>Consider the following example usage of the Counter class by multiple threads:&lt;/p>
&lt;pre>&lt;code class="language-java">public class Main {
public static void main(String[] args) {
Counter counter = new Counter();
Thread thread1 = new Thread(() -&amp;gt; {
for (int i = 0; i &amp;lt; 10000; i++) {
counter.increment();
}
});
Thread thread2 = new Thread(() -&amp;gt; {
for (int i = 0; i &amp;lt; 10000; i++) {
counter.increment();
}
});
thread1.start();
thread2.start();
try {
thread1.join();
thread2.join();
} catch (InterruptedException e) {
e.printStackTrace();
}
System.out.println(&amp;quot;Final count: &amp;quot; + counter.getCount());
}
}
&lt;/code>&lt;/pre>
&lt;p>In this example, we create two threads, thread1 and thread2, which both increment the Counter object&amp;rsquo;s count field 10,000 times. We then wait for both threads to complete using the join() method, and output the final value of count.&lt;/p>
&lt;p>Without the volatile keyword on the count field in the Counter class, there is no guarantee that the final value of count will be 20,000. However, with count marked as volatile, we can be sure that changes made by one thread will be immediately visible to the other thread, and the final value of count will be 20,000.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>8. Deadlocks&lt;/strong>
In Java, a deadlock occurs when two or more threads are blocked, waiting for each other to release the locks they hold. As a result, none of the threads can make progress and the program hangs.&lt;/p>
&lt;p>Here&amp;rsquo;s an example to illustrate how a deadlock can occur in Java:&lt;/p>
&lt;pre>&lt;code class="language-java">public class DeadlockExample {
private Object lock1 = new Object();
private Object lock2 = new Object();
public void method1() {
synchronized (lock1) {
System.out.println(&amp;quot;Acquired lock1 in method1&amp;quot;);
try {
Thread.sleep(1000);
} catch (InterruptedException e) {}
synchronized (lock2) {
System.out.println(&amp;quot;Acquired lock2 in method1&amp;quot;);
}
}
}
public void method2() {
synchronized (lock2) {
System.out.println(&amp;quot;Acquired lock2 in method2&amp;quot;);
try {
Thread.sleep(1000);
} catch (InterruptedException e) {}
synchronized (lock1) {
System.out.println(&amp;quot;Acquired lock1 in method2&amp;quot;);
}
}
}
public static void main(String[] args) {
final DeadlockExample example = new DeadlockExample();
Thread thread1 = new Thread(new Runnable() {
public void run() {
example.method1();
}
});
Thread thread2 = new Thread(new Runnable() {
public void run() {
example.method2();
}
});
thread1.start();
thread2.start();
}
}
&lt;/code>&lt;/pre>
&lt;p>In this example, there are two methods, method1() and method2(), which each synchronize on a different lock. The main() method creates two threads that each call one of these methods.&lt;/p>
&lt;p>Now, suppose that thread1 acquires lock1 and then calls method2(), which tries to acquire lock2. At the same time, thread2 has already acquired lock2 and is trying to acquire lock1. Both threads are blocked waiting for the other thread to release its lock, causing a deadlock.&lt;/p>
&lt;p>Deadlock can occur in a concurrent system when the following conditions are met:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Mutual Exclusion: At least one resource is held in a mutually exclusive mode, meaning only one thread can use it at a time.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Hold and Wait: A thread is holding at least one resource and is waiting to acquire additional resources that are currently held by other threads.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>No Preemption: Resources cannot be preempted or taken away from threads that are holding them. The only way to release a resource is for the thread to voluntarily release it.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Circular Wait: A circular chain of threads exists, where each thread is waiting for a resource that is held by the next thread in the chain. In other words, there is a cycle in the resource allocation graph.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>To avoid deadlocks, you can use some techniques like:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Acquire locks in a fixed order.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Use timeouts when acquiring locks to avoid indefinitely waiting for a lock.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Use tryLock() instead of synchronized blocks to acquire locks in a non-blocking way.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Use higher-level concurrency utilities like java.util.concurrent classes, which handle synchronization and - locking automatically.&lt;/p>
&lt;/li>
&lt;/ul></description><author>ronalds.vilcins@gmail.com (Ronalds Vilcins)</author><guid>https://karthikselvam.com/posts/2023/01/23/threads/</guid><pubDate>Mon, 23 Jan 2023 00:00:00 +0000</pubDate></item><item><title>Handling Transactions in Microservices</title><link>https://karthikselvam.com/posts/2023/01/23/transactions/</link><description>&lt;p>Handling transactions involving more than one microservice can be challenging since each microservice typically has its own data store and transaction management. However, there are several best practices that can help to ensure consistency and reliability across microservices:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>The Saga pattern&lt;/strong>: This involves breaking the transaction into multiple smaller transactions, each of which is handled by a separate microservice. If a transaction fails, the other services can be rolled back, ensuring that the system remains consistent. Let&amp;rsquo;s say you have a system where a user can place an order that involves multiple microservices. The order might involve checking inventory levels, processing payments, and shipping products. You can use the Saga pattern to handle this transaction by breaking it down into smaller transactions, each handled by a separate microservice. If one of the transactions fails, the other transactions can be rolled back, ensuring that the system remains consistent. For example, the payment service fails to process a payment. The shipping service can be notified to cancel the shipment, and the inventory service can be notified to restock the item. This ensures that the system remains consistent even though one of the transactions failed.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Distributed transaction coordinator&lt;/strong>: A distributed transaction coordinator can help to manage transactions across multiple microservices. The coordinator can ensure that all transactions are either committed or rolled back as a single unit, ensuring consistency across the system.For example, you could use a tool like Apache Kafka to implement a distributed transaction coordinator. When a user places an order, the order microservice can publish a message to a Kafka topic. Each microservice that needs to handle the transaction can subscribe to the topic and perform its own transaction. If one of the microservices fails, the coordinator can ensure that all transactions are either committed or rolled back as a single unit, ensuring consistency across the system.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Compensating transactions&lt;/strong>: A compensating transaction is a transaction that undoes the effects of a previous transaction. This can be used to handle failures in the system by rolling back the changes made by previous transactions and restoring the system to its previous state.For example, Let&amp;rsquo;s say you have a system where a user can transfer money between accounts. This transaction involves two microservices: one to debit the account and another to credit the account. If the credit service fails, you can use a compensating transaction to handle the failure. The debit service can be notified to reverse the debit transaction, ensuring that the system remains consistent.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Event-driven architectures&lt;/strong>: In an event-driven architecture, each microservice publishes events when it completes a transaction. Other microservices can subscribe to these events and use them to trigger their own transactions. This can help to ensure consistency across the system and reduce the risk of failures.For example, Let&amp;rsquo;s say you have a system where a user can place an order that involves multiple microservices. Each microservice can publish an event when it completes a transaction. For example, the inventory service can publish an event when it updates the inventory level, and the shipping service can publish an event when it ships the product. Other microservices can subscribe to these events and use them to trigger their own transactions. This can help to ensure consistency across the system and reduce the risk of failures.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Idempotency&lt;/strong>: Idempotency is the property of a system where performing the same operation multiple times has the same result as performing it once. By designing microservices to be idempotent, you can reduce the risk of failures and ensure consistency across the system.For example, Let&amp;rsquo;s say you have a system where a user can update their profile information. To ensure idempotency, you can design the microservice to only update the profile if the request includes a unique identifier, such as a UUID. If the same request is made multiple times, the microservice will recognize the duplicate request and return the same result as the original request. This ensures that the system remains consistent even if the same request is made multiple times.&lt;/p>
&lt;/li>
&lt;/ol></description><author>ronalds.vilcins@gmail.com (Ronalds Vilcins)</author><guid>https://karthikselvam.com/posts/2023/01/23/transactions/</guid><pubDate>Mon, 23 Jan 2023 00:00:00 +0000</pubDate></item><item><title>Arrays</title><link>https://karthikselvam.com/posts/2023/01/22/behavioral_questions/</link><description>&lt;p>&lt;strong>1. Tell me about a time when you went above and beyond to meet customer needs.&lt;/strong>
Situation: In my previous role as a Senior Software Development Engineer at [Company Name], we had a critical customer who relied heavily on one of our core services for their day-to-day operations. The service was generally reliable, but we noticed an increase in latency during peak hours, which started to affect the customer’s business. They were experiencing delays that disrupted their workflow, leading to frustration and potential loss of business for them.&lt;/p>
&lt;p>Task: As the senior engineer responsible for the service, I was tasked with investigating the root cause of the latency and finding a solution. The challenge was that this issue was intermittent and had not surfaced in our regular testing or monitoring processes. Additionally, the customer had an important launch event in two weeks, and they needed this issue resolved before then.&lt;/p>
&lt;p>Action:
I decided to go beyond the typical debugging process and took the following steps:&lt;/p>
&lt;p>Deep Dive into Logs: I led a detailed analysis of logs and metrics from both our production and pre-production environments to identify patterns during peak times. I involved the DevOps team to help simulate the exact production load in a controlled environment.&lt;/p>
&lt;p>Customer Collaboration: I personally reached out to the customer’s technical team to understand the specific scenarios where they were facing issues. This allowed me to replicate their exact usage patterns and identify bottlenecks that weren’t evident in generic load testing.&lt;/p>
&lt;p>Optimizing the Code: Upon identifying the bottleneck, I worked on optimizing the service&amp;rsquo;s code, specifically focusing on the database queries and caching mechanisms that were causing the delays. I also refactored parts of the code to make the service more resilient under heavy load.&lt;/p>
&lt;p>Proactive Communication: Throughout this process, I kept the customer informed about our progress, ensuring that they felt supported and knew we were prioritizing their needs.&lt;/p>
&lt;p>Testing and Deployment: Once the optimizations were implemented, I coordinated with the QA team to conduct rigorous testing. I also worked with the DevOps team to deploy the changes in a phased manner, closely monitoring the service during the deployment to ensure there were no regressions.&lt;/p>
&lt;p>Result:
The optimization efforts reduced the service&amp;rsquo;s latency by 60% during peak hours, which significantly improved the customer’s experience. The issue was resolved well before their launch event, and they were able to proceed without any disruptions. The customer was highly appreciative of the proactive approach and the level of detail we went into to solve their problem. This not only strengthened our relationship with them but also led to a long-term partnership and additional business opportunities.&lt;/p>
&lt;p>Reflection:
This experience reinforced the importance of being customer-obsessed, especially in a senior role. Going beyond the expected duties, engaging directly with the customer, and ensuring that their needs are met, even under tight deadlines, is crucial in building trust and delivering exceptional service.&lt;/p>
&lt;p>&lt;strong>2. Can you provide an example of a time when you received negative customer feedback? What did you do to address it?&lt;/strong>
Situation:
In my previous role as a Senior Software Development Engineer at [Company Name], we launched a new version of our platform with several major updates and features. However, shortly after the release, we started receiving negative feedback from a key customer segment. They reported that the new user interface was confusing, and some of the features they relied on were either harder to access or didn’t work as expected.&lt;/p>
&lt;p>Task:
As the senior engineer responsible for this project, my task was to address the feedback promptly. This involved understanding the root cause of the issues, devising a plan to resolve them, and restoring customer satisfaction.&lt;/p>
&lt;p>Action:
To tackle this, I took the following steps:&lt;/p>
&lt;p>Engage Directly with Customers:
I initiated direct communication with the affected customers to gather detailed feedback. I set up calls and meetings with key users to understand their specific pain points and how the changes impacted their workflow. This allowed me to get a clearer picture of the issues beyond what was reported in generic feedback channels.&lt;/p>
&lt;p>Analyze the Feedback:
I worked closely with the UX team to analyze the feedback and identify common patterns. We discovered that the navigation changes we made, though intended to streamline the interface, had unintentionally made it harder for some users to complete their tasks efficiently. Additionally, there were a few bugs in the new features that had slipped through our testing process.&lt;/p>
&lt;p>Implement Rapid Improvements:
Based on the feedback, I prioritized quick wins that could immediately improve the user experience. We rolled out a patch that fixed the bugs and made some immediate adjustments to the navigation flow based on customer input.
I also proposed and led a short-term project to create customizable interface options, allowing users to revert to a layout closer to the previous version if they preferred it.&lt;/p>
&lt;p>Proactive Communication:
Throughout this process, I maintained open lines of communication with the affected customers, providing regular updates on our progress and the changes we were making. I also took the opportunity to thank them for their feedback and assured them that we were committed to addressing their concerns.&lt;/p>
&lt;p>Post-Release Follow-Up:
After the changes were implemented, I followed up with the customers to gather additional feedback and ensure the modifications addressed their issues. I also monitored the platform for further feedback to ensure the improvements were well-received.&lt;/p>
&lt;p>Result:
The quick response and the adjustments we made led to a significant reduction in customer complaints, and the feedback shifted from negative to positive. The customizable interface option was particularly well-received, as it gave users more control over their experience. Our relationship with the customers improved, and they appreciated our responsiveness and willingness to adapt based on their needs.&lt;/p>
&lt;p>Reflection:
This experience reinforced the importance of actively listening to customer feedback and being agile in responding to it. By engaging directly with customers and being transparent about the steps we were taking, we were able to turn a negative situation into a positive one, ultimately enhancing the customer experience and strengthening our product.&lt;/p>
&lt;p>&lt;strong>3. Tell me about a time when you had to deliver a product or feature under a tight deadline. How did you ensure it met customer expectations??&lt;/strong>
Situation: At my previous company, we had a client who requested a new feature for their application just weeks before their product launch. The feature was crucial for their marketing campaign, and they needed it delivered within an extremely tight deadline of two weeks.&lt;/p>
&lt;p>Task: As the lead developer, my task was to ensure that we delivered a fully functional, high-quality feature on time, without compromising our existing development schedule.&lt;/p>
&lt;p>Action: I started by breaking down the feature requirements into manageable tasks and prioritized them based on the client’s most critical needs. I then assembled a small team of developers and designers, ensuring everyone was clear on their responsibilities and the importance of meeting the deadline.&lt;/p>
&lt;p>To maximize efficiency, I implemented daily stand-up meetings to track progress, identify any roadblocks early, and make quick decisions. I also set up a continuous integration pipeline to automate testing and deployment, so that we could catch and fix bugs as early as possible.&lt;/p>
&lt;p>Throughout the development process, I maintained close communication with the client to keep them updated on our progress and to manage their expectations. This also allowed us to get quick feedback on the feature’s implementation, ensuring we were aligned with their vision.&lt;/p>
&lt;p>Result: We successfully delivered the feature on time, and it met the client’s expectations in terms of functionality and quality. The client was impressed with our ability to meet such a tight deadline without compromising on the end product. This experience not only strengthened our relationship with the client but also demonstrated our team’s ability to work efficiently under pressure.&lt;/p>
&lt;p>&lt;strong>4. Tell about a time you disagreed with your teamamt?&lt;/strong>
Situation:
In one of my previous projects, we were tasked with breaking down a monolithic application into microservices. The goal was to improve scalability and maintainability.&lt;/p>
&lt;p>Task:
My role was to design the microservices architecture and ensure a smooth transition from the monolithic system. However, a teammate and I had a fundamental disagreement about how to approach this.&lt;/p>
&lt;p>Action:
My teammate advocated for a &amp;ldquo;big bang&amp;rdquo; approach, where we would decompose the entire application at once and deploy all microservices simultaneously. They believed this would be more efficient and faster. I, on the other hand, favored an incremental approach. I suggested breaking down the application one component at a time, deploying each microservice individually, and ensuring that each one worked correctly before moving on to the next. I felt this would minimize risk and make it easier to identify and fix issues.&lt;/p>
&lt;p>To resolve the disagreement, we decided to:
Discuss Concerns: We sat down and outlined the pros and cons of both approaches. I highlighted the potential risks of a &amp;ldquo;big bang&amp;rdquo; deployment, such as the difficulty in debugging and the high impact of potential failures.
Run Experiments: We agreed to conduct a proof-of-concept by splitting one part of the monolith into a microservice and deploying it. This would give us insights into the complexity and potential issues we might face.
Consult with Stakeholders: We brought in our tech lead and a few other senior engineers to get their perspectives and advice. They supported the idea of an incremental approach given the complexity of our system.&lt;/p>
&lt;p>Result:
The proof-of-concept was successful and demonstrated the benefits of an incremental approach. It allowed us to catch and resolve issues early, and it provided the team with valuable learning experiences. As a result, we adopted the incremental approach for the rest of the project.&lt;/p>
&lt;p>In the end, the project was a success. The incremental approach proved to be effective in managing risks and ensuring a smooth transition to microservices. This experience reinforced the importance of open communication, experimentation, and involving stakeholders in decision-making processes.&lt;/p></description><author>ronalds.vilcins@gmail.com (Ronalds Vilcins)</author><guid>https://karthikselvam.com/posts/2023/01/22/behavioral_questions/</guid><pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate></item></channel></rss>